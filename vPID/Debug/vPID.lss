
vPID.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000fe  00800100  00003404  00003498  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00003404  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000008b6  008001fe  008001fe  00003596  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00003596  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000035c8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000368  00000000  00000000  00003604  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00004d1c  00000000  00000000  0000396c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000016ff  00000000  00000000  00008688  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000029a9  00000000  00000000  00009d87  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000a14  00000000  00000000  0000c730  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000012b8  00000000  00000000  0000d144  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00003d36  00000000  00000000  0000e3fc  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000310  00000000  00000000  00012132  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	4c c1       	rjmp	.+664    	; 0x29a <__ctors_end>
       2:	00 00       	nop
       4:	68 c1       	rjmp	.+720    	; 0x2d6 <__bad_interrupt>
       6:	00 00       	nop
       8:	66 c1       	rjmp	.+716    	; 0x2d6 <__bad_interrupt>
       a:	00 00       	nop
       c:	64 c1       	rjmp	.+712    	; 0x2d6 <__bad_interrupt>
       e:	00 00       	nop
      10:	62 c1       	rjmp	.+708    	; 0x2d6 <__bad_interrupt>
      12:	00 00       	nop
      14:	60 c1       	rjmp	.+704    	; 0x2d6 <__bad_interrupt>
      16:	00 00       	nop
      18:	5e c1       	rjmp	.+700    	; 0x2d6 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	5c c1       	rjmp	.+696    	; 0x2d6 <__bad_interrupt>
      1e:	00 00       	nop
      20:	5a c1       	rjmp	.+692    	; 0x2d6 <__bad_interrupt>
      22:	00 00       	nop
      24:	58 c1       	rjmp	.+688    	; 0x2d6 <__bad_interrupt>
      26:	00 00       	nop
      28:	56 c1       	rjmp	.+684    	; 0x2d6 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	54 c1       	rjmp	.+680    	; 0x2d6 <__bad_interrupt>
      2e:	00 00       	nop
      30:	0c 94 f9 0e 	jmp	0x1df2	; 0x1df2 <__vector_12>
      34:	50 c1       	rjmp	.+672    	; 0x2d6 <__bad_interrupt>
      36:	00 00       	nop
      38:	4e c1       	rjmp	.+668    	; 0x2d6 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	4c c1       	rjmp	.+664    	; 0x2d6 <__bad_interrupt>
      3e:	00 00       	nop
      40:	4a c1       	rjmp	.+660    	; 0x2d6 <__bad_interrupt>
      42:	00 00       	nop
      44:	48 c1       	rjmp	.+656    	; 0x2d6 <__bad_interrupt>
      46:	00 00       	nop
      48:	46 c1       	rjmp	.+652    	; 0x2d6 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	44 c1       	rjmp	.+648    	; 0x2d6 <__bad_interrupt>
      4e:	00 00       	nop
      50:	42 c1       	rjmp	.+644    	; 0x2d6 <__bad_interrupt>
      52:	00 00       	nop
      54:	40 c1       	rjmp	.+640    	; 0x2d6 <__bad_interrupt>
      56:	00 00       	nop
      58:	3e c1       	rjmp	.+636    	; 0x2d6 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	3c c1       	rjmp	.+632    	; 0x2d6 <__bad_interrupt>
      5e:	00 00       	nop
      60:	3a c1       	rjmp	.+628    	; 0x2d6 <__bad_interrupt>
      62:	00 00       	nop
      64:	38 c1       	rjmp	.+624    	; 0x2d6 <__bad_interrupt>
      66:	00 00       	nop
      68:	5a c1       	rjmp	.+692    	; 0x31e <__vector_26>
      6a:	00 00       	nop
      6c:	34 c1       	rjmp	.+616    	; 0x2d6 <__bad_interrupt>
      6e:	00 00       	nop
      70:	32 c1       	rjmp	.+612    	; 0x2d6 <__bad_interrupt>
      72:	00 00       	nop
      74:	30 c1       	rjmp	.+608    	; 0x2d6 <__bad_interrupt>
      76:	00 00       	nop
      78:	2e c1       	rjmp	.+604    	; 0x2d6 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	2c c1       	rjmp	.+600    	; 0x2d6 <__bad_interrupt>
      7e:	00 00       	nop
      80:	2a c1       	rjmp	.+596    	; 0x2d6 <__bad_interrupt>
      82:	00 00       	nop
      84:	28 c1       	rjmp	.+592    	; 0x2d6 <__bad_interrupt>
      86:	00 00       	nop
      88:	26 c1       	rjmp	.+588    	; 0x2d6 <__bad_interrupt>
	...

0000008c <__trampolines_end>:
      8c:	53 74       	andi	r21, 0x43	; 67
      8e:	61 63       	ori	r22, 0x31	; 49
      90:	6b 20       	and	r6, r11
      92:	6f 76       	andi	r22, 0x6F	; 111
      94:	65 72       	andi	r22, 0x25	; 37
      96:	66 6c       	ori	r22, 0xC6	; 198
      98:	6f 77       	andi	r22, 0x7F	; 127
      9a:	20 74       	andi	r18, 0x40	; 64
      9c:	61 73       	andi	r22, 0x31	; 49
      9e:	6b 3a       	cpi	r22, 0xAB	; 171
	...

000000a1 <strSch>:
      a1:	53 63 68 65 64 75 6c 65 72 20 73 74 61 72 74 65     Scheduler starte
      b1:	64 20 20 20 00                                      d   .

000000b6 <strTask>:
      b6:	54 61 73 6b 73 20 63 72 65 61 74 65 64 20 20 20     Tasks created   
      c6:	20 20 20 20 00                                          .

000000cb <strQue>:
      cb:	51 75 65 75 65 73 20 63 72 65 61 74 65 64 20 20     Queues created  
      db:	20 20 20 20 00                                          .

000000e0 <strLCD>:
      e0:	4c 43 44 20 6c 69 62 72 61 72 79 20 2d 20 4f 6b     LCD library - Ok
      f0:	20 20 20 20 00                                          .

000000f5 <err_status>:
      f5:	73 74 61 74 75 73 20 6f 75 74 20 6f 66 20 72 61     status out of ra
     105:	6e 67 65 20 00                                      nge .

0000010a <SBP_Menu>:
     10a:	53 68 6f 77 20 42 61 6c 6c 20 50 6f 73 69 74 69     Show Ball Positi
     11a:	6f 6e 20 20 2d 53 6c 6f 77 50 6f 73 69 74 69 6f     on  -SlowPositio
     12a:	6e 3d 2d 30 2e 31 32 33 2d 4c 30 30 30 30 30 30     n=-0.123-L000000
     13a:	30 20 20 46 54 31 31 31 31 31 31 31 3e 42 61 63     0  FT1111111>Bac
     14a:	6b 20 20 20 20 20 20 20 20 20 20 20 20 20 20 00     k              .

0000015a <PID_Menu>:
     15a:	50 49 44 20 69 73 20 72 75 6e 6e 69 6e 67 20 2e     PID is running .
     16a:	2e 2e 20 20 2d 20 20 20 50 49 44 2d 49 6e 70 75     ..  -   PID-Inpu
     17a:	74 3d 2d 30 2e 31 32 33 2d 20 20 50 49 44 2d 4f     t=-0.123-  PID-O
     18a:	75 74 70 75 74 3d 2d 30 2e 31 32 33 3e 42 61 63     utput=-0.123>Bac
     19a:	6b 20 61 6e 64 20 53 74 6f 70 20 50 49 44 20 00     k and Stop PID .

000001aa <DRT_Parameter_Menu>:
     1aa:	50 61 72 61 6d 65 74 65 72 20 56 61 6c 75 65 73     Parameter Values
     1ba:	20 44 52 20 3e 20 20 44 65 72 69 76 61 74 69 76      DR >  Derivativ
     1ca:	65 3d 2b 30 2e 31 32 33 3e 20 20 20 52 65 66 65     e=+0.123>   Refe
     1da:	72 65 6e 63 65 3d 2b 30 2e 31 32 33 3e 42 61 63     rence=+0.123>Bac
     1ea:	6b 20 20 20 20 20 20 20 20 20 20 20 20 20 20 00     k              .

000001fa <PI_Parameter_Menu>:
     1fa:	50 61 72 61 6d 65 74 65 72 20 56 61 6c 75 65 73     Parameter Values
     20a:	20 50 49 20 3e 50 72 6f 70 6f 72 74 69 6f 6e 61      PI >Proportiona
     21a:	6c 3d 2b 30 2e 31 32 33 3e 20 20 20 20 49 6e 74     l=+0.123>    Int
     22a:	65 67 72 61 6c 3d 2b 30 2e 31 32 33 3e 4e 65 78     egral=+0.123>Nex
     23a:	74 20 20 20 20 20 20 20 20 20 20 20 20 20 20 00     t              .

0000024a <Main_Menu>:
     24a:	47 72 6f 75 70 30 35 20 45 58 33 20 32 30 32 30     Group05 EX3 2020
     25a:	20 3e 43 68 61 6e 67 65 20 50 61 72 61 6d 65 74      >Change Paramet
     26a:	65 72 20 20 20 3e 53 68 6f 77 20 42 61 6c 6c 20     er   >Show Ball 
     27a:	50 6f 73 69 74 69 6f 6e 20 3e 53 74 61 72 74 20     Position >Start 
     28a:	50 49 44 20 43 6f 6e 74 72 6f 6c 20 00 00 00 00     PID Control ....

0000029a <__ctors_end>:
     29a:	11 24       	eor	r1, r1
     29c:	1f be       	out	0x3f, r1	; 63
     29e:	cf ef       	ldi	r28, 0xFF	; 255
     2a0:	d0 e1       	ldi	r29, 0x10	; 16
     2a2:	de bf       	out	0x3e, r29	; 62
     2a4:	cd bf       	out	0x3d, r28	; 61

000002a6 <__do_copy_data>:
     2a6:	11 e0       	ldi	r17, 0x01	; 1
     2a8:	a0 e0       	ldi	r26, 0x00	; 0
     2aa:	b1 e0       	ldi	r27, 0x01	; 1
     2ac:	e4 e0       	ldi	r30, 0x04	; 4
     2ae:	f4 e3       	ldi	r31, 0x34	; 52
     2b0:	00 e0       	ldi	r16, 0x00	; 0
     2b2:	0b bf       	out	0x3b, r16	; 59
     2b4:	02 c0       	rjmp	.+4      	; 0x2ba <__do_copy_data+0x14>
     2b6:	07 90       	elpm	r0, Z+
     2b8:	0d 92       	st	X+, r0
     2ba:	ae 3f       	cpi	r26, 0xFE	; 254
     2bc:	b1 07       	cpc	r27, r17
     2be:	d9 f7       	brne	.-10     	; 0x2b6 <__do_copy_data+0x10>

000002c0 <__do_clear_bss>:
     2c0:	2a e0       	ldi	r18, 0x0A	; 10
     2c2:	ae ef       	ldi	r26, 0xFE	; 254
     2c4:	b1 e0       	ldi	r27, 0x01	; 1
     2c6:	01 c0       	rjmp	.+2      	; 0x2ca <.do_clear_bss_start>

000002c8 <.do_clear_bss_loop>:
     2c8:	1d 92       	st	X+, r1

000002ca <.do_clear_bss_start>:
     2ca:	a4 3b       	cpi	r26, 0xB4	; 180
     2cc:	b2 07       	cpc	r27, r18
     2ce:	e1 f7       	brne	.-8      	; 0x2c8 <.do_clear_bss_loop>
     2d0:	31 d0       	rcall	.+98     	; 0x334 <main>
     2d2:	0c 94 00 1a 	jmp	0x3400	; 0x3400 <_exit>

000002d6 <__bad_interrupt>:
     2d6:	94 ce       	rjmp	.-728    	; 0x0 <__vectors>

000002d8 <vApplicationStackOverflowHook>:
const char strTask [21] PROGMEM =  "Tasks created       "; 
const char strSch [21] PROGMEM =   "Scheduler started   "; 
const char strStack [21] PROGMEM = "Stack overflow task:"; 
//----------------------------------------------------------
 void vApplicationStackOverflowHook (xTaskHandle *pxTask, const portCHAR *pcTaskName)
{	lcd_clrscr();  	lcd_puts_p(strStack);
     2d8:	eb 01       	movw	r28, r22
     2da:	0e 94 c8 0b 	call	0x1790	; 0x1790 <lcd_clrscr>
     2de:	8c e8       	ldi	r24, 0x8C	; 140
     2e0:	90 e0       	ldi	r25, 0x00	; 0
     2e2:	0e 94 fa 0b 	call	0x17f4	; 0x17f4 <lcd_puts_p>
	lcd_puts(pcTaskName);  	
     2e6:	ce 01       	movw	r24, r28
     2e8:	0e 94 eb 0b 	call	0x17d6	; 0x17d6 <lcd_puts>
	cli();  PORTC = PORTC & 0b10000000;  while (1);
     2ec:	f8 94       	cli
     2ee:	85 b3       	in	r24, 0x15	; 21
     2f0:	80 78       	andi	r24, 0x80	; 128
     2f2:	85 bb       	out	0x15, r24	; 21
     2f4:	ff cf       	rjmp	.-2      	; 0x2f4 <vApplicationStackOverflowHook+0x1c>

000002f6 <vApplicationTickHook>:
//----------------------------------------------------------
// Global vars for following function
unsigned char  Servo_counter = 0;
// Function is called by FreeRTOS ticker every 3ms
void  vApplicationTickHook (void)
{ TCNT3 = 0; // Delete timer counter reg 3
     2f6:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
     2fa:	10 92 88 00 	sts	0x0088, r1	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
  Servo_counter ++; // Every 7 times generate a servo signal
     2fe:	80 91 fe 01 	lds	r24, 0x01FE	; 0x8001fe <__data_end>
     302:	8f 5f       	subi	r24, 0xFF	; 255
  if (Servo_counter > 6) // Historical reason from flight model remote control
     304:	87 30       	cpi	r24, 0x07	; 7
     306:	18 f4       	brcc	.+6      	; 0x30e <vApplicationTickHook+0x18>
// Global vars for following function
unsigned char  Servo_counter = 0;
// Function is called by FreeRTOS ticker every 3ms
void  vApplicationTickHook (void)
{ TCNT3 = 0; // Delete timer counter reg 3
  Servo_counter ++; // Every 7 times generate a servo signal
     308:	80 93 fe 01 	sts	0x01FE, r24	; 0x8001fe <__data_end>
     30c:	08 95       	ret
  if (Servo_counter > 6) // Historical reason from flight model remote control
  { Servo_counter = 0;
     30e:	10 92 fe 01 	sts	0x01FE, r1	; 0x8001fe <__data_end>
    if (servo_power == 1) PORTC = PORTC | 0b10000000; // Generate servo signal
     312:	80 91 ab 0a 	lds	r24, 0x0AAB	; 0x800aab <servo_power>
     316:	81 30       	cpi	r24, 0x01	; 1
     318:	09 f4       	brne	.+2      	; 0x31c <vApplicationTickHook+0x26>
     31a:	af 9a       	sbi	0x15, 7	; 21
     31c:	08 95       	ret

0000031e <__vector_26>:
  }
}
//----------------------------------------------------------
ISR (TIMER3_COMPA_vect)
{ PORTC = PORTC & 0b01111111; // Finish servo signal
     31e:	1f 92       	push	r1
     320:	0f 92       	push	r0
     322:	0f b6       	in	r0, 0x3f	; 63
     324:	0f 92       	push	r0
     326:	11 24       	eor	r1, r1
     328:	af 98       	cbi	0x15, 7	; 21
}
     32a:	0f 90       	pop	r0
     32c:	0f be       	out	0x3f, r0	; 63
     32e:	0f 90       	pop	r0
     330:	1f 90       	pop	r1
     332:	18 95       	reti

00000334 <main>:
//----------------------------------------------------------
int  main()
{ char  RTOS_Allright = 1, ret_val = 0;
     334:	ef 92       	push	r14
     336:	ff 92       	push	r15
     338:	0f 93       	push	r16
     33a:	cf 93       	push	r28
// Init port direction
  DDRD = DDRD & 0x0f;  // PD4..7 inputs
     33c:	81 b3       	in	r24, 0x11	; 17
     33e:	8f 70       	andi	r24, 0x0F	; 15
     340:	81 bb       	out	0x11, r24	; 17
  PORTD = PORTD | 0xf0;  // Pullups at PD4..7
     342:	82 b3       	in	r24, 0x12	; 18
     344:	80 6f       	ori	r24, 0xF0	; 240
     346:	82 bb       	out	0x12, r24	; 18
  DDRA = 0; // all PAs inputs
     348:	1a ba       	out	0x1a, r1	; 26
  PORTA = 0xff; // all PAs with pullups
     34a:	8f ef       	ldi	r24, 0xFF	; 255
     34c:	8b bb       	out	0x1b, r24	; 27
  DDRC = 255; // all pins outputs
     34e:	84 bb       	out	0x14, r24	; 20
  DDRG = 3; // internal LEDs
     350:	83 e0       	ldi	r24, 0x03	; 3
     352:	80 93 64 00 	sts	0x0064, r24	; 0x800064 <__TEXT_REGION_LENGTH__+0x7e0064>
  PORTG = 0b00111; // Pullup PG2 and LEDs off
     356:	97 e0       	ldi	r25, 0x07	; 7
     358:	90 93 65 00 	sts	0x0065, r25	; 0x800065 <__TEXT_REGION_LENGTH__+0x7e0065>
// Init timer 3
  TCCR3A = 0;
     35c:	10 92 8b 00 	sts	0x008B, r1	; 0x80008b <__TEXT_REGION_LENGTH__+0x7e008b>
  TCCR3B = 0b00000011; // 
     360:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <__TEXT_REGION_LENGTH__+0x7e008a>
  TCCR3C = 0;
     364:	10 92 8c 00 	sts	0x008C, r1	; 0x80008c <__TEXT_REGION_LENGTH__+0x7e008c>
  TCNT3 = 0;
     368:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
     36c:	10 92 88 00 	sts	0x0088, r1	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
  OCR3A = 3000;
     370:	88 eb       	ldi	r24, 0xB8	; 184
     372:	9b e0       	ldi	r25, 0x0B	; 11
     374:	90 93 87 00 	sts	0x0087, r25	; 0x800087 <__TEXT_REGION_LENGTH__+0x7e0087>
     378:	80 93 86 00 	sts	0x0086, r24	; 0x800086 <__TEXT_REGION_LENGTH__+0x7e0086>
  ETIMSK = ETIMSK | 0b00010000; // OCIE3A
     37c:	ed e7       	ldi	r30, 0x7D	; 125
     37e:	f0 e0       	ldi	r31, 0x00	; 0
     380:	80 81       	ld	r24, Z
     382:	80 61       	ori	r24, 0x10	; 16
     384:	80 83       	st	Z, r24
  ASSR = 0;
     386:	10 be       	out	0x30, r1	; 48
// Init LCD
  lcd_init (LCD_DISP_ON_CURSOR_BLINK);
     388:	8f e0       	ldi	r24, 0x0F	; 15
     38a:	0e 94 0b 0c 	call	0x1816	; 0x1816 <lcd_init>
  lcd_clrscr ();
     38e:	0e 94 c8 0b 	call	0x1790	; 0x1790 <lcd_clrscr>
  lcd_puts_p (strLCD);
     392:	80 ee       	ldi	r24, 0xE0	; 224
     394:	90 e0       	ldi	r25, 0x00	; 0
     396:	0e 94 fa 0b 	call	0x17f4	; 0x17f4 <lcd_puts_p>
// Create queues
  QueueTaster = xQueueCreate (10, sizeof(char));
     39a:	61 e0       	ldi	r22, 0x01	; 1
     39c:	8a e0       	ldi	r24, 0x0A	; 10
     39e:	0e 94 9e 0f 	call	0x1f3c	; 0x1f3c <xQueueCreate>
     3a2:	90 93 a0 0a 	sts	0x0AA0, r25	; 0x800aa0 <QueueTaster+0x1>
     3a6:	80 93 9f 0a 	sts	0x0A9F, r24	; 0x800a9f <QueueTaster>
ISR (TIMER3_COMPA_vect)
{ PORTC = PORTC & 0b01111111; // Finish servo signal
}
//----------------------------------------------------------
int  main()
{ char  RTOS_Allright = 1, ret_val = 0;
     3aa:	c1 e0       	ldi	r28, 0x01	; 1
     3ac:	89 2b       	or	r24, r25
     3ae:	09 f4       	brne	.+2      	; 0x3b2 <main+0x7e>
     3b0:	c0 e0       	ldi	r28, 0x00	; 0
  lcd_clrscr ();
  lcd_puts_p (strLCD);
// Create queues
  QueueTaster = xQueueCreate (10, sizeof(char));
  if (QueueTaster == 0)  RTOS_Allright = 0;
  QueueSensor = xQueueCreate (1, sizeof(float));
     3b2:	64 e0       	ldi	r22, 0x04	; 4
     3b4:	81 e0       	ldi	r24, 0x01	; 1
     3b6:	0e 94 9e 0f 	call	0x1f3c	; 0x1f3c <xQueueCreate>
     3ba:	90 93 97 0a 	sts	0x0A97, r25	; 0x800a97 <QueueSensor+0x1>
     3be:	80 93 96 0a 	sts	0x0A96, r24	; 0x800a96 <QueueSensor>
  if (QueueSensor == 0)  RTOS_Allright = 0;
     3c2:	89 2b       	or	r24, r25
     3c4:	09 f4       	brne	.+2      	; 0x3c8 <main+0x94>
     3c6:	c0 e0       	ldi	r28, 0x00	; 0
  QueueServo = xQueueCreate (1, sizeof(float));
     3c8:	64 e0       	ldi	r22, 0x04	; 4
     3ca:	81 e0       	ldi	r24, 0x01	; 1
     3cc:	0e 94 9e 0f 	call	0x1f3c	; 0x1f3c <xQueueCreate>
     3d0:	90 93 95 0a 	sts	0x0A95, r25	; 0x800a95 <QueueServo+0x1>
     3d4:	80 93 94 0a 	sts	0x0A94, r24	; 0x800a94 <QueueServo>
  if (QueueServo == 0)  RTOS_Allright = 0;
     3d8:	89 2b       	or	r24, r25
     3da:	09 f4       	brne	.+2      	; 0x3de <main+0xaa>
     3dc:	c0 e0       	ldi	r28, 0x00	; 0
  lcd_puts_p (strQue);
     3de:	8b ec       	ldi	r24, 0xCB	; 203
     3e0:	90 e0       	ldi	r25, 0x00	; 0
     3e2:	0e 94 fa 0b 	call	0x17f4	; 0x17f4 <lcd_puts_p>
// Start tasks
  ret_val = xTaskCreate (vSensor, (const signed portCHAR *)\
     3e6:	0f 2e       	mov	r0, r31
     3e8:	f2 e9       	ldi	r31, 0x92	; 146
     3ea:	ef 2e       	mov	r14, r31
     3ec:	fa e0       	ldi	r31, 0x0A	; 10
     3ee:	ff 2e       	mov	r15, r31
     3f0:	f0 2d       	mov	r31, r0
     3f2:	02 e0       	ldi	r16, 0x02	; 2
     3f4:	20 e0       	ldi	r18, 0x00	; 0
     3f6:	30 e0       	ldi	r19, 0x00	; 0
     3f8:	4d ec       	ldi	r20, 0xCD	; 205
     3fa:	50 e0       	ldi	r21, 0x00	; 0
     3fc:	64 ec       	ldi	r22, 0xC4	; 196
     3fe:	71 e0       	ldi	r23, 0x01	; 1
     400:	8f e5       	ldi	r24, 0x5F	; 95
     402:	91 e1       	ldi	r25, 0x11	; 17
     404:	0e 94 35 13 	call	0x266a	; 0x266a <xTaskCreate>
   "Sensor", configMINIMAL_STACK_SIZE  + (30 * sizeof (float)),\
    NULL, tskIDLE_PRIORITY+2, &vSensor_Handle);
  if (ret_val != pdPASS)  RTOS_Allright = 0;
     408:	81 30       	cpi	r24, 0x01	; 1
     40a:	09 f0       	breq	.+2      	; 0x40e <__LOCK_REGION_LENGTH__+0xe>
     40c:	c0 e0       	ldi	r28, 0x00	; 0

  ret_val = xTaskCreate (vIO_SRAM_to_LCD, (const signed portCHAR *) \
     40e:	0f 2e       	mov	r0, r31
     410:	fc e8       	ldi	r31, 0x8C	; 140
     412:	ef 2e       	mov	r14, r31
     414:	fa e0       	ldi	r31, 0x0A	; 10
     416:	ff 2e       	mov	r15, r31
     418:	f0 2d       	mov	r31, r0
     41a:	01 e0       	ldi	r16, 0x01	; 1
     41c:	20 e0       	ldi	r18, 0x00	; 0
     41e:	30 e0       	ldi	r19, 0x00	; 0
     420:	49 e6       	ldi	r20, 0x69	; 105
     422:	50 e0       	ldi	r21, 0x00	; 0
     424:	6b ec       	ldi	r22, 0xCB	; 203
     426:	71 e0       	ldi	r23, 0x01	; 1
     428:	81 ec       	ldi	r24, 0xC1	; 193
     42a:	92 e0       	ldi	r25, 0x02	; 2
     42c:	0e 94 35 13 	call	0x266a	; 0x266a <xTaskCreate>
   "LCD", configMINIMAL_STACK_SIZE  + (20 * sizeof (char)),\
    NULL, tskIDLE_PRIORITY+1, &vIO_SRAM_to_LCD_Handle);
  if (ret_val != pdPASS)  RTOS_Allright = 0;
     430:	81 30       	cpi	r24, 0x01	; 1
     432:	09 f0       	breq	.+2      	; 0x436 <__LOCK_REGION_LENGTH__+0x36>
     434:	c0 e0       	ldi	r28, 0x00	; 0

  ret_val = xTaskCreate (vTaster, (const signed portCHAR *) \
     436:	0f 2e       	mov	r0, r31
     438:	fb e9       	ldi	r31, 0x9B	; 155
     43a:	ef 2e       	mov	r14, r31
     43c:	fa e0       	ldi	r31, 0x0A	; 10
     43e:	ff 2e       	mov	r15, r31
     440:	f0 2d       	mov	r31, r0
     442:	01 e0       	ldi	r16, 0x01	; 1
     444:	20 e0       	ldi	r18, 0x00	; 0
     446:	30 e0       	ldi	r19, 0x00	; 0
     448:	49 e6       	ldi	r20, 0x69	; 105
     44a:	50 e0       	ldi	r21, 0x00	; 0
     44c:	6f ec       	ldi	r22, 0xCF	; 207
     44e:	71 e0       	ldi	r23, 0x01	; 1
     450:	85 e0       	ldi	r24, 0x05	; 5
     452:	93 e0       	ldi	r25, 0x03	; 3
     454:	0e 94 35 13 	call	0x266a	; 0x266a <xTaskCreate>
   "Taster", configMINIMAL_STACK_SIZE  + (20 * sizeof (char)),\
    NULL, tskIDLE_PRIORITY+1, &vTaster_Handle);
  if (ret_val != pdPASS)  RTOS_Allright = 0;
     458:	81 30       	cpi	r24, 0x01	; 1
     45a:	09 f0       	breq	.+2      	; 0x45e <__LOCK_REGION_LENGTH__+0x5e>
     45c:	c0 e0       	ldi	r28, 0x00	; 0

  ret_val = xTaskCreate (vHMI, (const signed portCHAR *) \
     45e:	0f 2e       	mov	r0, r31
     460:	fd e9       	ldi	r31, 0x9D	; 157
     462:	ef 2e       	mov	r14, r31
     464:	fa e0       	ldi	r31, 0x0A	; 10
     466:	ff 2e       	mov	r15, r31
     468:	f0 2d       	mov	r31, r0
     46a:	01 e0       	ldi	r16, 0x01	; 1
     46c:	20 e0       	ldi	r18, 0x00	; 0
     46e:	30 e0       	ldi	r19, 0x00	; 0
     470:	49 eb       	ldi	r20, 0xB9	; 185
     472:	50 e0       	ldi	r21, 0x00	; 0
     474:	66 ed       	ldi	r22, 0xD6	; 214
     476:	71 e0       	ldi	r23, 0x01	; 1
     478:	84 e7       	ldi	r24, 0x74	; 116
     47a:	99 e0       	ldi	r25, 0x09	; 9
     47c:	0e 94 35 13 	call	0x266a	; 0x266a <xTaskCreate>
   "HMI", configMINIMAL_STACK_SIZE  + (100 * sizeof (char)),\
    NULL, tskIDLE_PRIORITY+1, &vHMI_Handle);
  if (ret_val != pdPASS)  RTOS_Allright = 0;
     480:	81 30       	cpi	r24, 0x01	; 1
     482:	09 f0       	breq	.+2      	; 0x486 <__LOCK_REGION_LENGTH__+0x86>
     484:	c0 e0       	ldi	r28, 0x00	; 0

  ret_val = xTaskCreate (vServo, (const signed portCHAR *) \
     486:	0f 2e       	mov	r0, r31
     488:	f8 e9       	ldi	r31, 0x98	; 152
     48a:	ef 2e       	mov	r14, r31
     48c:	fa e0       	ldi	r31, 0x0A	; 10
     48e:	ff 2e       	mov	r15, r31
     490:	f0 2d       	mov	r31, r0
     492:	02 e0       	ldi	r16, 0x02	; 2
     494:	20 e0       	ldi	r18, 0x00	; 0
     496:	30 e0       	ldi	r19, 0x00	; 0
     498:	49 e6       	ldi	r20, 0x69	; 105
     49a:	50 e0       	ldi	r21, 0x00	; 0
     49c:	6a ed       	ldi	r22, 0xDA	; 218
     49e:	71 e0       	ldi	r23, 0x01	; 1
     4a0:	8f ec       	ldi	r24, 0xCF	; 207
     4a2:	92 e1       	ldi	r25, 0x12	; 18
     4a4:	0e 94 35 13 	call	0x266a	; 0x266a <xTaskCreate>
   "Servo", configMINIMAL_STACK_SIZE  + (5 * sizeof (float)),\
    NULL, tskIDLE_PRIORITY+2, &vServo_Handle);
  if (ret_val != pdPASS)  RTOS_Allright = 0;
     4a8:	81 30       	cpi	r24, 0x01	; 1
     4aa:	49 f5       	brne	.+82     	; 0x4fe <__LOCK_REGION_LENGTH__+0xfe>

  ret_val = xTaskCreate (vPID, (const signed portCHAR *) \
     4ac:	0f 2e       	mov	r0, r31
     4ae:	f9 ea       	ldi	r31, 0xA9	; 169
     4b0:	ef 2e       	mov	r14, r31
     4b2:	fa e0       	ldi	r31, 0x0A	; 10
     4b4:	ff 2e       	mov	r15, r31
     4b6:	f0 2d       	mov	r31, r0
     4b8:	20 e0       	ldi	r18, 0x00	; 0
     4ba:	30 e0       	ldi	r19, 0x00	; 0
     4bc:	45 ea       	ldi	r20, 0xA5	; 165
     4be:	50 e0       	ldi	r21, 0x00	; 0
     4c0:	60 ee       	ldi	r22, 0xE0	; 224
     4c2:	71 e0       	ldi	r23, 0x01	; 1
     4c4:	8a ed       	ldi	r24, 0xDA	; 218
     4c6:	9c e0       	ldi	r25, 0x0C	; 12
     4c8:	0e 94 35 13 	call	0x266a	; 0x266a <xTaskCreate>
   "PID", configMINIMAL_STACK_SIZE  + (20 * sizeof (float)),\
    NULL, tskIDLE_PRIORITY+2, &vPID_Handle);
  if (ret_val != pdPASS)  RTOS_Allright = 0;
     4cc:	81 30       	cpi	r24, 0x01	; 1
     4ce:	69 f4       	brne	.+26     	; 0x4ea <__LOCK_REGION_LENGTH__+0xea>

  lcd_puts_p (strTask);
     4d0:	86 eb       	ldi	r24, 0xB6	; 182
     4d2:	90 e0       	ldi	r25, 0x00	; 0
     4d4:	0e 94 fa 0b 	call	0x17f4	; 0x17f4 <lcd_puts_p>
// Start Scheduler
  if (RTOS_Allright == 1) 
     4d8:	c1 30       	cpi	r28, 0x01	; 1
     4da:	29 f5       	brne	.+74     	; 0x526 <__LOCK_REGION_LENGTH__+0x126>
  {   lcd_puts_p (strSch);
     4dc:	81 ea       	ldi	r24, 0xA1	; 161
     4de:	90 e0       	ldi	r25, 0x00	; 0
     4e0:	0e 94 fa 0b 	call	0x17f4	; 0x17f4 <lcd_puts_p>
      vTaskStartScheduler ();
     4e4:	0e 94 9e 14 	call	0x293c	; 0x293c <vTaskStartScheduler>
     4e8:	1e c0       	rjmp	.+60     	; 0x526 <__LOCK_REGION_LENGTH__+0x126>
  ret_val = xTaskCreate (vPID, (const signed portCHAR *) \
   "PID", configMINIMAL_STACK_SIZE  + (20 * sizeof (float)),\
    NULL, tskIDLE_PRIORITY+2, &vPID_Handle);
  if (ret_val != pdPASS)  RTOS_Allright = 0;

  lcd_puts_p (strTask);
     4ea:	86 eb       	ldi	r24, 0xB6	; 182
     4ec:	90 e0       	ldi	r25, 0x00	; 0
     4ee:	0e 94 fa 0b 	call	0x17f4	; 0x17f4 <lcd_puts_p>
     4f2:	19 c0       	rjmp	.+50     	; 0x526 <__LOCK_REGION_LENGTH__+0x126>
     4f4:	86 eb       	ldi	r24, 0xB6	; 182
     4f6:	90 e0       	ldi	r25, 0x00	; 0
     4f8:	0e 94 fa 0b 	call	0x17f4	; 0x17f4 <lcd_puts_p>
     4fc:	14 c0       	rjmp	.+40     	; 0x526 <__LOCK_REGION_LENGTH__+0x126>
  ret_val = xTaskCreate (vServo, (const signed portCHAR *) \
   "Servo", configMINIMAL_STACK_SIZE  + (5 * sizeof (float)),\
    NULL, tskIDLE_PRIORITY+2, &vServo_Handle);
  if (ret_val != pdPASS)  RTOS_Allright = 0;

  ret_val = xTaskCreate (vPID, (const signed portCHAR *) \
     4fe:	0f 2e       	mov	r0, r31
     500:	f9 ea       	ldi	r31, 0xA9	; 169
     502:	ef 2e       	mov	r14, r31
     504:	fa e0       	ldi	r31, 0x0A	; 10
     506:	ff 2e       	mov	r15, r31
     508:	f0 2d       	mov	r31, r0
     50a:	02 e0       	ldi	r16, 0x02	; 2
     50c:	20 e0       	ldi	r18, 0x00	; 0
     50e:	30 e0       	ldi	r19, 0x00	; 0
     510:	45 ea       	ldi	r20, 0xA5	; 165
     512:	50 e0       	ldi	r21, 0x00	; 0
     514:	60 ee       	ldi	r22, 0xE0	; 224
     516:	71 e0       	ldi	r23, 0x01	; 1
     518:	8a ed       	ldi	r24, 0xDA	; 218
     51a:	9c e0       	ldi	r25, 0x0C	; 12
     51c:	0e 94 35 13 	call	0x266a	; 0x266a <xTaskCreate>
   "PID", configMINIMAL_STACK_SIZE  + (20 * sizeof (float)),\
    NULL, tskIDLE_PRIORITY+2, &vPID_Handle);
  if (ret_val != pdPASS)  RTOS_Allright = 0;
     520:	81 30       	cpi	r24, 0x01	; 1
     522:	19 f7       	brne	.-58     	; 0x4ea <__LOCK_REGION_LENGTH__+0xea>
     524:	e7 cf       	rjmp	.-50     	; 0x4f4 <__LOCK_REGION_LENGTH__+0xf4>
// Start Scheduler
  if (RTOS_Allright == 1) 
  {   lcd_puts_p (strSch);
      vTaskStartScheduler ();
  } // end if
} // end main
     526:	80 e0       	ldi	r24, 0x00	; 0
     528:	90 e0       	ldi	r25, 0x00	; 0
     52a:	cf 91       	pop	r28
     52c:	0f 91       	pop	r16
     52e:	ff 90       	pop	r15
     530:	ef 90       	pop	r14
     532:	08 95       	ret

00000534 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     534:	cf 93       	push	r28
     536:	df 93       	push	r29
     538:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & heapBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     53a:	0e 94 bb 14 	call	0x2976	; 0x2976 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     53e:	20 91 ff 01 	lds	r18, 0x01FF	; 0x8001ff <xNextFreeByte>
     542:	30 91 00 02 	lds	r19, 0x0200	; 0x800200 <xNextFreeByte+0x1>
     546:	c9 01       	movw	r24, r18
     548:	8c 0f       	add	r24, r28
     54a:	9d 1f       	adc	r25, r29
     54c:	80 3d       	cpi	r24, 0xD0	; 208
     54e:	47 e0       	ldi	r20, 0x07	; 7
     550:	94 07       	cpc	r25, r20
     552:	58 f4       	brcc	.+22     	; 0x56a <pvPortMalloc+0x36>
     554:	28 17       	cp	r18, r24
     556:	39 07       	cpc	r19, r25
     558:	58 f4       	brcc	.+22     	; 0x570 <pvPortMalloc+0x3c>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     55a:	e9 01       	movw	r28, r18
     55c:	cb 5f       	subi	r28, 0xFB	; 251
     55e:	dd 4f       	sbci	r29, 0xFD	; 253
			xNextFreeByte += xWantedSize;			
     560:	90 93 00 02 	sts	0x0200, r25	; 0x800200 <xNextFreeByte+0x1>
     564:	80 93 ff 01 	sts	0x01FF, r24	; 0x8001ff <xNextFreeByte>
     568:	05 c0       	rjmp	.+10     	; 0x574 <pvPortMalloc+0x40>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
     56a:	c0 e0       	ldi	r28, 0x00	; 0
     56c:	d0 e0       	ldi	r29, 0x00	; 0
     56e:	02 c0       	rjmp	.+4      	; 0x574 <pvPortMalloc+0x40>
     570:	c0 e0       	ldi	r28, 0x00	; 0
     572:	d0 e0       	ldi	r29, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
     574:	0e 94 46 15 	call	0x2a8c	; 0x2a8c <xTaskResumeAll>

	return pvReturn;
}
     578:	ce 01       	movw	r24, r28
     57a:	df 91       	pop	r29
     57c:	cf 91       	pop	r28
     57e:	08 95       	ret

00000580 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     580:	08 95       	ret

00000582 <vIO_SRAM_to_LCD>:
 { -0.0, -0.0, -0.0, -0.0, -0.8, -0.9, -1.0}};
/*-----------------------------------------------------------*/
// Copy RAM to LCD, position cursor and change gadget sign
//-------------------------------------------------------------
void  vIO_SRAM_to_LCD ( void * pvParameters)
{ unsigned char  zeichen, z = 0;
     582:	f1 2c       	mov	r15, r1
     584:	08 e8       	ldi	r16, 0x88	; 136
     586:	1a e0       	ldi	r17, 0x0A	; 10
	  lcd_putc (SRAM_LCD_Text[zeichen]);
	lcd_gotoxy (Cursor_X, Cursor_Y);
    z++;
    switch (z%4)
	{ case 0: SRAM_LCD_Text[79] = 254; break;
	  case 1: SRAM_LCD_Text[79] = 47; break;
     588:	0f 2e       	mov	r0, r31
     58a:	f7 e8       	ldi	r31, 0x87	; 135
     58c:	cf 2e       	mov	r12, r31
     58e:	fa e0       	ldi	r31, 0x0A	; 10
     590:	df 2e       	mov	r13, r31
     592:	f0 2d       	mov	r31, r0
     594:	0f 2e       	mov	r0, r31
     596:	ff e2       	ldi	r31, 0x2F	; 47
     598:	9f 2e       	mov	r9, r31
     59a:	f0 2d       	mov	r31, r0
	for (zeichen = 0; zeichen < 80; zeichen++)
	  lcd_putc (SRAM_LCD_Text[zeichen]);
	lcd_gotoxy (Cursor_X, Cursor_Y);
    z++;
    switch (z%4)
	{ case 0: SRAM_LCD_Text[79] = 254; break;
     59c:	0f 2e       	mov	r0, r31
     59e:	fe ef       	ldi	r31, 0xFE	; 254
     5a0:	af 2e       	mov	r10, r31
     5a2:	f0 2d       	mov	r31, r0
	  case 1: SRAM_LCD_Text[79] = 47; break;
	  case 2: SRAM_LCD_Text[79] = 45; break;
     5a4:	0f 2e       	mov	r0, r31
     5a6:	fd e2       	ldi	r31, 0x2D	; 45
     5a8:	bf 2e       	mov	r11, r31
     5aa:	f0 2d       	mov	r31, r0
	  case 3: SRAM_LCD_Text[79] = 251; break;
     5ac:	0f 2e       	mov	r0, r31
     5ae:	fb ef       	ldi	r31, 0xFB	; 251
     5b0:	ef 2e       	mov	r14, r31
     5b2:	f0 2d       	mov	r31, r0
// Copy RAM to LCD, position cursor and change gadget sign
//-------------------------------------------------------------
void  vIO_SRAM_to_LCD ( void * pvParameters)
{ unsigned char  zeichen, z = 0;
  for (;;)
  {	vTaskDelay (33); // 33x 3ms = 99ms
     5b4:	81 e2       	ldi	r24, 0x21	; 33
     5b6:	90 e0       	ldi	r25, 0x00	; 0
     5b8:	0e 94 cb 15 	call	0x2b96	; 0x2b96 <vTaskDelay>
    lcd_home ();
     5bc:	0e 94 cb 0b 	call	0x1796	; 0x1796 <lcd_home>
     5c0:	c8 e3       	ldi	r28, 0x38	; 56
     5c2:	da e0       	ldi	r29, 0x0A	; 10
	for (zeichen = 0; zeichen < 80; zeichen++)
	  lcd_putc (SRAM_LCD_Text[zeichen]);
     5c4:	89 91       	ld	r24, Y+
     5c6:	0e 94 ce 0b 	call	0x179c	; 0x179c <lcd_putc>
void  vIO_SRAM_to_LCD ( void * pvParameters)
{ unsigned char  zeichen, z = 0;
  for (;;)
  {	vTaskDelay (33); // 33x 3ms = 99ms
    lcd_home ();
	for (zeichen = 0; zeichen < 80; zeichen++)
     5ca:	c0 17       	cp	r28, r16
     5cc:	d1 07       	cpc	r29, r17
     5ce:	d1 f7       	brne	.-12     	; 0x5c4 <vIO_SRAM_to_LCD+0x42>
	  lcd_putc (SRAM_LCD_Text[zeichen]);
	lcd_gotoxy (Cursor_X, Cursor_Y);
     5d0:	60 91 33 0a 	lds	r22, 0x0A33	; 0x800a33 <Cursor_Y>
     5d4:	80 91 9a 0a 	lds	r24, 0x0A9A	; 0x800a9a <Cursor_X>
     5d8:	0e 94 b6 0b 	call	0x176c	; 0x176c <lcd_gotoxy>
    z++;
     5dc:	f3 94       	inc	r15
    switch (z%4)
     5de:	8f 2d       	mov	r24, r15
     5e0:	83 70       	andi	r24, 0x03	; 3
     5e2:	81 30       	cpi	r24, 0x01	; 1
     5e4:	49 f0       	breq	.+18     	; 0x5f8 <vIO_SRAM_to_LCD+0x76>
     5e6:	28 f0       	brcs	.+10     	; 0x5f2 <vIO_SRAM_to_LCD+0x70>
     5e8:	82 30       	cpi	r24, 0x02	; 2
     5ea:	49 f0       	breq	.+18     	; 0x5fe <vIO_SRAM_to_LCD+0x7c>
     5ec:	83 30       	cpi	r24, 0x03	; 3
     5ee:	51 f0       	breq	.+20     	; 0x604 <vIO_SRAM_to_LCD+0x82>
     5f0:	e1 cf       	rjmp	.-62     	; 0x5b4 <vIO_SRAM_to_LCD+0x32>
	{ case 0: SRAM_LCD_Text[79] = 254; break;
     5f2:	f6 01       	movw	r30, r12
     5f4:	a0 82       	st	Z, r10
     5f6:	de cf       	rjmp	.-68     	; 0x5b4 <vIO_SRAM_to_LCD+0x32>
	  case 1: SRAM_LCD_Text[79] = 47; break;
     5f8:	f6 01       	movw	r30, r12
     5fa:	90 82       	st	Z, r9
     5fc:	db cf       	rjmp	.-74     	; 0x5b4 <vIO_SRAM_to_LCD+0x32>
	  case 2: SRAM_LCD_Text[79] = 45; break;
     5fe:	f6 01       	movw	r30, r12
     600:	b0 82       	st	Z, r11
     602:	d8 cf       	rjmp	.-80     	; 0x5b4 <vIO_SRAM_to_LCD+0x32>
	  case 3: SRAM_LCD_Text[79] = 251; break;
     604:	f6 01       	movw	r30, r12
     606:	e0 82       	st	Z, r14
     608:	d5 cf       	rjmp	.-86     	; 0x5b4 <vIO_SRAM_to_LCD+0x32>

0000060a <vTaster>:
/*-----------------------------------------------------------*/
// enum for push button events
enum {NADA, UP, DOWN, LEFT, RIGHT, ENTER};
//-------------------------------------------------------------
void  vTaster ( void * pvParameters)
{ unsigned char  up=3, down=3, left=3, right=3, enter=3, para;
     60a:	cf 93       	push	r28
     60c:	df 93       	push	r29
     60e:	00 d0       	rcall	.+0      	; 0x610 <vTaster+0x6>
     610:	00 d0       	rcall	.+0      	; 0x612 <vTaster+0x8>
     612:	1f 92       	push	r1
     614:	cd b7       	in	r28, 0x3d	; 61
     616:	de b7       	in	r29, 0x3e	; 62
     618:	0f 2e       	mov	r0, r31
     61a:	f3 e0       	ldi	r31, 0x03	; 3
     61c:	3f 2e       	mov	r3, r31
     61e:	f0 2d       	mov	r31, r0
     620:	0f 2e       	mov	r0, r31
     622:	f3 e0       	ldi	r31, 0x03	; 3
     624:	4f 2e       	mov	r4, r31
     626:	f0 2d       	mov	r31, r0
     628:	0f 2e       	mov	r0, r31
     62a:	f3 e0       	ldi	r31, 0x03	; 3
     62c:	5f 2e       	mov	r5, r31
     62e:	f0 2d       	mov	r31, r0
     630:	0f 2e       	mov	r0, r31
     632:	f3 e0       	ldi	r31, 0x03	; 3
     634:	7f 2e       	mov	r7, r31
     636:	f0 2d       	mov	r31, r0
	// process switch values - UP
	if ((up & 0b00000111) == 0)
	{ up = up | 0b00000100; SRAM_LCD_Text [19] = 0xde; }
	else
	  if (((~up) & 7) == 0)
	  { up = up & 0b11111011; SRAM_LCD_Text [19] = ' ';
     638:	08 e3       	ldi	r16, 0x38	; 56
     63a:	1a e0       	ldi	r17, 0x0A	; 10
     63c:	68 94       	set
     63e:	22 24       	eor	r2, r2
     640:	25 f8       	bld	r2, 5
	if ((enter & 0b00000111) == 0)
	{ enter = enter | 0b00000100; SRAM_LCD_Text [19] = 0x1c; }
	else
	  if (((~enter) & 7) == 0)
	  { enter = enter & 0b11111011; SRAM_LCD_Text [19] = ' ';
	    para = ENTER;
     642:	1b 83       	std	Y+3, r17	; 0x03
     644:	0a 83       	std	Y+2, r16	; 0x02
     646:	14 2d       	mov	r17, r4
enum {NADA, UP, DOWN, LEFT, RIGHT, ENTER};
//-------------------------------------------------------------
void  vTaster ( void * pvParameters)
{ unsigned char  up=3, down=3, left=3, right=3, enter=3, para;
  for (;;)
  { vTaskDelay (3); // 3x 3ms = 9ms
     648:	83 e0       	ldi	r24, 0x03	; 3
     64a:	90 e0       	ldi	r25, 0x00	; 0
     64c:	0e 94 cb 15 	call	0x2b96	; 0x2b96 <vTaskDelay>
    down = (down & 0b11111101) | ((down & 0b00000001) << 1);
    left = (left & 0b11111101) | ((left & 0b00000001) << 1);
    right = (right & 0b11111101) | ((right & 0b00000001) << 1);
    enter = (enter & 0b11111101) | ((enter & 0b00000001) << 1);
	// read actual values from pins
	up = (up & 0b11111110) | ((PING & 0b00000100) >> 2);
     650:	e3 e6       	ldi	r30, 0x63	; 99
     652:	f0 e0       	ldi	r31, 0x00	; 0
     654:	20 81       	ld	r18, Z
     656:	f5 2d       	mov	r31, r5
     658:	f1 70       	andi	r31, 0x01	; 1
     65a:	fc 83       	std	Y+4, r31	; 0x04
     65c:	1d 82       	std	Y+5, r1	; 0x05
     65e:	8c 81       	ldd	r24, Y+4	; 0x04
     660:	9d 81       	ldd	r25, Y+5	; 0x05
     662:	88 0f       	add	r24, r24
     664:	99 1f       	adc	r25, r25
     666:	35 2d       	mov	r19, r5
     668:	3d 7f       	andi	r19, 0xFD	; 253
     66a:	83 2b       	or	r24, r19
     66c:	8e 7f       	andi	r24, 0xFE	; 254
     66e:	22 fb       	bst	r18, 2
     670:	55 24       	eor	r5, r5
     672:	50 f8       	bld	r5, 0
     674:	58 2a       	or	r5, r24
    down = (down & 0b11111110) | ((PINA & 0b00100000) >> 5);
     676:	29 b3       	in	r18, 0x19	; 25
     678:	40 fa       	bst	r4, 0
     67a:	ee 24       	eor	r14, r14
     67c:	e0 f8       	bld	r14, 0
     67e:	f1 2c       	mov	r15, r1
     680:	c7 01       	movw	r24, r14
     682:	88 0f       	add	r24, r24
     684:	99 1f       	adc	r25, r25
     686:	34 2d       	mov	r19, r4
     688:	3d 7f       	andi	r19, 0xFD	; 253
     68a:	83 2b       	or	r24, r19
     68c:	8e 7f       	andi	r24, 0xFE	; 254
     68e:	25 fb       	bst	r18, 5
     690:	44 24       	eor	r4, r4
     692:	40 f8       	bld	r4, 0
     694:	48 2a       	or	r4, r24
    left = (left & 0b11111110) | ((PINA & 0b10000000) >> 7);
     696:	29 b3       	in	r18, 0x19	; 25
     698:	30 fa       	bst	r3, 0
     69a:	cc 24       	eor	r12, r12
     69c:	c0 f8       	bld	r12, 0
     69e:	d1 2c       	mov	r13, r1
     6a0:	c6 01       	movw	r24, r12
     6a2:	88 0f       	add	r24, r24
     6a4:	99 1f       	adc	r25, r25
     6a6:	33 2d       	mov	r19, r3
     6a8:	3d 7f       	andi	r19, 0xFD	; 253
     6aa:	83 2b       	or	r24, r19
     6ac:	8e 7f       	andi	r24, 0xFE	; 254
     6ae:	32 2e       	mov	r3, r18
     6b0:	33 1c       	adc	r3, r3
     6b2:	33 24       	eor	r3, r3
     6b4:	33 1c       	adc	r3, r3
     6b6:	38 2a       	or	r3, r24
    right = (right & 0b11111110) | ((PINA & 0b00010000) >> 4);
     6b8:	29 b3       	in	r18, 0x19	; 25
     6ba:	10 fb       	bst	r17, 0
     6bc:	aa 24       	eor	r10, r10
     6be:	a0 f8       	bld	r10, 0
     6c0:	b1 2c       	mov	r11, r1
     6c2:	c5 01       	movw	r24, r10
     6c4:	88 0f       	add	r24, r24
     6c6:	99 1f       	adc	r25, r25
     6c8:	91 2f       	mov	r25, r17
     6ca:	9d 7f       	andi	r25, 0xFD	; 253
     6cc:	89 2b       	or	r24, r25
     6ce:	8e 7f       	andi	r24, 0xFE	; 254
     6d0:	24 fb       	bst	r18, 4
     6d2:	99 27       	eor	r25, r25
     6d4:	90 f9       	bld	r25, 0
     6d6:	18 2f       	mov	r17, r24
     6d8:	19 2b       	or	r17, r25
    enter = (enter & 0b11111110) | ((PINA & 0b01000000) >> 6);
     6da:	29 b3       	in	r18, 0x19	; 25
     6dc:	70 fa       	bst	r7, 0
     6de:	88 24       	eor	r8, r8
     6e0:	80 f8       	bld	r8, 0
     6e2:	91 2c       	mov	r9, r1
     6e4:	c4 01       	movw	r24, r8
     6e6:	88 0f       	add	r24, r24
     6e8:	99 1f       	adc	r25, r25
     6ea:	97 2d       	mov	r25, r7
     6ec:	9d 7f       	andi	r25, 0xFD	; 253
     6ee:	89 2b       	or	r24, r25
     6f0:	8e 7f       	andi	r24, 0xFE	; 254
     6f2:	26 fb       	bst	r18, 6
     6f4:	99 27       	eor	r25, r25
     6f6:	90 f9       	bld	r25, 0
     6f8:	78 2e       	mov	r7, r24
     6fa:	79 2a       	or	r7, r25
	// process switch values - UP
	if ((up & 0b00000111) == 0)
     6fc:	85 2d       	mov	r24, r5
     6fe:	87 70       	andi	r24, 0x07	; 7
     700:	41 f4       	brne	.+16     	; 0x712 <vTaster+0x108>
	{ up = up | 0b00000100; SRAM_LCD_Text [19] = 0xde; }
     702:	85 2d       	mov	r24, r5
     704:	84 60       	ori	r24, 0x04	; 4
     706:	58 2e       	mov	r5, r24
     708:	8e ed       	ldi	r24, 0xDE	; 222
     70a:	ea 81       	ldd	r30, Y+2	; 0x02
     70c:	fb 81       	ldd	r31, Y+3	; 0x03
     70e:	83 8b       	std	Z+19, r24	; 0x13
     710:	1e c0       	rjmp	.+60     	; 0x74e <vTaster+0x144>
	else
	  if (((~up) & 7) == 0)
     712:	85 2d       	mov	r24, r5
     714:	90 e0       	ldi	r25, 0x00	; 0
     716:	80 95       	com	r24
     718:	90 95       	com	r25
     71a:	87 70       	andi	r24, 0x07	; 7
     71c:	99 27       	eor	r25, r25
     71e:	89 2b       	or	r24, r25
     720:	b1 f4       	brne	.+44     	; 0x74e <vTaster+0x144>
	  { up = up & 0b11111011; SRAM_LCD_Text [19] = ' ';
     722:	e5 2d       	mov	r30, r5
     724:	eb 7f       	andi	r30, 0xFB	; 251
     726:	5e 2e       	mov	r5, r30
     728:	ea 81       	ldd	r30, Y+2	; 0x02
     72a:	fb 81       	ldd	r31, Y+3	; 0x03
     72c:	23 8a       	std	Z+19, r2	; 0x13
	    para = UP;
     72e:	f1 e0       	ldi	r31, 0x01	; 1
     730:	f9 83       	std	Y+1, r31	; 0x01
	    if (QueueTaster != 0)  xQueueSend (QueueTaster, &para, 0);
     732:	80 91 9f 0a 	lds	r24, 0x0A9F	; 0x800a9f <QueueTaster>
     736:	90 91 a0 0a 	lds	r25, 0x0AA0	; 0x800aa0 <QueueTaster+0x1>
     73a:	00 97       	sbiw	r24, 0x00	; 0
     73c:	41 f0       	breq	.+16     	; 0x74e <vTaster+0x144>
     73e:	20 e0       	ldi	r18, 0x00	; 0
     740:	40 e0       	ldi	r20, 0x00	; 0
     742:	50 e0       	ldi	r21, 0x00	; 0
     744:	be 01       	movw	r22, r28
     746:	6f 5f       	subi	r22, 0xFF	; 255
     748:	7f 4f       	sbci	r23, 0xFF	; 255
     74a:	0e 94 f0 0f 	call	0x1fe0	; 0x1fe0 <xQueueGenericSend>
      }
	// process switch values - DOWN
	if ((down & 0b00000111) == 0)
     74e:	84 2d       	mov	r24, r4
     750:	87 70       	andi	r24, 0x07	; 7
     752:	41 f4       	brne	.+16     	; 0x764 <vTaster+0x15a>
	{ down = down | 0b00000100; SRAM_LCD_Text [19] = 0xe0; }
     754:	84 2d       	mov	r24, r4
     756:	84 60       	ori	r24, 0x04	; 4
     758:	48 2e       	mov	r4, r24
     75a:	80 ee       	ldi	r24, 0xE0	; 224
     75c:	ea 81       	ldd	r30, Y+2	; 0x02
     75e:	fb 81       	ldd	r31, Y+3	; 0x03
     760:	83 8b       	std	Z+19, r24	; 0x13
     762:	1e c0       	rjmp	.+60     	; 0x7a0 <vTaster+0x196>
	else
	  if (((~down) & 7) == 0)
     764:	84 2d       	mov	r24, r4
     766:	90 e0       	ldi	r25, 0x00	; 0
     768:	80 95       	com	r24
     76a:	90 95       	com	r25
     76c:	87 70       	andi	r24, 0x07	; 7
     76e:	99 27       	eor	r25, r25
     770:	89 2b       	or	r24, r25
     772:	b1 f4       	brne	.+44     	; 0x7a0 <vTaster+0x196>
	  { down = down & 0b11111011; SRAM_LCD_Text [19] = ' ';
     774:	e4 2d       	mov	r30, r4
     776:	eb 7f       	andi	r30, 0xFB	; 251
     778:	4e 2e       	mov	r4, r30
     77a:	ea 81       	ldd	r30, Y+2	; 0x02
     77c:	fb 81       	ldd	r31, Y+3	; 0x03
     77e:	23 8a       	std	Z+19, r2	; 0x13
	    para = DOWN;
     780:	f2 e0       	ldi	r31, 0x02	; 2
     782:	f9 83       	std	Y+1, r31	; 0x01
	    if (QueueTaster != 0)  xQueueSend (QueueTaster, &para, 0);
     784:	80 91 9f 0a 	lds	r24, 0x0A9F	; 0x800a9f <QueueTaster>
     788:	90 91 a0 0a 	lds	r25, 0x0AA0	; 0x800aa0 <QueueTaster+0x1>
     78c:	00 97       	sbiw	r24, 0x00	; 0
     78e:	41 f0       	breq	.+16     	; 0x7a0 <vTaster+0x196>
     790:	20 e0       	ldi	r18, 0x00	; 0
     792:	40 e0       	ldi	r20, 0x00	; 0
     794:	50 e0       	ldi	r21, 0x00	; 0
     796:	be 01       	movw	r22, r28
     798:	6f 5f       	subi	r22, 0xFF	; 255
     79a:	7f 4f       	sbci	r23, 0xFF	; 255
     79c:	0e 94 f0 0f 	call	0x1fe0	; 0x1fe0 <xQueueGenericSend>
      }
	// process switch values - LEFT
	if ((left & 0b00000111) == 0)
     7a0:	83 2d       	mov	r24, r3
     7a2:	87 70       	andi	r24, 0x07	; 7
     7a4:	41 f4       	brne	.+16     	; 0x7b6 <vTaster+0x1ac>
	{ left = left | 0b00000100; SRAM_LCD_Text [19] = 0xe1; }
     7a6:	83 2d       	mov	r24, r3
     7a8:	84 60       	ori	r24, 0x04	; 4
     7aa:	38 2e       	mov	r3, r24
     7ac:	81 ee       	ldi	r24, 0xE1	; 225
     7ae:	ea 81       	ldd	r30, Y+2	; 0x02
     7b0:	fb 81       	ldd	r31, Y+3	; 0x03
     7b2:	83 8b       	std	Z+19, r24	; 0x13
     7b4:	1e c0       	rjmp	.+60     	; 0x7f2 <vTaster+0x1e8>
	else
	  if (((~left) & 7) == 0)
     7b6:	83 2d       	mov	r24, r3
     7b8:	90 e0       	ldi	r25, 0x00	; 0
     7ba:	80 95       	com	r24
     7bc:	90 95       	com	r25
     7be:	87 70       	andi	r24, 0x07	; 7
     7c0:	99 27       	eor	r25, r25
     7c2:	89 2b       	or	r24, r25
     7c4:	b1 f4       	brne	.+44     	; 0x7f2 <vTaster+0x1e8>
	  { left = left & 0b11111011; SRAM_LCD_Text [19] = ' ';
     7c6:	e3 2d       	mov	r30, r3
     7c8:	eb 7f       	andi	r30, 0xFB	; 251
     7ca:	3e 2e       	mov	r3, r30
     7cc:	ea 81       	ldd	r30, Y+2	; 0x02
     7ce:	fb 81       	ldd	r31, Y+3	; 0x03
     7d0:	23 8a       	std	Z+19, r2	; 0x13
	    para =LEFT;
     7d2:	f3 e0       	ldi	r31, 0x03	; 3
     7d4:	f9 83       	std	Y+1, r31	; 0x01
	    if (QueueTaster != 0)  xQueueSend (QueueTaster, &para, 0);
     7d6:	80 91 9f 0a 	lds	r24, 0x0A9F	; 0x800a9f <QueueTaster>
     7da:	90 91 a0 0a 	lds	r25, 0x0AA0	; 0x800aa0 <QueueTaster+0x1>
     7de:	00 97       	sbiw	r24, 0x00	; 0
     7e0:	41 f0       	breq	.+16     	; 0x7f2 <vTaster+0x1e8>
     7e2:	20 e0       	ldi	r18, 0x00	; 0
     7e4:	40 e0       	ldi	r20, 0x00	; 0
     7e6:	50 e0       	ldi	r21, 0x00	; 0
     7e8:	be 01       	movw	r22, r28
     7ea:	6f 5f       	subi	r22, 0xFF	; 255
     7ec:	7f 4f       	sbci	r23, 0xFF	; 255
     7ee:	0e 94 f0 0f 	call	0x1fe0	; 0x1fe0 <xQueueGenericSend>
      }
	// process switch values - RIGHT
	if ((right & 0b00000111) == 0)
     7f2:	81 2f       	mov	r24, r17
     7f4:	87 70       	andi	r24, 0x07	; 7
     7f6:	31 f4       	brne	.+12     	; 0x804 <vTaster+0x1fa>
	{ right = right | 0b00000100; SRAM_LCD_Text [19] = 0xdf; }
     7f8:	14 60       	ori	r17, 0x04	; 4
     7fa:	8f ed       	ldi	r24, 0xDF	; 223
     7fc:	ea 81       	ldd	r30, Y+2	; 0x02
     7fe:	fb 81       	ldd	r31, Y+3	; 0x03
     800:	83 8b       	std	Z+19, r24	; 0x13
     802:	1c c0       	rjmp	.+56     	; 0x83c <vTaster+0x232>
	else
	  if (((~right) & 7) == 0)
     804:	81 2f       	mov	r24, r17
     806:	90 e0       	ldi	r25, 0x00	; 0
     808:	80 95       	com	r24
     80a:	90 95       	com	r25
     80c:	87 70       	andi	r24, 0x07	; 7
     80e:	99 27       	eor	r25, r25
     810:	89 2b       	or	r24, r25
     812:	a1 f4       	brne	.+40     	; 0x83c <vTaster+0x232>
	  { right = right & 0b11111011; SRAM_LCD_Text [19] = ' ';
     814:	1b 7f       	andi	r17, 0xFB	; 251
     816:	ea 81       	ldd	r30, Y+2	; 0x02
     818:	fb 81       	ldd	r31, Y+3	; 0x03
     81a:	23 8a       	std	Z+19, r2	; 0x13
	    para = RIGHT;
     81c:	f4 e0       	ldi	r31, 0x04	; 4
     81e:	f9 83       	std	Y+1, r31	; 0x01
	    if (QueueTaster != 0)  xQueueSend (QueueTaster, &para, 0);
     820:	80 91 9f 0a 	lds	r24, 0x0A9F	; 0x800a9f <QueueTaster>
     824:	90 91 a0 0a 	lds	r25, 0x0AA0	; 0x800aa0 <QueueTaster+0x1>
     828:	00 97       	sbiw	r24, 0x00	; 0
     82a:	41 f0       	breq	.+16     	; 0x83c <vTaster+0x232>
     82c:	20 e0       	ldi	r18, 0x00	; 0
     82e:	40 e0       	ldi	r20, 0x00	; 0
     830:	50 e0       	ldi	r21, 0x00	; 0
     832:	be 01       	movw	r22, r28
     834:	6f 5f       	subi	r22, 0xFF	; 255
     836:	7f 4f       	sbci	r23, 0xFF	; 255
     838:	0e 94 f0 0f 	call	0x1fe0	; 0x1fe0 <xQueueGenericSend>
      }
	// process switch values - ENTER
	if ((enter & 0b00000111) == 0)
     83c:	87 2d       	mov	r24, r7
     83e:	87 70       	andi	r24, 0x07	; 7
     840:	41 f4       	brne	.+16     	; 0x852 <vTaster+0x248>
	{ enter = enter | 0b00000100; SRAM_LCD_Text [19] = 0x1c; }
     842:	87 2d       	mov	r24, r7
     844:	84 60       	ori	r24, 0x04	; 4
     846:	78 2e       	mov	r7, r24
     848:	8c e1       	ldi	r24, 0x1C	; 28
     84a:	ea 81       	ldd	r30, Y+2	; 0x02
     84c:	fb 81       	ldd	r31, Y+3	; 0x03
     84e:	83 8b       	std	Z+19, r24	; 0x13
     850:	fb ce       	rjmp	.-522    	; 0x648 <vTaster+0x3e>
	else
	  if (((~enter) & 7) == 0)
     852:	87 2d       	mov	r24, r7
     854:	90 e0       	ldi	r25, 0x00	; 0
     856:	80 95       	com	r24
     858:	90 95       	com	r25
     85a:	87 70       	andi	r24, 0x07	; 7
     85c:	99 27       	eor	r25, r25
     85e:	89 2b       	or	r24, r25
     860:	09 f0       	breq	.+2      	; 0x864 <vTaster+0x25a>
     862:	f2 ce       	rjmp	.-540    	; 0x648 <vTaster+0x3e>
	  { enter = enter & 0b11111011; SRAM_LCD_Text [19] = ' ';
     864:	f7 2d       	mov	r31, r7
     866:	fb 7f       	andi	r31, 0xFB	; 251
     868:	7f 2e       	mov	r7, r31
     86a:	ea 81       	ldd	r30, Y+2	; 0x02
     86c:	fb 81       	ldd	r31, Y+3	; 0x03
     86e:	23 8a       	std	Z+19, r2	; 0x13
	    para = ENTER;
     870:	f5 e0       	ldi	r31, 0x05	; 5
     872:	f9 83       	std	Y+1, r31	; 0x01
	    if (QueueTaster != 0)  xQueueSend (QueueTaster, &para, 0);
     874:	80 91 9f 0a 	lds	r24, 0x0A9F	; 0x800a9f <QueueTaster>
     878:	90 91 a0 0a 	lds	r25, 0x0AA0	; 0x800aa0 <QueueTaster+0x1>
     87c:	00 97       	sbiw	r24, 0x00	; 0
     87e:	09 f4       	brne	.+2      	; 0x882 <vTaster+0x278>
     880:	e3 ce       	rjmp	.-570    	; 0x648 <vTaster+0x3e>
     882:	20 e0       	ldi	r18, 0x00	; 0
     884:	40 e0       	ldi	r20, 0x00	; 0
     886:	50 e0       	ldi	r21, 0x00	; 0
     888:	be 01       	movw	r22, r28
     88a:	6f 5f       	subi	r22, 0xFF	; 255
     88c:	7f 4f       	sbci	r23, 0xFF	; 255
     88e:	0e 94 f0 0f 	call	0x1fe0	; 0x1fe0 <xQueueGenericSend>
     892:	da ce       	rjmp	.-588    	; 0x648 <vTaster+0x3e>

00000894 <floatvalues2LCD>:
      }
  } // end for
}
/*-----------------------------------------------------------*/
void  floatvalues2LCD (float  first_para, float  second_para)
{ char  sign;
     894:	8f 92       	push	r8
     896:	9f 92       	push	r9
     898:	af 92       	push	r10
     89a:	bf 92       	push	r11
     89c:	cf 92       	push	r12
     89e:	df 92       	push	r13
     8a0:	ef 92       	push	r14
     8a2:	ff 92       	push	r15
     8a4:	1f 93       	push	r17
     8a6:	cf 93       	push	r28
     8a8:	df 93       	push	r29
     8aa:	4b 01       	movw	r8, r22
     8ac:	5c 01       	movw	r10, r24
     8ae:	69 01       	movw	r12, r18
     8b0:	7a 01       	movw	r14, r20
	unsigned char  e0, e_1, e_2, e_3;
  if (first_para > 0.0)  sign = '+';  
     8b2:	20 e0       	ldi	r18, 0x00	; 0
     8b4:	30 e0       	ldi	r19, 0x00	; 0
     8b6:	a9 01       	movw	r20, r18
     8b8:	0e 94 46 19 	call	0x328c	; 0x328c <__gesf2>
     8bc:	18 16       	cp	r1, r24
     8be:	34 f0       	brlt	.+12     	; 0x8cc <floatvalues2LCD+0x38>
  else  {sign = '-';  first_para = -1.0 * first_para;}
     8c0:	b7 fa       	bst	r11, 7
     8c2:	b0 94       	com	r11
     8c4:	b7 f8       	bld	r11, 7
     8c6:	b0 94       	com	r11
     8c8:	8d e2       	ldi	r24, 0x2D	; 45
     8ca:	01 c0       	rjmp	.+2      	; 0x8ce <floatvalues2LCD+0x3a>
}
/*-----------------------------------------------------------*/
void  floatvalues2LCD (float  first_para, float  second_para)
{ char  sign;
	unsigned char  e0, e_1, e_2, e_3;
  if (first_para > 0.0)  sign = '+';  
     8cc:	8b e2       	ldi	r24, 0x2B	; 43
  else  {sign = '-';  first_para = -1.0 * first_para;}
  SRAM_LCD_Text[34] = sign;
     8ce:	c8 e3       	ldi	r28, 0x38	; 56
     8d0:	da e0       	ldi	r29, 0x0A	; 10
     8d2:	8a a3       	std	Y+34, r24	; 0x22
  e0 = (unsigned char) first_para;
     8d4:	c5 01       	movw	r24, r10
     8d6:	b4 01       	movw	r22, r8
     8d8:	0e 94 68 18 	call	0x30d0	; 0x30d0 <__fixunssfsi>
     8dc:	16 2f       	mov	r17, r22
  SRAM_LCD_Text[35] = e0 + '0';
     8de:	80 e3       	ldi	r24, 0x30	; 48
     8e0:	81 0f       	add	r24, r17
     8e2:	8b a3       	std	Y+35, r24	; 0x23
  first_para = (first_para*10) - (float)(e0 * 10);
     8e4:	20 e0       	ldi	r18, 0x00	; 0
     8e6:	30 e0       	ldi	r19, 0x00	; 0
     8e8:	40 e2       	ldi	r20, 0x20	; 32
     8ea:	51 e4       	ldi	r21, 0x41	; 65
     8ec:	c5 01       	movw	r24, r10
     8ee:	b4 01       	movw	r22, r8
     8f0:	0e 94 4a 19 	call	0x3294	; 0x3294 <__mulsf3>
     8f4:	4b 01       	movw	r8, r22
     8f6:	5c 01       	movw	r10, r24
     8f8:	81 2f       	mov	r24, r17
     8fa:	90 e0       	ldi	r25, 0x00	; 0
     8fc:	bc 01       	movw	r22, r24
     8fe:	66 0f       	add	r22, r22
     900:	77 1f       	adc	r23, r23
     902:	88 0f       	add	r24, r24
     904:	99 1f       	adc	r25, r25
     906:	88 0f       	add	r24, r24
     908:	99 1f       	adc	r25, r25
     90a:	88 0f       	add	r24, r24
     90c:	99 1f       	adc	r25, r25
     90e:	68 0f       	add	r22, r24
     910:	79 1f       	adc	r23, r25
     912:	07 2e       	mov	r0, r23
     914:	00 0c       	add	r0, r0
     916:	88 0b       	sbc	r24, r24
     918:	99 0b       	sbc	r25, r25
     91a:	0e 94 96 18 	call	0x312c	; 0x312c <__floatsisf>
     91e:	9b 01       	movw	r18, r22
     920:	ac 01       	movw	r20, r24
     922:	c5 01       	movw	r24, r10
     924:	b4 01       	movw	r22, r8
     926:	0e 94 92 17 	call	0x2f24	; 0x2f24 <__subsf3>
     92a:	4b 01       	movw	r8, r22
     92c:	5c 01       	movw	r10, r24
  e_1 = (unsigned char) first_para;
     92e:	0e 94 68 18 	call	0x30d0	; 0x30d0 <__fixunssfsi>
     932:	16 2f       	mov	r17, r22
  SRAM_LCD_Text[37] = e_1 + '0';
     934:	80 e3       	ldi	r24, 0x30	; 48
     936:	81 0f       	add	r24, r17
     938:	8d a3       	std	Y+37, r24	; 0x25
  first_para = (first_para*10) - (float)(e_1 * 10);
     93a:	20 e0       	ldi	r18, 0x00	; 0
     93c:	30 e0       	ldi	r19, 0x00	; 0
     93e:	40 e2       	ldi	r20, 0x20	; 32
     940:	51 e4       	ldi	r21, 0x41	; 65
     942:	c5 01       	movw	r24, r10
     944:	b4 01       	movw	r22, r8
     946:	0e 94 4a 19 	call	0x3294	; 0x3294 <__mulsf3>
     94a:	4b 01       	movw	r8, r22
     94c:	5c 01       	movw	r10, r24
     94e:	81 2f       	mov	r24, r17
     950:	90 e0       	ldi	r25, 0x00	; 0
     952:	bc 01       	movw	r22, r24
     954:	66 0f       	add	r22, r22
     956:	77 1f       	adc	r23, r23
     958:	88 0f       	add	r24, r24
     95a:	99 1f       	adc	r25, r25
     95c:	88 0f       	add	r24, r24
     95e:	99 1f       	adc	r25, r25
     960:	88 0f       	add	r24, r24
     962:	99 1f       	adc	r25, r25
     964:	68 0f       	add	r22, r24
     966:	79 1f       	adc	r23, r25
     968:	07 2e       	mov	r0, r23
     96a:	00 0c       	add	r0, r0
     96c:	88 0b       	sbc	r24, r24
     96e:	99 0b       	sbc	r25, r25
     970:	0e 94 96 18 	call	0x312c	; 0x312c <__floatsisf>
     974:	9b 01       	movw	r18, r22
     976:	ac 01       	movw	r20, r24
     978:	c5 01       	movw	r24, r10
     97a:	b4 01       	movw	r22, r8
     97c:	0e 94 92 17 	call	0x2f24	; 0x2f24 <__subsf3>
     980:	4b 01       	movw	r8, r22
     982:	5c 01       	movw	r10, r24
  e_2 = (unsigned char) first_para;
     984:	0e 94 68 18 	call	0x30d0	; 0x30d0 <__fixunssfsi>
     988:	16 2f       	mov	r17, r22
  SRAM_LCD_Text[38] = e_2 + '0';
     98a:	80 e3       	ldi	r24, 0x30	; 48
     98c:	81 0f       	add	r24, r17
     98e:	8e a3       	std	Y+38, r24	; 0x26
  first_para = (first_para*10) - (float)(e_2 * 10);
     990:	20 e0       	ldi	r18, 0x00	; 0
     992:	30 e0       	ldi	r19, 0x00	; 0
     994:	40 e2       	ldi	r20, 0x20	; 32
     996:	51 e4       	ldi	r21, 0x41	; 65
     998:	c5 01       	movw	r24, r10
     99a:	b4 01       	movw	r22, r8
     99c:	0e 94 4a 19 	call	0x3294	; 0x3294 <__mulsf3>
     9a0:	4b 01       	movw	r8, r22
     9a2:	5c 01       	movw	r10, r24
  e_3 = (unsigned char) first_para;
  SRAM_LCD_Text[39] = e_3 + '0';
     9a4:	81 2f       	mov	r24, r17
     9a6:	90 e0       	ldi	r25, 0x00	; 0
     9a8:	bc 01       	movw	r22, r24
     9aa:	66 0f       	add	r22, r22
     9ac:	77 1f       	adc	r23, r23
     9ae:	88 0f       	add	r24, r24
     9b0:	99 1f       	adc	r25, r25
     9b2:	88 0f       	add	r24, r24
     9b4:	99 1f       	adc	r25, r25
     9b6:	88 0f       	add	r24, r24
     9b8:	99 1f       	adc	r25, r25
     9ba:	68 0f       	add	r22, r24
     9bc:	79 1f       	adc	r23, r25
     9be:	07 2e       	mov	r0, r23
     9c0:	00 0c       	add	r0, r0
     9c2:	88 0b       	sbc	r24, r24
     9c4:	99 0b       	sbc	r25, r25
     9c6:	0e 94 96 18 	call	0x312c	; 0x312c <__floatsisf>
     9ca:	9b 01       	movw	r18, r22
     9cc:	ac 01       	movw	r20, r24
     9ce:	c5 01       	movw	r24, r10
     9d0:	b4 01       	movw	r22, r8
     9d2:	0e 94 92 17 	call	0x2f24	; 0x2f24 <__subsf3>
     9d6:	0e 94 68 18 	call	0x30d0	; 0x30d0 <__fixunssfsi>
     9da:	60 5d       	subi	r22, 0xD0	; 208
     9dc:	6f a3       	std	Y+39, r22	; 0x27
  //
  if (second_para > 0.0)  sign = '+';  
     9de:	20 e0       	ldi	r18, 0x00	; 0
     9e0:	30 e0       	ldi	r19, 0x00	; 0
     9e2:	a9 01       	movw	r20, r18
     9e4:	c7 01       	movw	r24, r14
     9e6:	b6 01       	movw	r22, r12
     9e8:	0e 94 46 19 	call	0x328c	; 0x328c <__gesf2>
     9ec:	18 16       	cp	r1, r24
     9ee:	34 f0       	brlt	.+12     	; 0x9fc <floatvalues2LCD+0x168>
  else  {sign = '-';  second_para = -1.0 * second_para;}
     9f0:	f7 fa       	bst	r15, 7
     9f2:	f0 94       	com	r15
     9f4:	f7 f8       	bld	r15, 7
     9f6:	f0 94       	com	r15
     9f8:	8d e2       	ldi	r24, 0x2D	; 45
     9fa:	01 c0       	rjmp	.+2      	; 0x9fe <floatvalues2LCD+0x16a>
  SRAM_LCD_Text[38] = e_2 + '0';
  first_para = (first_para*10) - (float)(e_2 * 10);
  e_3 = (unsigned char) first_para;
  SRAM_LCD_Text[39] = e_3 + '0';
  //
  if (second_para > 0.0)  sign = '+';  
     9fc:	8b e2       	ldi	r24, 0x2B	; 43
  else  {sign = '-';  second_para = -1.0 * second_para;}
  SRAM_LCD_Text[54] = sign;
     9fe:	c8 e3       	ldi	r28, 0x38	; 56
     a00:	da e0       	ldi	r29, 0x0A	; 10
     a02:	8e ab       	std	Y+54, r24	; 0x36
  e0 = (unsigned char) second_para;
     a04:	c7 01       	movw	r24, r14
     a06:	b6 01       	movw	r22, r12
     a08:	0e 94 68 18 	call	0x30d0	; 0x30d0 <__fixunssfsi>
     a0c:	16 2f       	mov	r17, r22
  SRAM_LCD_Text[55] = e0 + '0';
     a0e:	80 e3       	ldi	r24, 0x30	; 48
     a10:	81 0f       	add	r24, r17
     a12:	8f ab       	std	Y+55, r24	; 0x37
  second_para = (second_para*10) - (float)(e0 * 10);
     a14:	20 e0       	ldi	r18, 0x00	; 0
     a16:	30 e0       	ldi	r19, 0x00	; 0
     a18:	40 e2       	ldi	r20, 0x20	; 32
     a1a:	51 e4       	ldi	r21, 0x41	; 65
     a1c:	c7 01       	movw	r24, r14
     a1e:	b6 01       	movw	r22, r12
     a20:	0e 94 4a 19 	call	0x3294	; 0x3294 <__mulsf3>
     a24:	6b 01       	movw	r12, r22
     a26:	7c 01       	movw	r14, r24
     a28:	81 2f       	mov	r24, r17
     a2a:	90 e0       	ldi	r25, 0x00	; 0
     a2c:	bc 01       	movw	r22, r24
     a2e:	66 0f       	add	r22, r22
     a30:	77 1f       	adc	r23, r23
     a32:	88 0f       	add	r24, r24
     a34:	99 1f       	adc	r25, r25
     a36:	88 0f       	add	r24, r24
     a38:	99 1f       	adc	r25, r25
     a3a:	88 0f       	add	r24, r24
     a3c:	99 1f       	adc	r25, r25
     a3e:	68 0f       	add	r22, r24
     a40:	79 1f       	adc	r23, r25
     a42:	07 2e       	mov	r0, r23
     a44:	00 0c       	add	r0, r0
     a46:	88 0b       	sbc	r24, r24
     a48:	99 0b       	sbc	r25, r25
     a4a:	0e 94 96 18 	call	0x312c	; 0x312c <__floatsisf>
     a4e:	9b 01       	movw	r18, r22
     a50:	ac 01       	movw	r20, r24
     a52:	c7 01       	movw	r24, r14
     a54:	b6 01       	movw	r22, r12
     a56:	0e 94 92 17 	call	0x2f24	; 0x2f24 <__subsf3>
     a5a:	6b 01       	movw	r12, r22
     a5c:	7c 01       	movw	r14, r24
  e_1 = (unsigned char) second_para;
     a5e:	0e 94 68 18 	call	0x30d0	; 0x30d0 <__fixunssfsi>
     a62:	16 2f       	mov	r17, r22
  SRAM_LCD_Text[57] = e_1 + '0';
     a64:	80 e3       	ldi	r24, 0x30	; 48
     a66:	81 0f       	add	r24, r17
     a68:	89 af       	std	Y+57, r24	; 0x39
  second_para = (second_para*10) - (float)(e_1 * 10);
     a6a:	20 e0       	ldi	r18, 0x00	; 0
     a6c:	30 e0       	ldi	r19, 0x00	; 0
     a6e:	40 e2       	ldi	r20, 0x20	; 32
     a70:	51 e4       	ldi	r21, 0x41	; 65
     a72:	c7 01       	movw	r24, r14
     a74:	b6 01       	movw	r22, r12
     a76:	0e 94 4a 19 	call	0x3294	; 0x3294 <__mulsf3>
     a7a:	6b 01       	movw	r12, r22
     a7c:	7c 01       	movw	r14, r24
     a7e:	81 2f       	mov	r24, r17
     a80:	90 e0       	ldi	r25, 0x00	; 0
     a82:	bc 01       	movw	r22, r24
     a84:	66 0f       	add	r22, r22
     a86:	77 1f       	adc	r23, r23
     a88:	88 0f       	add	r24, r24
     a8a:	99 1f       	adc	r25, r25
     a8c:	88 0f       	add	r24, r24
     a8e:	99 1f       	adc	r25, r25
     a90:	88 0f       	add	r24, r24
     a92:	99 1f       	adc	r25, r25
     a94:	68 0f       	add	r22, r24
     a96:	79 1f       	adc	r23, r25
     a98:	07 2e       	mov	r0, r23
     a9a:	00 0c       	add	r0, r0
     a9c:	88 0b       	sbc	r24, r24
     a9e:	99 0b       	sbc	r25, r25
     aa0:	0e 94 96 18 	call	0x312c	; 0x312c <__floatsisf>
     aa4:	9b 01       	movw	r18, r22
     aa6:	ac 01       	movw	r20, r24
     aa8:	c7 01       	movw	r24, r14
     aaa:	b6 01       	movw	r22, r12
     aac:	0e 94 92 17 	call	0x2f24	; 0x2f24 <__subsf3>
     ab0:	6b 01       	movw	r12, r22
     ab2:	7c 01       	movw	r14, r24
  e_2 = (unsigned char) second_para;
     ab4:	0e 94 68 18 	call	0x30d0	; 0x30d0 <__fixunssfsi>
     ab8:	16 2f       	mov	r17, r22
  SRAM_LCD_Text[58] = e_2 + '0';
     aba:	80 e3       	ldi	r24, 0x30	; 48
     abc:	81 0f       	add	r24, r17
     abe:	8a af       	std	Y+58, r24	; 0x3a
  second_para = (second_para*10) - (float)(e_2 * 10);
     ac0:	20 e0       	ldi	r18, 0x00	; 0
     ac2:	30 e0       	ldi	r19, 0x00	; 0
     ac4:	40 e2       	ldi	r20, 0x20	; 32
     ac6:	51 e4       	ldi	r21, 0x41	; 65
     ac8:	c7 01       	movw	r24, r14
     aca:	b6 01       	movw	r22, r12
     acc:	0e 94 4a 19 	call	0x3294	; 0x3294 <__mulsf3>
     ad0:	6b 01       	movw	r12, r22
     ad2:	7c 01       	movw	r14, r24
  e_3 = (unsigned char) second_para;
  SRAM_LCD_Text[59] = e_3 + '0';
     ad4:	81 2f       	mov	r24, r17
     ad6:	90 e0       	ldi	r25, 0x00	; 0
     ad8:	bc 01       	movw	r22, r24
     ada:	66 0f       	add	r22, r22
     adc:	77 1f       	adc	r23, r23
     ade:	88 0f       	add	r24, r24
     ae0:	99 1f       	adc	r25, r25
     ae2:	88 0f       	add	r24, r24
     ae4:	99 1f       	adc	r25, r25
     ae6:	88 0f       	add	r24, r24
     ae8:	99 1f       	adc	r25, r25
     aea:	68 0f       	add	r22, r24
     aec:	79 1f       	adc	r23, r25
     aee:	07 2e       	mov	r0, r23
     af0:	00 0c       	add	r0, r0
     af2:	88 0b       	sbc	r24, r24
     af4:	99 0b       	sbc	r25, r25
     af6:	0e 94 96 18 	call	0x312c	; 0x312c <__floatsisf>
     afa:	9b 01       	movw	r18, r22
     afc:	ac 01       	movw	r20, r24
     afe:	c7 01       	movw	r24, r14
     b00:	b6 01       	movw	r22, r12
     b02:	0e 94 92 17 	call	0x2f24	; 0x2f24 <__subsf3>
     b06:	0e 94 68 18 	call	0x30d0	; 0x30d0 <__fixunssfsi>
     b0a:	60 5d       	subi	r22, 0xD0	; 208
     b0c:	6b af       	std	Y+59, r22	; 0x3b
}
     b0e:	df 91       	pop	r29
     b10:	cf 91       	pop	r28
     b12:	1f 91       	pop	r17
     b14:	ff 90       	pop	r15
     b16:	ef 90       	pop	r14
     b18:	df 90       	pop	r13
     b1a:	cf 90       	pop	r12
     b1c:	bf 90       	pop	r11
     b1e:	af 90       	pop	r10
     b20:	9f 90       	pop	r9
     b22:	8f 90       	pop	r8
     b24:	08 95       	ret

00000b26 <change_para>:
/*-----------------------------------------------------------*/
float  change_para (float  parameter)
{ char  para, sign, e0, e_1, e_2, e_3;
     b26:	4f 92       	push	r4
     b28:	5f 92       	push	r5
     b2a:	6f 92       	push	r6
     b2c:	7f 92       	push	r7
     b2e:	8f 92       	push	r8
     b30:	9f 92       	push	r9
     b32:	af 92       	push	r10
     b34:	bf 92       	push	r11
     b36:	cf 92       	push	r12
     b38:	df 92       	push	r13
     b3a:	ef 92       	push	r14
     b3c:	ff 92       	push	r15
     b3e:	0f 93       	push	r16
     b40:	1f 93       	push	r17
     b42:	cf 93       	push	r28
     b44:	df 93       	push	r29
     b46:	1f 92       	push	r1
     b48:	cd b7       	in	r28, 0x3d	; 61
     b4a:	de b7       	in	r29, 0x3e	; 62
     b4c:	4b 01       	movw	r8, r22
     b4e:	5c 01       	movw	r10, r24
  Cursor_X = 14;
     b50:	8e e0       	ldi	r24, 0x0E	; 14
     b52:	80 93 9a 0a 	sts	0x0A9A, r24	; 0x800a9a <Cursor_X>
  // Convert parameter to chars
  if (parameter > 0.0)  sign = '+';  
     b56:	20 e0       	ldi	r18, 0x00	; 0
     b58:	30 e0       	ldi	r19, 0x00	; 0
     b5a:	a9 01       	movw	r20, r18
     b5c:	c5 01       	movw	r24, r10
     b5e:	b4 01       	movw	r22, r8
     b60:	0e 94 46 19 	call	0x328c	; 0x328c <__gesf2>
     b64:	18 16       	cp	r1, r24
     b66:	4c f0       	brlt	.+18     	; 0xb7a <change_para+0x54>
  else  {sign = '-';  parameter = -1.0*parameter;}
     b68:	b7 fa       	bst	r11, 7
     b6a:	b0 94       	com	r11
     b6c:	b7 f8       	bld	r11, 7
     b6e:	b0 94       	com	r11
     b70:	0f 2e       	mov	r0, r31
     b72:	fd e2       	ldi	r31, 0x2D	; 45
     b74:	ef 2e       	mov	r14, r31
     b76:	f0 2d       	mov	r31, r0
     b78:	04 c0       	rjmp	.+8      	; 0xb82 <change_para+0x5c>
/*-----------------------------------------------------------*/
float  change_para (float  parameter)
{ char  para, sign, e0, e_1, e_2, e_3;
  Cursor_X = 14;
  // Convert parameter to chars
  if (parameter > 0.0)  sign = '+';  
     b7a:	0f 2e       	mov	r0, r31
     b7c:	fb e2       	ldi	r31, 0x2B	; 43
     b7e:	ef 2e       	mov	r14, r31
     b80:	f0 2d       	mov	r31, r0
  else  {sign = '-';  parameter = -1.0*parameter;}
  e0 = (unsigned char) parameter;
     b82:	c5 01       	movw	r24, r10
     b84:	b4 01       	movw	r22, r8
     b86:	0e 94 68 18 	call	0x30d0	; 0x30d0 <__fixunssfsi>
     b8a:	06 2f       	mov	r16, r22
  parameter = (parameter*10) - (float)(e0 * 10);
     b8c:	20 e0       	ldi	r18, 0x00	; 0
     b8e:	30 e0       	ldi	r19, 0x00	; 0
     b90:	40 e2       	ldi	r20, 0x20	; 32
     b92:	51 e4       	ldi	r21, 0x41	; 65
     b94:	c5 01       	movw	r24, r10
     b96:	b4 01       	movw	r22, r8
     b98:	0e 94 4a 19 	call	0x3294	; 0x3294 <__mulsf3>
     b9c:	4b 01       	movw	r8, r22
     b9e:	5c 01       	movw	r10, r24
     ba0:	80 2f       	mov	r24, r16
     ba2:	00 2e       	mov	r0, r16
     ba4:	00 0c       	add	r0, r0
     ba6:	99 0b       	sbc	r25, r25
     ba8:	bc 01       	movw	r22, r24
     baa:	66 0f       	add	r22, r22
     bac:	77 1f       	adc	r23, r23
     bae:	88 0f       	add	r24, r24
     bb0:	99 1f       	adc	r25, r25
     bb2:	88 0f       	add	r24, r24
     bb4:	99 1f       	adc	r25, r25
     bb6:	88 0f       	add	r24, r24
     bb8:	99 1f       	adc	r25, r25
     bba:	68 0f       	add	r22, r24
     bbc:	79 1f       	adc	r23, r25
     bbe:	07 2e       	mov	r0, r23
     bc0:	00 0c       	add	r0, r0
     bc2:	88 0b       	sbc	r24, r24
     bc4:	99 0b       	sbc	r25, r25
     bc6:	0e 94 96 18 	call	0x312c	; 0x312c <__floatsisf>
     bca:	9b 01       	movw	r18, r22
     bcc:	ac 01       	movw	r20, r24
     bce:	c5 01       	movw	r24, r10
     bd0:	b4 01       	movw	r22, r8
     bd2:	0e 94 92 17 	call	0x2f24	; 0x2f24 <__subsf3>
     bd6:	4b 01       	movw	r8, r22
     bd8:	5c 01       	movw	r10, r24
  e_1 = (unsigned char) parameter;
     bda:	0e 94 68 18 	call	0x30d0	; 0x30d0 <__fixunssfsi>
     bde:	f6 2e       	mov	r15, r22
  parameter = (parameter*10) - (float)(e_1 * 10);
     be0:	20 e0       	ldi	r18, 0x00	; 0
     be2:	30 e0       	ldi	r19, 0x00	; 0
     be4:	40 e2       	ldi	r20, 0x20	; 32
     be6:	51 e4       	ldi	r21, 0x41	; 65
     be8:	c5 01       	movw	r24, r10
     bea:	b4 01       	movw	r22, r8
     bec:	0e 94 4a 19 	call	0x3294	; 0x3294 <__mulsf3>
     bf0:	4b 01       	movw	r8, r22
     bf2:	5c 01       	movw	r10, r24
     bf4:	8f 2d       	mov	r24, r15
     bf6:	0f 2c       	mov	r0, r15
     bf8:	00 0c       	add	r0, r0
     bfa:	99 0b       	sbc	r25, r25
     bfc:	bc 01       	movw	r22, r24
     bfe:	66 0f       	add	r22, r22
     c00:	77 1f       	adc	r23, r23
     c02:	88 0f       	add	r24, r24
     c04:	99 1f       	adc	r25, r25
     c06:	88 0f       	add	r24, r24
     c08:	99 1f       	adc	r25, r25
     c0a:	88 0f       	add	r24, r24
     c0c:	99 1f       	adc	r25, r25
     c0e:	68 0f       	add	r22, r24
     c10:	79 1f       	adc	r23, r25
     c12:	07 2e       	mov	r0, r23
     c14:	00 0c       	add	r0, r0
     c16:	88 0b       	sbc	r24, r24
     c18:	99 0b       	sbc	r25, r25
     c1a:	0e 94 96 18 	call	0x312c	; 0x312c <__floatsisf>
     c1e:	9b 01       	movw	r18, r22
     c20:	ac 01       	movw	r20, r24
     c22:	c5 01       	movw	r24, r10
     c24:	b4 01       	movw	r22, r8
     c26:	0e 94 92 17 	call	0x2f24	; 0x2f24 <__subsf3>
     c2a:	4b 01       	movw	r8, r22
     c2c:	5c 01       	movw	r10, r24
  e_2 = (unsigned char) parameter;
     c2e:	0e 94 68 18 	call	0x30d0	; 0x30d0 <__fixunssfsi>
     c32:	16 2f       	mov	r17, r22
  parameter = (parameter*10) - (float)(e_2 * 10);
     c34:	20 e0       	ldi	r18, 0x00	; 0
     c36:	30 e0       	ldi	r19, 0x00	; 0
     c38:	40 e2       	ldi	r20, 0x20	; 32
     c3a:	51 e4       	ldi	r21, 0x41	; 65
     c3c:	c5 01       	movw	r24, r10
     c3e:	b4 01       	movw	r22, r8
     c40:	0e 94 4a 19 	call	0x3294	; 0x3294 <__mulsf3>
     c44:	4b 01       	movw	r8, r22
     c46:	5c 01       	movw	r10, r24
  e_3 = (unsigned char) parameter;
     c48:	21 2f       	mov	r18, r17
     c4a:	01 2e       	mov	r0, r17
     c4c:	00 0c       	add	r0, r0
     c4e:	33 0b       	sbc	r19, r19
     c50:	b9 01       	movw	r22, r18
     c52:	66 0f       	add	r22, r22
     c54:	77 1f       	adc	r23, r23
     c56:	22 0f       	add	r18, r18
     c58:	33 1f       	adc	r19, r19
     c5a:	22 0f       	add	r18, r18
     c5c:	33 1f       	adc	r19, r19
     c5e:	22 0f       	add	r18, r18
     c60:	33 1f       	adc	r19, r19
     c62:	62 0f       	add	r22, r18
     c64:	73 1f       	adc	r23, r19
     c66:	07 2e       	mov	r0, r23
     c68:	00 0c       	add	r0, r0
     c6a:	88 0b       	sbc	r24, r24
     c6c:	99 0b       	sbc	r25, r25
     c6e:	0e 94 96 18 	call	0x312c	; 0x312c <__floatsisf>
     c72:	9b 01       	movw	r18, r22
     c74:	ac 01       	movw	r20, r24
     c76:	c5 01       	movw	r24, r10
     c78:	b4 01       	movw	r22, r8
     c7a:	0e 94 92 17 	call	0x2f24	; 0x2f24 <__subsf3>
     c7e:	0e 94 68 18 	call	0x30d0	; 0x30d0 <__fixunssfsi>
     c82:	96 2e       	mov	r9, r22
		case DOWN:
		  switch (Cursor_X)
		  { case 14:  if (sign == '+')  sign = '-';  else  sign = '+';
			  SRAM_LCD_Text[Cursor_Y*20 + Cursor_X] = sign;  break;
			case 15:  e0--;  if (e0 < 0) e0 = 9;  SRAM_LCD_Text[Cursor_Y*20 + Cursor_X] = '0' + e0;  break;
			case 17:  e_1--;  if (e_1 < 0) e_1 = 9;  SRAM_LCD_Text[Cursor_Y*20 + Cursor_X] = '0' + e_1;  break;
     c84:	0f 2e       	mov	r0, r31
     c86:	f4 e1       	ldi	r31, 0x14	; 20
     c88:	8f 2e       	mov	r8, r31
     c8a:	f0 2d       	mov	r31, r0
		  }  break;  // case RIGHT
		case LEFT:
		  switch (Cursor_X)
		  { case 19:  Cursor_X = 18;  break;
			case 18:  Cursor_X = 17;  break;
			case 17:  Cursor_X = 15;  break;
     c8c:	0f 2e       	mov	r0, r31
     c8e:	ff e0       	ldi	r31, 0x0F	; 15
     c90:	7f 2e       	mov	r7, r31
     c92:	f0 2d       	mov	r31, r0
			case 18:  Cursor_X = 19;  break;
		  }  break;  // case RIGHT
		case LEFT:
		  switch (Cursor_X)
		  { case 19:  Cursor_X = 18;  break;
			case 18:  Cursor_X = 17;  break;
     c94:	0f 2e       	mov	r0, r31
     c96:	f1 e1       	ldi	r31, 0x11	; 17
     c98:	cf 2e       	mov	r12, r31
     c9a:	f0 2d       	mov	r31, r0
			case 17:  Cursor_X = 18;  break;
			case 18:  Cursor_X = 19;  break;
		  }  break;  // case RIGHT
		case LEFT:
		  switch (Cursor_X)
		  { case 19:  Cursor_X = 18;  break;
     c9c:	0f 2e       	mov	r0, r31
     c9e:	f2 e1       	ldi	r31, 0x12	; 18
     ca0:	df 2e       	mov	r13, r31
     ca2:	f0 2d       	mov	r31, r0
			case 18:  Cursor_X = 17;  break;
			case 17:  Cursor_X = 15;  break;
			case 15:  Cursor_X = 14;  break;
     ca4:	0f 2e       	mov	r0, r31
     ca6:	fe e0       	ldi	r31, 0x0E	; 14
     ca8:	5f 2e       	mov	r5, r31
     caa:	f0 2d       	mov	r31, r0
	  { case RIGHT:
		  switch (Cursor_X)
		  { case 14:  Cursor_X = 15;  break;
			case 15:  Cursor_X = 17;  break;
			case 17:  Cursor_X = 18;  break;
			case 18:  Cursor_X = 19;  break;
     cac:	0f 2e       	mov	r0, r31
     cae:	f3 e1       	ldi	r31, 0x13	; 19
     cb0:	6f 2e       	mov	r6, r31
     cb2:	f0 2d       	mov	r31, r0
		case UP:
		  switch (Cursor_X)
		  { case 14:  if (sign == '+')  sign = '-';  else  sign = '+';
			  SRAM_LCD_Text[Cursor_Y*20 + Cursor_X] = sign;  break;
			case 15:  e0 = (e0 + 1) % 10;   SRAM_LCD_Text[Cursor_Y*20 + Cursor_X] = '0' + e0;  break;
			case 17:  e_1 = (e_1 + 1) % 10;  SRAM_LCD_Text[Cursor_Y*20 + Cursor_X] = '0' + e_1;  break;
     cb4:	0f 2e       	mov	r0, r31
     cb6:	fa e0       	ldi	r31, 0x0A	; 10
     cb8:	af 2e       	mov	r10, r31
     cba:	b1 2c       	mov	r11, r1
     cbc:	f0 2d       	mov	r31, r0
  parameter = (parameter*10) - (float)(e_1 * 10);
  e_2 = (unsigned char) parameter;
  parameter = (parameter*10) - (float)(e_2 * 10);
  e_3 = (unsigned char) parameter;
  // Change char values
  while (para != ENTER)
     cbe:	1c c1       	rjmp	.+568    	; 0xef8 <change_para+0x3d2>
  {	  xQueueReceive (QueueTaster, &para, portMAX_DELAY);
     cc0:	20 e0       	ldi	r18, 0x00	; 0
     cc2:	4f ef       	ldi	r20, 0xFF	; 255
     cc4:	5f ef       	ldi	r21, 0xFF	; 255
     cc6:	be 01       	movw	r22, r28
     cc8:	6f 5f       	subi	r22, 0xFF	; 255
     cca:	7f 4f       	sbci	r23, 0xFF	; 255
     ccc:	80 91 9f 0a 	lds	r24, 0x0A9F	; 0x800a9f <QueueTaster>
     cd0:	90 91 a0 0a 	lds	r25, 0x0AA0	; 0x800aa0 <QueueTaster+0x1>
     cd4:	0e 94 9d 10 	call	0x213a	; 0x213a <xQueueGenericReceive>
	  switch (para)
     cd8:	99 81       	ldd	r25, Y+1	; 0x01
     cda:	92 30       	cpi	r25, 0x02	; 2
     cdc:	09 f4       	brne	.+2      	; 0xce0 <change_para+0x1ba>
     cde:	a8 c0       	rjmp	.+336    	; 0xe30 <change_para+0x30a>
     ce0:	1c f4       	brge	.+6      	; 0xce8 <change_para+0x1c2>
     ce2:	91 30       	cpi	r25, 0x01	; 1
     ce4:	c1 f1       	breq	.+112    	; 0xd56 <change_para+0x230>
     ce6:	08 c1       	rjmp	.+528    	; 0xef8 <change_para+0x3d2>
     ce8:	93 30       	cpi	r25, 0x03	; 3
     cea:	e1 f0       	breq	.+56     	; 0xd24 <change_para+0x1fe>
     cec:	94 30       	cpi	r25, 0x04	; 4
     cee:	09 f0       	breq	.+2      	; 0xcf2 <change_para+0x1cc>
     cf0:	03 c1       	rjmp	.+518    	; 0xef8 <change_para+0x3d2>
	  { case RIGHT:
		  switch (Cursor_X)
     cf2:	80 91 9a 0a 	lds	r24, 0x0A9A	; 0x800a9a <Cursor_X>
     cf6:	8f 30       	cpi	r24, 0x0F	; 15
     cf8:	61 f0       	breq	.+24     	; 0xd12 <change_para+0x1ec>
     cfa:	18 f4       	brcc	.+6      	; 0xd02 <change_para+0x1dc>
     cfc:	8e 30       	cpi	r24, 0x0E	; 14
     cfe:	31 f0       	breq	.+12     	; 0xd0c <change_para+0x1e6>
     d00:	fb c0       	rjmp	.+502    	; 0xef8 <change_para+0x3d2>
     d02:	81 31       	cpi	r24, 0x11	; 17
     d04:	49 f0       	breq	.+18     	; 0xd18 <change_para+0x1f2>
     d06:	82 31       	cpi	r24, 0x12	; 18
     d08:	51 f0       	breq	.+20     	; 0xd1e <change_para+0x1f8>
     d0a:	f6 c0       	rjmp	.+492    	; 0xef8 <change_para+0x3d2>
		  { case 14:  Cursor_X = 15;  break;
     d0c:	70 92 9a 0a 	sts	0x0A9A, r7	; 0x800a9a <Cursor_X>
     d10:	f3 c0       	rjmp	.+486    	; 0xef8 <change_para+0x3d2>
			case 15:  Cursor_X = 17;  break;
     d12:	c0 92 9a 0a 	sts	0x0A9A, r12	; 0x800a9a <Cursor_X>
     d16:	f0 c0       	rjmp	.+480    	; 0xef8 <change_para+0x3d2>
			case 17:  Cursor_X = 18;  break;
     d18:	d0 92 9a 0a 	sts	0x0A9A, r13	; 0x800a9a <Cursor_X>
     d1c:	ed c0       	rjmp	.+474    	; 0xef8 <change_para+0x3d2>
			case 18:  Cursor_X = 19;  break;
     d1e:	60 92 9a 0a 	sts	0x0A9A, r6	; 0x800a9a <Cursor_X>
     d22:	ea c0       	rjmp	.+468    	; 0xef8 <change_para+0x3d2>
		  }  break;  // case RIGHT
		case LEFT:
		  switch (Cursor_X)
     d24:	80 91 9a 0a 	lds	r24, 0x0A9A	; 0x800a9a <Cursor_X>
     d28:	81 31       	cpi	r24, 0x11	; 17
     d2a:	79 f0       	breq	.+30     	; 0xd4a <change_para+0x224>
     d2c:	18 f4       	brcc	.+6      	; 0xd34 <change_para+0x20e>
     d2e:	8f 30       	cpi	r24, 0x0F	; 15
     d30:	79 f0       	breq	.+30     	; 0xd50 <change_para+0x22a>
     d32:	e2 c0       	rjmp	.+452    	; 0xef8 <change_para+0x3d2>
     d34:	82 31       	cpi	r24, 0x12	; 18
     d36:	31 f0       	breq	.+12     	; 0xd44 <change_para+0x21e>
     d38:	83 31       	cpi	r24, 0x13	; 19
     d3a:	09 f0       	breq	.+2      	; 0xd3e <change_para+0x218>
     d3c:	dd c0       	rjmp	.+442    	; 0xef8 <change_para+0x3d2>
		  { case 19:  Cursor_X = 18;  break;
     d3e:	d0 92 9a 0a 	sts	0x0A9A, r13	; 0x800a9a <Cursor_X>
     d42:	da c0       	rjmp	.+436    	; 0xef8 <change_para+0x3d2>
			case 18:  Cursor_X = 17;  break;
     d44:	c0 92 9a 0a 	sts	0x0A9A, r12	; 0x800a9a <Cursor_X>
     d48:	d7 c0       	rjmp	.+430    	; 0xef8 <change_para+0x3d2>
			case 17:  Cursor_X = 15;  break;
     d4a:	70 92 9a 0a 	sts	0x0A9A, r7	; 0x800a9a <Cursor_X>
     d4e:	d4 c0       	rjmp	.+424    	; 0xef8 <change_para+0x3d2>
			case 15:  Cursor_X = 14;  break;
     d50:	50 92 9a 0a 	sts	0x0A9A, r5	; 0x800a9a <Cursor_X>
     d54:	d1 c0       	rjmp	.+418    	; 0xef8 <change_para+0x3d2>
		  }  break;  // case LEFT
		case UP:
		  switch (Cursor_X)
     d56:	80 91 9a 0a 	lds	r24, 0x0A9A	; 0x800a9a <Cursor_X>
     d5a:	81 31       	cpi	r24, 0x11	; 17
     d5c:	99 f1       	breq	.+102    	; 0xdc4 <change_para+0x29e>
     d5e:	28 f4       	brcc	.+10     	; 0xd6a <change_para+0x244>
     d60:	8e 30       	cpi	r24, 0x0E	; 14
     d62:	49 f0       	breq	.+18     	; 0xd76 <change_para+0x250>
     d64:	8f 30       	cpi	r24, 0x0F	; 15
     d66:	e1 f0       	breq	.+56     	; 0xda0 <change_para+0x27a>
     d68:	c7 c0       	rjmp	.+398    	; 0xef8 <change_para+0x3d2>
     d6a:	82 31       	cpi	r24, 0x12	; 18
     d6c:	e9 f1       	breq	.+122    	; 0xde8 <change_para+0x2c2>
     d6e:	83 31       	cpi	r24, 0x13	; 19
     d70:	09 f4       	brne	.+2      	; 0xd74 <change_para+0x24e>
     d72:	4c c0       	rjmp	.+152    	; 0xe0c <change_para+0x2e6>
     d74:	c1 c0       	rjmp	.+386    	; 0xef8 <change_para+0x3d2>
		  { case 14:  if (sign == '+')  sign = '-';  else  sign = '+';
     d76:	2b e2       	ldi	r18, 0x2B	; 43
     d78:	e2 16       	cp	r14, r18
     d7a:	29 f0       	breq	.+10     	; 0xd86 <change_para+0x260>
     d7c:	0f 2e       	mov	r0, r31
     d7e:	fb e2       	ldi	r31, 0x2B	; 43
     d80:	ef 2e       	mov	r14, r31
     d82:	f0 2d       	mov	r31, r0
     d84:	04 c0       	rjmp	.+8      	; 0xd8e <change_para+0x268>
     d86:	0f 2e       	mov	r0, r31
     d88:	fd e2       	ldi	r31, 0x2D	; 45
     d8a:	ef 2e       	mov	r14, r31
     d8c:	f0 2d       	mov	r31, r0
			  SRAM_LCD_Text[Cursor_Y*20 + Cursor_X] = sign;  break;
     d8e:	e0 91 33 0a 	lds	r30, 0x0A33	; 0x800a33 <Cursor_Y>
     d92:	8e 9e       	mul	r8, r30
     d94:	f0 01       	movw	r30, r0
     d96:	11 24       	eor	r1, r1
     d98:	e8 5c       	subi	r30, 0xC8	; 200
     d9a:	f5 4f       	sbci	r31, 0xF5	; 245
     d9c:	e6 86       	std	Z+14, r14	; 0x0e
     d9e:	ac c0       	rjmp	.+344    	; 0xef8 <change_para+0x3d2>
			case 15:  e0 = (e0 + 1) % 10;   SRAM_LCD_Text[Cursor_Y*20 + Cursor_X] = '0' + e0;  break;
     da0:	80 2f       	mov	r24, r16
     da2:	00 0f       	add	r16, r16
     da4:	99 0b       	sbc	r25, r25
     da6:	01 96       	adiw	r24, 0x01	; 1
     da8:	b5 01       	movw	r22, r10
     daa:	0e 94 ad 19 	call	0x335a	; 0x335a <__divmodhi4>
     dae:	08 2f       	mov	r16, r24
     db0:	e0 91 33 0a 	lds	r30, 0x0A33	; 0x800a33 <Cursor_Y>
     db4:	8e 9e       	mul	r8, r30
     db6:	f0 01       	movw	r30, r0
     db8:	11 24       	eor	r1, r1
     dba:	e8 5c       	subi	r30, 0xC8	; 200
     dbc:	f5 4f       	sbci	r31, 0xF5	; 245
     dbe:	80 5d       	subi	r24, 0xD0	; 208
     dc0:	87 87       	std	Z+15, r24	; 0x0f
     dc2:	9a c0       	rjmp	.+308    	; 0xef8 <change_para+0x3d2>
			case 17:  e_1 = (e_1 + 1) % 10;  SRAM_LCD_Text[Cursor_Y*20 + Cursor_X] = '0' + e_1;  break;
     dc4:	8f 2d       	mov	r24, r15
     dc6:	ff 0c       	add	r15, r15
     dc8:	99 0b       	sbc	r25, r25
     dca:	01 96       	adiw	r24, 0x01	; 1
     dcc:	b5 01       	movw	r22, r10
     dce:	0e 94 ad 19 	call	0x335a	; 0x335a <__divmodhi4>
     dd2:	f8 2e       	mov	r15, r24
     dd4:	e0 91 33 0a 	lds	r30, 0x0A33	; 0x800a33 <Cursor_Y>
     dd8:	8e 9e       	mul	r8, r30
     dda:	f0 01       	movw	r30, r0
     ddc:	11 24       	eor	r1, r1
     dde:	e8 5c       	subi	r30, 0xC8	; 200
     de0:	f5 4f       	sbci	r31, 0xF5	; 245
     de2:	80 5d       	subi	r24, 0xD0	; 208
     de4:	81 8b       	std	Z+17, r24	; 0x11
     de6:	88 c0       	rjmp	.+272    	; 0xef8 <change_para+0x3d2>
			case 18:  e_2 = (e_2 + 1) % 10;  SRAM_LCD_Text[Cursor_Y*20 + Cursor_X] = '0' + e_2;  break;
     de8:	81 2f       	mov	r24, r17
     dea:	11 0f       	add	r17, r17
     dec:	99 0b       	sbc	r25, r25
     dee:	01 96       	adiw	r24, 0x01	; 1
     df0:	b5 01       	movw	r22, r10
     df2:	0e 94 ad 19 	call	0x335a	; 0x335a <__divmodhi4>
     df6:	18 2f       	mov	r17, r24
     df8:	e0 91 33 0a 	lds	r30, 0x0A33	; 0x800a33 <Cursor_Y>
     dfc:	8e 9e       	mul	r8, r30
     dfe:	f0 01       	movw	r30, r0
     e00:	11 24       	eor	r1, r1
     e02:	e8 5c       	subi	r30, 0xC8	; 200
     e04:	f5 4f       	sbci	r31, 0xF5	; 245
     e06:	80 5d       	subi	r24, 0xD0	; 208
     e08:	82 8b       	std	Z+18, r24	; 0x12
     e0a:	76 c0       	rjmp	.+236    	; 0xef8 <change_para+0x3d2>
			case 19:  e_3 = (e_3 + 1) % 10;  SRAM_LCD_Text[Cursor_Y*20 + Cursor_X] = '0' + e_3;  break;
     e0c:	89 2d       	mov	r24, r9
     e0e:	99 0c       	add	r9, r9
     e10:	99 0b       	sbc	r25, r25
     e12:	01 96       	adiw	r24, 0x01	; 1
     e14:	b5 01       	movw	r22, r10
     e16:	0e 94 ad 19 	call	0x335a	; 0x335a <__divmodhi4>
     e1a:	98 2e       	mov	r9, r24
     e1c:	e0 91 33 0a 	lds	r30, 0x0A33	; 0x800a33 <Cursor_Y>
     e20:	8e 9e       	mul	r8, r30
     e22:	f0 01       	movw	r30, r0
     e24:	11 24       	eor	r1, r1
     e26:	e8 5c       	subi	r30, 0xC8	; 200
     e28:	f5 4f       	sbci	r31, 0xF5	; 245
     e2a:	80 5d       	subi	r24, 0xD0	; 208
     e2c:	83 8b       	std	Z+19, r24	; 0x13
     e2e:	64 c0       	rjmp	.+200    	; 0xef8 <change_para+0x3d2>
		  }  break;  // case UP
		case DOWN:
		  switch (Cursor_X)
     e30:	90 91 9a 0a 	lds	r25, 0x0A9A	; 0x800a9a <Cursor_X>
     e34:	91 31       	cpi	r25, 0x11	; 17
     e36:	79 f1       	breq	.+94     	; 0xe96 <change_para+0x370>
     e38:	28 f4       	brcc	.+10     	; 0xe44 <change_para+0x31e>
     e3a:	9e 30       	cpi	r25, 0x0E	; 14
     e3c:	49 f0       	breq	.+18     	; 0xe50 <change_para+0x32a>
     e3e:	9f 30       	cpi	r25, 0x0F	; 15
     e40:	e1 f0       	breq	.+56     	; 0xe7a <change_para+0x354>
     e42:	5a c0       	rjmp	.+180    	; 0xef8 <change_para+0x3d2>
     e44:	92 31       	cpi	r25, 0x12	; 18
     e46:	c9 f1       	breq	.+114    	; 0xeba <change_para+0x394>
     e48:	93 31       	cpi	r25, 0x13	; 19
     e4a:	09 f4       	brne	.+2      	; 0xe4e <change_para+0x328>
     e4c:	44 c0       	rjmp	.+136    	; 0xed6 <change_para+0x3b0>
     e4e:	54 c0       	rjmp	.+168    	; 0xef8 <change_para+0x3d2>
		  { case 14:  if (sign == '+')  sign = '-';  else  sign = '+';
     e50:	8b e2       	ldi	r24, 0x2B	; 43
     e52:	e8 16       	cp	r14, r24
     e54:	29 f0       	breq	.+10     	; 0xe60 <change_para+0x33a>
     e56:	0f 2e       	mov	r0, r31
     e58:	fb e2       	ldi	r31, 0x2B	; 43
     e5a:	ef 2e       	mov	r14, r31
     e5c:	f0 2d       	mov	r31, r0
     e5e:	04 c0       	rjmp	.+8      	; 0xe68 <change_para+0x342>
     e60:	0f 2e       	mov	r0, r31
     e62:	fd e2       	ldi	r31, 0x2D	; 45
     e64:	ef 2e       	mov	r14, r31
     e66:	f0 2d       	mov	r31, r0
			  SRAM_LCD_Text[Cursor_Y*20 + Cursor_X] = sign;  break;
     e68:	e0 91 33 0a 	lds	r30, 0x0A33	; 0x800a33 <Cursor_Y>
     e6c:	8e 9e       	mul	r8, r30
     e6e:	f0 01       	movw	r30, r0
     e70:	11 24       	eor	r1, r1
     e72:	e8 5c       	subi	r30, 0xC8	; 200
     e74:	f5 4f       	sbci	r31, 0xF5	; 245
     e76:	e6 86       	std	Z+14, r14	; 0x0e
     e78:	3f c0       	rjmp	.+126    	; 0xef8 <change_para+0x3d2>
			case 15:  e0--;  if (e0 < 0) e0 = 9;  SRAM_LCD_Text[Cursor_Y*20 + Cursor_X] = '0' + e0;  break;
     e7a:	01 50       	subi	r16, 0x01	; 1
     e7c:	0a f4       	brpl	.+2      	; 0xe80 <change_para+0x35a>
     e7e:	09 e0       	ldi	r16, 0x09	; 9
     e80:	e0 91 33 0a 	lds	r30, 0x0A33	; 0x800a33 <Cursor_Y>
     e84:	8e 9e       	mul	r8, r30
     e86:	f0 01       	movw	r30, r0
     e88:	11 24       	eor	r1, r1
     e8a:	e8 5c       	subi	r30, 0xC8	; 200
     e8c:	f5 4f       	sbci	r31, 0xF5	; 245
     e8e:	80 e3       	ldi	r24, 0x30	; 48
     e90:	80 0f       	add	r24, r16
     e92:	87 87       	std	Z+15, r24	; 0x0f
     e94:	31 c0       	rjmp	.+98     	; 0xef8 <change_para+0x3d2>
			case 17:  e_1--;  if (e_1 < 0) e_1 = 9;  SRAM_LCD_Text[Cursor_Y*20 + Cursor_X] = '0' + e_1;  break;
     e96:	fa 94       	dec	r15
     e98:	ff 20       	and	r15, r15
     e9a:	24 f4       	brge	.+8      	; 0xea4 <change_para+0x37e>
     e9c:	0f 2e       	mov	r0, r31
     e9e:	f9 e0       	ldi	r31, 0x09	; 9
     ea0:	ff 2e       	mov	r15, r31
     ea2:	f0 2d       	mov	r31, r0
     ea4:	e0 91 33 0a 	lds	r30, 0x0A33	; 0x800a33 <Cursor_Y>
     ea8:	8e 9e       	mul	r8, r30
     eaa:	f0 01       	movw	r30, r0
     eac:	11 24       	eor	r1, r1
     eae:	e8 5c       	subi	r30, 0xC8	; 200
     eb0:	f5 4f       	sbci	r31, 0xF5	; 245
     eb2:	80 e3       	ldi	r24, 0x30	; 48
     eb4:	8f 0d       	add	r24, r15
     eb6:	81 8b       	std	Z+17, r24	; 0x11
     eb8:	1f c0       	rjmp	.+62     	; 0xef8 <change_para+0x3d2>
			case 18:  e_2--;  if (e_2 < 0) e_2 = 9;  SRAM_LCD_Text[Cursor_Y*20 + Cursor_X] = '0' + e_2;  break;
     eba:	11 50       	subi	r17, 0x01	; 1
     ebc:	0a f4       	brpl	.+2      	; 0xec0 <change_para+0x39a>
     ebe:	19 e0       	ldi	r17, 0x09	; 9
     ec0:	e0 91 33 0a 	lds	r30, 0x0A33	; 0x800a33 <Cursor_Y>
     ec4:	8e 9e       	mul	r8, r30
     ec6:	f0 01       	movw	r30, r0
     ec8:	11 24       	eor	r1, r1
     eca:	e8 5c       	subi	r30, 0xC8	; 200
     ecc:	f5 4f       	sbci	r31, 0xF5	; 245
     ece:	80 e3       	ldi	r24, 0x30	; 48
     ed0:	81 0f       	add	r24, r17
     ed2:	82 8b       	std	Z+18, r24	; 0x12
     ed4:	11 c0       	rjmp	.+34     	; 0xef8 <change_para+0x3d2>
			case 19:  e_3--;  if (e_3 < 0) e_3 = 9;  SRAM_LCD_Text[Cursor_Y*20 + Cursor_X] = '0' + e_3;  break;
     ed6:	9a 94       	dec	r9
     ed8:	99 20       	and	r9, r9
     eda:	24 f4       	brge	.+8      	; 0xee4 <change_para+0x3be>
     edc:	0f 2e       	mov	r0, r31
     ede:	f9 e0       	ldi	r31, 0x09	; 9
     ee0:	9f 2e       	mov	r9, r31
     ee2:	f0 2d       	mov	r31, r0
     ee4:	e0 91 33 0a 	lds	r30, 0x0A33	; 0x800a33 <Cursor_Y>
     ee8:	8e 9e       	mul	r8, r30
     eea:	f0 01       	movw	r30, r0
     eec:	11 24       	eor	r1, r1
     eee:	e8 5c       	subi	r30, 0xC8	; 200
     ef0:	f5 4f       	sbci	r31, 0xF5	; 245
     ef2:	80 e3       	ldi	r24, 0x30	; 48
     ef4:	89 0d       	add	r24, r9
     ef6:	83 8b       	std	Z+19, r24	; 0x13
  parameter = (parameter*10) - (float)(e_1 * 10);
  e_2 = (unsigned char) parameter;
  parameter = (parameter*10) - (float)(e_2 * 10);
  e_3 = (unsigned char) parameter;
  // Change char values
  while (para != ENTER)
     ef8:	99 81       	ldd	r25, Y+1	; 0x01
     efa:	95 30       	cpi	r25, 0x05	; 5
     efc:	09 f0       	breq	.+2      	; 0xf00 <change_para+0x3da>
     efe:	e0 ce       	rjmp	.-576    	; 0xcc0 <change_para+0x19a>
			case 18:  e_2--;  if (e_2 < 0) e_2 = 9;  SRAM_LCD_Text[Cursor_Y*20 + Cursor_X] = '0' + e_2;  break;
			case 19:  e_3--;  if (e_3 < 0) e_3 = 9;  SRAM_LCD_Text[Cursor_Y*20 + Cursor_X] = '0' + e_3;  break;
		  }  break;  // case UP
	  }  // end switch (para)	  
  }  // end while (para != ENTER)
  Cursor_X = 0;
     f00:	10 92 9a 0a 	sts	0x0A9A, r1	; 0x800a9a <Cursor_X>
  // Convert chars to parameter
  parameter = (float)e0 + 0.1*(float)e_1 + 0.01*(float)e_2 + 0.001*(float)e_3;
     f04:	6f 2d       	mov	r22, r15
     f06:	ff 0c       	add	r15, r15
     f08:	77 0b       	sbc	r23, r23
     f0a:	88 0b       	sbc	r24, r24
     f0c:	99 0b       	sbc	r25, r25
     f0e:	0e 94 96 18 	call	0x312c	; 0x312c <__floatsisf>
     f12:	2d ec       	ldi	r18, 0xCD	; 205
     f14:	3c ec       	ldi	r19, 0xCC	; 204
     f16:	4c ec       	ldi	r20, 0xCC	; 204
     f18:	5d e3       	ldi	r21, 0x3D	; 61
     f1a:	0e 94 4a 19 	call	0x3294	; 0x3294 <__mulsf3>
     f1e:	2b 01       	movw	r4, r22
     f20:	3c 01       	movw	r6, r24
     f22:	60 2f       	mov	r22, r16
     f24:	00 0f       	add	r16, r16
     f26:	77 0b       	sbc	r23, r23
     f28:	88 0b       	sbc	r24, r24
     f2a:	99 0b       	sbc	r25, r25
     f2c:	0e 94 96 18 	call	0x312c	; 0x312c <__floatsisf>
     f30:	9b 01       	movw	r18, r22
     f32:	ac 01       	movw	r20, r24
     f34:	c3 01       	movw	r24, r6
     f36:	b2 01       	movw	r22, r4
     f38:	0e 94 93 17 	call	0x2f26	; 0x2f26 <__addsf3>
     f3c:	2b 01       	movw	r4, r22
     f3e:	3c 01       	movw	r6, r24
     f40:	61 2f       	mov	r22, r17
     f42:	11 0f       	add	r17, r17
     f44:	77 0b       	sbc	r23, r23
     f46:	88 0b       	sbc	r24, r24
     f48:	99 0b       	sbc	r25, r25
     f4a:	0e 94 96 18 	call	0x312c	; 0x312c <__floatsisf>
     f4e:	2a e0       	ldi	r18, 0x0A	; 10
     f50:	37 ed       	ldi	r19, 0xD7	; 215
     f52:	43 e2       	ldi	r20, 0x23	; 35
     f54:	5c e3       	ldi	r21, 0x3C	; 60
     f56:	0e 94 4a 19 	call	0x3294	; 0x3294 <__mulsf3>
     f5a:	9b 01       	movw	r18, r22
     f5c:	ac 01       	movw	r20, r24
     f5e:	c3 01       	movw	r24, r6
     f60:	b2 01       	movw	r22, r4
     f62:	0e 94 93 17 	call	0x2f26	; 0x2f26 <__addsf3>
     f66:	2b 01       	movw	r4, r22
     f68:	3c 01       	movw	r6, r24
     f6a:	69 2d       	mov	r22, r9
     f6c:	99 0c       	add	r9, r9
     f6e:	77 0b       	sbc	r23, r23
     f70:	88 0b       	sbc	r24, r24
     f72:	99 0b       	sbc	r25, r25
     f74:	0e 94 96 18 	call	0x312c	; 0x312c <__floatsisf>
     f78:	2f e6       	ldi	r18, 0x6F	; 111
     f7a:	32 e1       	ldi	r19, 0x12	; 18
     f7c:	43 e8       	ldi	r20, 0x83	; 131
     f7e:	5a e3       	ldi	r21, 0x3A	; 58
     f80:	0e 94 4a 19 	call	0x3294	; 0x3294 <__mulsf3>
     f84:	9b 01       	movw	r18, r22
     f86:	ac 01       	movw	r20, r24
     f88:	c3 01       	movw	r24, r6
     f8a:	b2 01       	movw	r22, r4
     f8c:	0e 94 93 17 	call	0x2f26	; 0x2f26 <__addsf3>
  if (sign == '-')  parameter = -parameter;
     f90:	2d e2       	ldi	r18, 0x2D	; 45
     f92:	e2 12       	cpse	r14, r18
     f94:	01 c0       	rjmp	.+2      	; 0xf98 <change_para+0x472>
     f96:	90 58       	subi	r25, 0x80	; 128
  return (parameter);
}  // end change_para
     f98:	0f 90       	pop	r0
     f9a:	df 91       	pop	r29
     f9c:	cf 91       	pop	r28
     f9e:	1f 91       	pop	r17
     fa0:	0f 91       	pop	r16
     fa2:	ff 90       	pop	r15
     fa4:	ef 90       	pop	r14
     fa6:	df 90       	pop	r13
     fa8:	cf 90       	pop	r12
     faa:	bf 90       	pop	r11
     fac:	af 90       	pop	r10
     fae:	9f 90       	pop	r9
     fb0:	8f 90       	pop	r8
     fb2:	7f 90       	pop	r7
     fb4:	6f 90       	pop	r6
     fb6:	5f 90       	pop	r5
     fb8:	4f 90       	pop	r4
     fba:	08 95       	ret

00000fbc <show_sensors>:
unsigned char  led_nr = 0;  // Define and init LED group
char zeros = 0;
float pos_part = 0.0, pos;
//
void  show_sensors (void)
{ char  sign, led_bit, ft_bit, e0, e_1, e_2, e_3;
     fbc:	8f 92       	push	r8
     fbe:	9f 92       	push	r9
     fc0:	af 92       	push	r10
     fc2:	bf 92       	push	r11
     fc4:	cf 92       	push	r12
     fc6:	df 92       	push	r13
     fc8:	ef 92       	push	r14
     fca:	ff 92       	push	r15
     fcc:	0f 93       	push	r16
     fce:	1f 93       	push	r17
     fd0:	cf 93       	push	r28
     fd2:	df 93       	push	r29
  unsigned char  i, ft;
  // Show position
	pos = position;
     fd4:	c0 90 8e 0a 	lds	r12, 0x0A8E	; 0x800a8e <position>
     fd8:	d0 90 8f 0a 	lds	r13, 0x0A8F	; 0x800a8f <position+0x1>
     fdc:	e0 90 90 0a 	lds	r14, 0x0A90	; 0x800a90 <position+0x2>
     fe0:	f0 90 91 0a 	lds	r15, 0x0A91	; 0x800a91 <position+0x3>
	if (pos > 0.0)  sign = '+';  
     fe4:	20 e0       	ldi	r18, 0x00	; 0
     fe6:	30 e0       	ldi	r19, 0x00	; 0
     fe8:	a9 01       	movw	r20, r18
     fea:	c7 01       	movw	r24, r14
     fec:	b6 01       	movw	r22, r12
     fee:	0e 94 46 19 	call	0x328c	; 0x328c <__gesf2>
     ff2:	18 16       	cp	r1, r24
     ff4:	54 f4       	brge	.+20     	; 0x100a <show_sensors+0x4e>
//
void  show_sensors (void)
{ char  sign, led_bit, ft_bit, e0, e_1, e_2, e_3;
  unsigned char  i, ft;
  // Show position
	pos = position;
     ff6:	c0 92 b0 0a 	sts	0x0AB0, r12	; 0x800ab0 <pos>
     ffa:	d0 92 b1 0a 	sts	0x0AB1, r13	; 0x800ab1 <pos+0x1>
     ffe:	e0 92 b2 0a 	sts	0x0AB2, r14	; 0x800ab2 <pos+0x2>
    1002:	f0 92 b3 0a 	sts	0x0AB3, r15	; 0x800ab3 <pos+0x3>
	if (pos > 0.0)  sign = '+';  
    1006:	8b e2       	ldi	r24, 0x2B	; 43
    1008:	0d c0       	rjmp	.+26     	; 0x1024 <show_sensors+0x68>
	else  {sign = '-';  pos = -1.0 * pos;}
    100a:	f7 fa       	bst	r15, 7
    100c:	f0 94       	com	r15
    100e:	f7 f8       	bld	r15, 7
    1010:	f0 94       	com	r15
    1012:	c0 92 b0 0a 	sts	0x0AB0, r12	; 0x800ab0 <pos>
    1016:	d0 92 b1 0a 	sts	0x0AB1, r13	; 0x800ab1 <pos+0x1>
    101a:	e0 92 b2 0a 	sts	0x0AB2, r14	; 0x800ab2 <pos+0x2>
    101e:	f0 92 b3 0a 	sts	0x0AB3, r15	; 0x800ab3 <pos+0x3>
    1022:	8d e2       	ldi	r24, 0x2D	; 45
	SRAM_LCD_Text[34] = sign;
    1024:	c8 e3       	ldi	r28, 0x38	; 56
    1026:	da e0       	ldi	r29, 0x0A	; 10
    1028:	8a a3       	std	Y+34, r24	; 0x22
	e0 = (unsigned char) pos;
    102a:	c0 90 b0 0a 	lds	r12, 0x0AB0	; 0x800ab0 <pos>
    102e:	d0 90 b1 0a 	lds	r13, 0x0AB1	; 0x800ab1 <pos+0x1>
    1032:	e0 90 b2 0a 	lds	r14, 0x0AB2	; 0x800ab2 <pos+0x2>
    1036:	f0 90 b3 0a 	lds	r15, 0x0AB3	; 0x800ab3 <pos+0x3>
    103a:	c7 01       	movw	r24, r14
    103c:	b6 01       	movw	r22, r12
    103e:	0e 94 68 18 	call	0x30d0	; 0x30d0 <__fixunssfsi>
    1042:	16 2f       	mov	r17, r22
	SRAM_LCD_Text[35] = e0 + '0';
    1044:	80 e3       	ldi	r24, 0x30	; 48
    1046:	81 0f       	add	r24, r17
    1048:	8b a3       	std	Y+35, r24	; 0x23
	pos = (pos*10) - (float)(e0 * 10);
    104a:	20 e0       	ldi	r18, 0x00	; 0
    104c:	30 e0       	ldi	r19, 0x00	; 0
    104e:	40 e2       	ldi	r20, 0x20	; 32
    1050:	51 e4       	ldi	r21, 0x41	; 65
    1052:	c7 01       	movw	r24, r14
    1054:	b6 01       	movw	r22, r12
    1056:	0e 94 4a 19 	call	0x3294	; 0x3294 <__mulsf3>
    105a:	6b 01       	movw	r12, r22
    105c:	7c 01       	movw	r14, r24
    105e:	81 2f       	mov	r24, r17
    1060:	11 0f       	add	r17, r17
    1062:	99 0b       	sbc	r25, r25
    1064:	bc 01       	movw	r22, r24
    1066:	66 0f       	add	r22, r22
    1068:	77 1f       	adc	r23, r23
    106a:	88 0f       	add	r24, r24
    106c:	99 1f       	adc	r25, r25
    106e:	88 0f       	add	r24, r24
    1070:	99 1f       	adc	r25, r25
    1072:	88 0f       	add	r24, r24
    1074:	99 1f       	adc	r25, r25
    1076:	68 0f       	add	r22, r24
    1078:	79 1f       	adc	r23, r25
    107a:	07 2e       	mov	r0, r23
    107c:	00 0c       	add	r0, r0
    107e:	88 0b       	sbc	r24, r24
    1080:	99 0b       	sbc	r25, r25
    1082:	0e 94 96 18 	call	0x312c	; 0x312c <__floatsisf>
    1086:	9b 01       	movw	r18, r22
    1088:	ac 01       	movw	r20, r24
    108a:	c7 01       	movw	r24, r14
    108c:	b6 01       	movw	r22, r12
    108e:	0e 94 92 17 	call	0x2f24	; 0x2f24 <__subsf3>
    1092:	6b 01       	movw	r12, r22
    1094:	7c 01       	movw	r14, r24
	e_1 = (unsigned char) pos;
    1096:	0e 94 68 18 	call	0x30d0	; 0x30d0 <__fixunssfsi>
    109a:	16 2f       	mov	r17, r22
	SRAM_LCD_Text[37] = e_1 + '0';
    109c:	80 e3       	ldi	r24, 0x30	; 48
    109e:	81 0f       	add	r24, r17
    10a0:	8d a3       	std	Y+37, r24	; 0x25
	pos = (pos*10) - (float)(e_1 * 10);
    10a2:	20 e0       	ldi	r18, 0x00	; 0
    10a4:	30 e0       	ldi	r19, 0x00	; 0
    10a6:	40 e2       	ldi	r20, 0x20	; 32
    10a8:	51 e4       	ldi	r21, 0x41	; 65
    10aa:	c7 01       	movw	r24, r14
    10ac:	b6 01       	movw	r22, r12
    10ae:	0e 94 4a 19 	call	0x3294	; 0x3294 <__mulsf3>
    10b2:	6b 01       	movw	r12, r22
    10b4:	7c 01       	movw	r14, r24
    10b6:	81 2f       	mov	r24, r17
    10b8:	11 0f       	add	r17, r17
    10ba:	99 0b       	sbc	r25, r25
    10bc:	bc 01       	movw	r22, r24
    10be:	66 0f       	add	r22, r22
    10c0:	77 1f       	adc	r23, r23
    10c2:	88 0f       	add	r24, r24
    10c4:	99 1f       	adc	r25, r25
    10c6:	88 0f       	add	r24, r24
    10c8:	99 1f       	adc	r25, r25
    10ca:	88 0f       	add	r24, r24
    10cc:	99 1f       	adc	r25, r25
    10ce:	68 0f       	add	r22, r24
    10d0:	79 1f       	adc	r23, r25
    10d2:	07 2e       	mov	r0, r23
    10d4:	00 0c       	add	r0, r0
    10d6:	88 0b       	sbc	r24, r24
    10d8:	99 0b       	sbc	r25, r25
    10da:	0e 94 96 18 	call	0x312c	; 0x312c <__floatsisf>
    10de:	9b 01       	movw	r18, r22
    10e0:	ac 01       	movw	r20, r24
    10e2:	c7 01       	movw	r24, r14
    10e4:	b6 01       	movw	r22, r12
    10e6:	0e 94 92 17 	call	0x2f24	; 0x2f24 <__subsf3>
    10ea:	6b 01       	movw	r12, r22
    10ec:	7c 01       	movw	r14, r24
	e_2 = (unsigned char) pos;
    10ee:	0e 94 68 18 	call	0x30d0	; 0x30d0 <__fixunssfsi>
    10f2:	16 2f       	mov	r17, r22
	SRAM_LCD_Text[38] = e_2 + '0';
    10f4:	80 e3       	ldi	r24, 0x30	; 48
    10f6:	81 0f       	add	r24, r17
    10f8:	8e a3       	std	Y+38, r24	; 0x26
	pos = (pos*10) - (float)(e_2 * 10);
    10fa:	20 e0       	ldi	r18, 0x00	; 0
    10fc:	30 e0       	ldi	r19, 0x00	; 0
    10fe:	40 e2       	ldi	r20, 0x20	; 32
    1100:	51 e4       	ldi	r21, 0x41	; 65
    1102:	c7 01       	movw	r24, r14
    1104:	b6 01       	movw	r22, r12
    1106:	0e 94 4a 19 	call	0x3294	; 0x3294 <__mulsf3>
    110a:	6b 01       	movw	r12, r22
    110c:	7c 01       	movw	r14, r24
    110e:	81 2f       	mov	r24, r17
    1110:	11 0f       	add	r17, r17
    1112:	99 0b       	sbc	r25, r25
    1114:	bc 01       	movw	r22, r24
    1116:	66 0f       	add	r22, r22
    1118:	77 1f       	adc	r23, r23
    111a:	88 0f       	add	r24, r24
    111c:	99 1f       	adc	r25, r25
    111e:	88 0f       	add	r24, r24
    1120:	99 1f       	adc	r25, r25
    1122:	88 0f       	add	r24, r24
    1124:	99 1f       	adc	r25, r25
    1126:	68 0f       	add	r22, r24
    1128:	79 1f       	adc	r23, r25
    112a:	07 2e       	mov	r0, r23
    112c:	00 0c       	add	r0, r0
    112e:	88 0b       	sbc	r24, r24
    1130:	99 0b       	sbc	r25, r25
    1132:	0e 94 96 18 	call	0x312c	; 0x312c <__floatsisf>
    1136:	9b 01       	movw	r18, r22
    1138:	ac 01       	movw	r20, r24
    113a:	c7 01       	movw	r24, r14
    113c:	b6 01       	movw	r22, r12
    113e:	0e 94 92 17 	call	0x2f24	; 0x2f24 <__subsf3>
    1142:	60 93 b0 0a 	sts	0x0AB0, r22	; 0x800ab0 <pos>
    1146:	70 93 b1 0a 	sts	0x0AB1, r23	; 0x800ab1 <pos+0x1>
    114a:	80 93 b2 0a 	sts	0x0AB2, r24	; 0x800ab2 <pos+0x2>
    114e:	90 93 b3 0a 	sts	0x0AB3, r25	; 0x800ab3 <pos+0x3>
	e_3 = (unsigned char) pos;
	SRAM_LCD_Text[39] = e_3 + '0';
    1152:	0e 94 68 18 	call	0x30d0	; 0x30d0 <__fixunssfsi>
    1156:	60 5d       	subi	r22, 0xD0	; 208
    1158:	6f a3       	std	Y+39, r22	; 0x27
	// Get FT bits
  ft = (PIND >> 4) | (PINA << 4);
    115a:	80 b3       	in	r24, 0x10	; 16
    115c:	99 b3       	in	r25, 0x19	; 25
    115e:	c8 2e       	mov	r12, r24
    1160:	c6 94       	lsr	r12
    1162:	c6 94       	lsr	r12
    1164:	c6 94       	lsr	r12
    1166:	c6 94       	lsr	r12
    1168:	20 e1       	ldi	r18, 0x10	; 16
    116a:	92 9f       	mul	r25, r18
    116c:	c0 01       	movw	r24, r0
    116e:	11 24       	eor	r1, r1
    1170:	8c 29       	or	r24, r12
		SRAM_LCD_Text[48-i] = led_bit; 
		if (ft & (1 << i))  ft_bit = '1';  else  ft_bit = '0';
		SRAM_LCD_Text[59-i] = ft_bit;
		// Get part of position for actual FT values
		if ( ! (ft & (1 << i)))
		{ if (fabs(ref_value [i][led_nr]) > 0.001)  zeros++;
    1172:	00 91 da 09 	lds	r16, 0x09DA	; 0x8009da <led_nr>
    1176:	10 e0       	ldi	r17, 0x00	; 0
    1178:	00 0f       	add	r16, r16
    117a:	11 1f       	adc	r17, r17
    117c:	00 0f       	add	r16, r16
    117e:	11 1f       	adc	r17, r17
    1180:	00 50       	subi	r16, 0x00	; 0
    1182:	1f 4f       	sbci	r17, 0xFF	; 255
    1184:	0f 2e       	mov	r0, r31
    1186:	f9 e6       	ldi	r31, 0x69	; 105
    1188:	ef 2e       	mov	r14, r31
    118a:	fa e0       	ldi	r31, 0x0A	; 10
    118c:	ff 2e       	mov	r15, r31
    118e:	f0 2d       	mov	r31, r0
    1190:	c0 e0       	ldi	r28, 0x00	; 0
    1192:	d0 e0       	ldi	r29, 0x00	; 0
  ft = (PIND >> 4) | (PINA << 4);
	// Show LED bit values and FT bit values at LCD
  for (i = 0; i < 7; i++)
  { if (PORTC & (1 << i))  led_bit = '1';  else  led_bit = '0';
		SRAM_LCD_Text[48-i] = led_bit; 
		if (ft & (1 << i))  ft_bit = '1';  else  ft_bit = '0';
    1194:	c8 2e       	mov	r12, r24
    1196:	d1 2c       	mov	r13, r1
	SRAM_LCD_Text[39] = e_3 + '0';
	// Get FT bits
  ft = (PIND >> 4) | (PINA << 4);
	// Show LED bit values and FT bit values at LCD
  for (i = 0; i < 7; i++)
  { if (PORTC & (1 << i))  led_bit = '1';  else  led_bit = '0';
    1198:	85 b3       	in	r24, 0x15	; 21
    119a:	2c 2f       	mov	r18, r28
    119c:	90 e0       	ldi	r25, 0x00	; 0
    119e:	0c 2e       	mov	r0, r28
    11a0:	02 c0       	rjmp	.+4      	; 0x11a6 <__stack+0xa7>
    11a2:	95 95       	asr	r25
    11a4:	87 95       	ror	r24
    11a6:	0a 94       	dec	r0
    11a8:	e2 f7       	brpl	.-8      	; 0x11a2 <__stack+0xa3>
    11aa:	80 fd       	sbrc	r24, 0
    11ac:	02 c0       	rjmp	.+4      	; 0x11b2 <__stack+0xb3>
    11ae:	80 e3       	ldi	r24, 0x30	; 48
    11b0:	01 c0       	rjmp	.+2      	; 0x11b4 <__stack+0xb5>
    11b2:	81 e3       	ldi	r24, 0x31	; 49
		SRAM_LCD_Text[48-i] = led_bit; 
    11b4:	f7 01       	movw	r30, r14
    11b6:	82 93       	st	-Z, r24
    11b8:	7f 01       	movw	r14, r30
		if (ft & (1 << i))  ft_bit = '1';  else  ft_bit = '0';
    11ba:	c6 01       	movw	r24, r12
    11bc:	02 c0       	rjmp	.+4      	; 0x11c2 <__stack+0xc3>
    11be:	95 95       	asr	r25
    11c0:	87 95       	ror	r24
    11c2:	2a 95       	dec	r18
    11c4:	e2 f7       	brpl	.-8      	; 0x11be <__stack+0xbf>
    11c6:	80 fd       	sbrc	r24, 0
    11c8:	7f c0       	rjmp	.+254    	; 0x12c8 <__stack+0x1c9>
    11ca:	6a c0       	rjmp	.+212    	; 0x12a0 <__stack+0x1a1>
		SRAM_LCD_Text[59-i] = ft_bit;
		// Get part of position for actual FT values
		if ( ! (ft & (1 << i)))
		{ if (fabs(ref_value [i][led_nr]) > 0.001)  zeros++;
    11cc:	80 91 d9 09 	lds	r24, 0x09D9	; 0x8009d9 <zeros>
    11d0:	8f 5f       	subi	r24, 0xFF	; 255
    11d2:	80 93 d9 09 	sts	0x09D9, r24	; 0x8009d9 <zeros>
			pos_part = pos_part + ref_value [i][led_nr];
    11d6:	a5 01       	movw	r20, r10
    11d8:	94 01       	movw	r18, r8
    11da:	60 91 d5 09 	lds	r22, 0x09D5	; 0x8009d5 <pos_part>
    11de:	70 91 d6 09 	lds	r23, 0x09D6	; 0x8009d6 <pos_part+0x1>
    11e2:	80 91 d7 09 	lds	r24, 0x09D7	; 0x8009d7 <pos_part+0x2>
    11e6:	90 91 d8 09 	lds	r25, 0x09D8	; 0x8009d8 <pos_part+0x3>
    11ea:	0e 94 93 17 	call	0x2f26	; 0x2f26 <__addsf3>
    11ee:	60 93 d5 09 	sts	0x09D5, r22	; 0x8009d5 <pos_part>
    11f2:	70 93 d6 09 	sts	0x09D6, r23	; 0x8009d6 <pos_part+0x1>
    11f6:	80 93 d7 09 	sts	0x09D7, r24	; 0x8009d7 <pos_part+0x2>
    11fa:	90 93 d8 09 	sts	0x09D8, r25	; 0x8009d8 <pos_part+0x3>
    11fe:	21 96       	adiw	r28, 0x01	; 1
    1200:	04 5e       	subi	r16, 0xE4	; 228
    1202:	1f 4f       	sbci	r17, 0xFF	; 255
	e_3 = (unsigned char) pos;
	SRAM_LCD_Text[39] = e_3 + '0';
	// Get FT bits
  ft = (PIND >> 4) | (PINA << 4);
	// Show LED bit values and FT bit values at LCD
  for (i = 0; i < 7; i++)
    1204:	c7 30       	cpi	r28, 0x07	; 7
    1206:	d1 05       	cpc	r29, r1
    1208:	39 f6       	brne	.-114    	; 0x1198 <__stack+0x99>
		{ if (fabs(ref_value [i][led_nr]) > 0.001)  zeros++;
			pos_part = pos_part + ref_value [i][led_nr];
		}
  }
  // Wait a second for reading LCD
  PORTC = 0;  // LED off - reason Ptot of BSS123
    120a:	15 ba       	out	0x15, r1	; 21
  vTaskDelay(333);  // 333x 3ms = ca. 1s
    120c:	8d e4       	ldi	r24, 0x4D	; 77
    120e:	91 e0       	ldi	r25, 0x01	; 1
    1210:	0e 94 cb 15 	call	0x2b96	; 0x2b96 <vTaskDelay>
	// Rotate to next LED (0..6)
	led_nr++;
    1214:	80 91 da 09 	lds	r24, 0x09DA	; 0x8009da <led_nr>
    1218:	8f 5f       	subi	r24, 0xFF	; 255
    121a:	80 93 da 09 	sts	0x09DA, r24	; 0x8009da <led_nr>
	if (led_nr > 6)
    121e:	87 30       	cpi	r24, 0x07	; 7
    1220:	a0 f1       	brcs	.+104    	; 0x128a <__stack+0x18b>
	{ if (zeros > 0)  position = pos_part / (float) zeros;
    1222:	60 91 d9 09 	lds	r22, 0x09D9	; 0x8009d9 <zeros>
    1226:	16 16       	cp	r1, r22
    1228:	e4 f4       	brge	.+56     	; 0x1262 <__stack+0x163>
    122a:	06 2e       	mov	r0, r22
    122c:	00 0c       	add	r0, r0
    122e:	77 0b       	sbc	r23, r23
    1230:	88 0b       	sbc	r24, r24
    1232:	99 0b       	sbc	r25, r25
    1234:	0e 94 96 18 	call	0x312c	; 0x312c <__floatsisf>
    1238:	9b 01       	movw	r18, r22
    123a:	ac 01       	movw	r20, r24
    123c:	60 91 d5 09 	lds	r22, 0x09D5	; 0x8009d5 <pos_part>
    1240:	70 91 d6 09 	lds	r23, 0x09D6	; 0x8009d6 <pos_part+0x1>
    1244:	80 91 d7 09 	lds	r24, 0x09D7	; 0x8009d7 <pos_part+0x2>
    1248:	90 91 d8 09 	lds	r25, 0x09D8	; 0x8009d8 <pos_part+0x3>
    124c:	0e 94 fb 17 	call	0x2ff6	; 0x2ff6 <__divsf3>
    1250:	60 93 8e 0a 	sts	0x0A8E, r22	; 0x800a8e <position>
    1254:	70 93 8f 0a 	sts	0x0A8F, r23	; 0x800a8f <position+0x1>
    1258:	80 93 90 0a 	sts	0x0A90, r24	; 0x800a90 <position+0x2>
    125c:	90 93 91 0a 	sts	0x0A91, r25	; 0x800a91 <position+0x3>
    1260:	08 c0       	rjmp	.+16     	; 0x1272 <__stack+0x173>
		else  position = 0.0;
    1262:	10 92 8e 0a 	sts	0x0A8E, r1	; 0x800a8e <position>
    1266:	10 92 8f 0a 	sts	0x0A8F, r1	; 0x800a8f <position+0x1>
    126a:	10 92 90 0a 	sts	0x0A90, r1	; 0x800a90 <position+0x2>
    126e:	10 92 91 0a 	sts	0x0A91, r1	; 0x800a91 <position+0x3>
		led_nr = 0;  zeros = 0;  pos_part = 0.0;
    1272:	10 92 da 09 	sts	0x09DA, r1	; 0x8009da <led_nr>
    1276:	10 92 d9 09 	sts	0x09D9, r1	; 0x8009d9 <zeros>
    127a:	10 92 d5 09 	sts	0x09D5, r1	; 0x8009d5 <pos_part>
    127e:	10 92 d6 09 	sts	0x09D6, r1	; 0x8009d6 <pos_part+0x1>
    1282:	10 92 d7 09 	sts	0x09D7, r1	; 0x8009d7 <pos_part+0x2>
    1286:	10 92 d8 09 	sts	0x09D8, r1	; 0x8009d8 <pos_part+0x3>
	}  // end if
  PORTC = (1 << led_nr);
    128a:	81 e0       	ldi	r24, 0x01	; 1
    128c:	90 e0       	ldi	r25, 0x00	; 0
    128e:	00 90 da 09 	lds	r0, 0x09DA	; 0x8009da <led_nr>
    1292:	02 c0       	rjmp	.+4      	; 0x1298 <__stack+0x199>
    1294:	88 0f       	add	r24, r24
    1296:	99 1f       	adc	r25, r25
    1298:	0a 94       	dec	r0
    129a:	e2 f7       	brpl	.-8      	; 0x1294 <__stack+0x195>
    129c:	85 bb       	out	0x15, r24	; 21
}
    129e:	17 c0       	rjmp	.+46     	; 0x12ce <__stack+0x1cf>
	// Show LED bit values and FT bit values at LCD
  for (i = 0; i < 7; i++)
  { if (PORTC & (1 << i))  led_bit = '1';  else  led_bit = '0';
		SRAM_LCD_Text[48-i] = led_bit; 
		if (ft & (1 << i))  ft_bit = '1';  else  ft_bit = '0';
		SRAM_LCD_Text[59-i] = ft_bit;
    12a0:	80 e3       	ldi	r24, 0x30	; 48
    12a2:	83 87       	std	Z+11, r24	; 0x0b
		// Get part of position for actual FT values
		if ( ! (ft & (1 << i)))
		{ if (fabs(ref_value [i][led_nr]) > 0.001)  zeros++;
    12a4:	f8 01       	movw	r30, r16
    12a6:	80 80       	ld	r8, Z
    12a8:	91 80       	ldd	r9, Z+1	; 0x01
    12aa:	a2 80       	ldd	r10, Z+2	; 0x02
    12ac:	b3 80       	ldd	r11, Z+3	; 0x03
    12ae:	c5 01       	movw	r24, r10
    12b0:	b4 01       	movw	r22, r8
    12b2:	9f 77       	andi	r25, 0x7F	; 127
    12b4:	2f e6       	ldi	r18, 0x6F	; 111
    12b6:	32 e1       	ldi	r19, 0x12	; 18
    12b8:	43 e8       	ldi	r20, 0x83	; 131
    12ba:	5a e3       	ldi	r21, 0x3A	; 58
    12bc:	0e 94 46 19 	call	0x328c	; 0x328c <__gesf2>
    12c0:	18 16       	cp	r1, r24
    12c2:	0c f4       	brge	.+2      	; 0x12c6 <__stack+0x1c7>
    12c4:	83 cf       	rjmp	.-250    	; 0x11cc <__stack+0xcd>
    12c6:	87 cf       	rjmp	.-242    	; 0x11d6 <__stack+0xd7>
	// Show LED bit values and FT bit values at LCD
  for (i = 0; i < 7; i++)
  { if (PORTC & (1 << i))  led_bit = '1';  else  led_bit = '0';
		SRAM_LCD_Text[48-i] = led_bit; 
		if (ft & (1 << i))  ft_bit = '1';  else  ft_bit = '0';
		SRAM_LCD_Text[59-i] = ft_bit;
    12c8:	81 e3       	ldi	r24, 0x31	; 49
    12ca:	83 87       	std	Z+11, r24	; 0x0b
    12cc:	98 cf       	rjmp	.-208    	; 0x11fe <__stack+0xff>
	{ if (zeros > 0)  position = pos_part / (float) zeros;
		else  position = 0.0;
		led_nr = 0;  zeros = 0;  pos_part = 0.0;
	}  // end if
  PORTC = (1 << led_nr);
}
    12ce:	df 91       	pop	r29
    12d0:	cf 91       	pop	r28
    12d2:	1f 91       	pop	r17
    12d4:	0f 91       	pop	r16
    12d6:	ff 90       	pop	r15
    12d8:	ef 90       	pop	r14
    12da:	df 90       	pop	r13
    12dc:	cf 90       	pop	r12
    12de:	bf 90       	pop	r11
    12e0:	af 90       	pop	r10
    12e2:	9f 90       	pop	r9
    12e4:	8f 90       	pop	r8
    12e6:	08 95       	ret

000012e8 <vHMI>:
const char err_Cursor_X [21] PROGMEM =         "Cursor_X out of rang"; 
// Enum for HMI state machine
enum {Main, Para1, Para2, PIDr, SBP};
//------------------------------------------------------------------
void  vHMI ( void * pvParameters)
{ unsigned char  lauf, para = NADA , status = Main;
    12e8:	cf 93       	push	r28
    12ea:	df 93       	push	r29
    12ec:	1f 92       	push	r1
    12ee:	cd b7       	in	r28, 0x3d	; 61
    12f0:	de b7       	in	r29, 0x3e	; 62
    12f2:	19 82       	std	Y+1, r1	; 0x01
  // Stop sensor task
  vTaskSuspend (vSensor_Handle);
    12f4:	80 91 92 0a 	lds	r24, 0x0A92	; 0x800a92 <vSensor_Handle>
    12f8:	90 91 93 0a 	lds	r25, 0x0A93	; 0x800a93 <vSensor_Handle+0x1>
    12fc:	0e 94 12 14 	call	0x2824	; 0x2824 <vTaskSuspend>
  servo_power = 0;
    1300:	10 92 ab 0a 	sts	0x0AAB, r1	; 0x800aab <servo_power>
  // Init cursor position
  Cursor_X = 0;  Cursor_Y = 1;
    1304:	10 92 9a 0a 	sts	0x0A9A, r1	; 0x800a9a <Cursor_X>
    1308:	81 e0       	ldi	r24, 0x01	; 1
    130a:	80 93 33 0a 	sts	0x0A33, r24	; 0x800a33 <Cursor_Y>
  // Init PID parameters
  reference = 0.0;  proportional = 0.2;
    130e:	10 92 88 0a 	sts	0x0A88, r1	; 0x800a88 <reference>
    1312:	10 92 89 0a 	sts	0x0A89, r1	; 0x800a89 <reference+0x1>
    1316:	10 92 8a 0a 	sts	0x0A8A, r1	; 0x800a8a <reference+0x2>
    131a:	10 92 8b 0a 	sts	0x0A8B, r1	; 0x800a8b <reference+0x3>
    131e:	8d ec       	ldi	r24, 0xCD	; 205
    1320:	9c ec       	ldi	r25, 0xCC	; 204
    1322:	ac e4       	ldi	r26, 0x4C	; 76
    1324:	be e3       	ldi	r27, 0x3E	; 62
    1326:	80 93 a1 0a 	sts	0x0AA1, r24	; 0x800aa1 <proportional>
    132a:	90 93 a2 0a 	sts	0x0AA2, r25	; 0x800aa2 <proportional+0x1>
    132e:	a0 93 a3 0a 	sts	0x0AA3, r26	; 0x800aa3 <proportional+0x2>
    1332:	b0 93 a4 0a 	sts	0x0AA4, r27	; 0x800aa4 <proportional+0x3>
  integral = 0.0;  derivative = 0.0;
    1336:	10 92 ac 0a 	sts	0x0AAC, r1	; 0x800aac <integral>
    133a:	10 92 ad 0a 	sts	0x0AAD, r1	; 0x800aad <integral+0x1>
    133e:	10 92 ae 0a 	sts	0x0AAE, r1	; 0x800aae <integral+0x2>
    1342:	10 92 af 0a 	sts	0x0AAF, r1	; 0x800aaf <integral+0x3>
    1346:	10 92 34 0a 	sts	0x0A34, r1	; 0x800a34 <derivative>
    134a:	10 92 35 0a 	sts	0x0A35, r1	; 0x800a35 <derivative+0x1>
    134e:	10 92 36 0a 	sts	0x0A36, r1	; 0x800a36 <derivative+0x2>
    1352:	10 92 37 0a 	sts	0x0A37, r1	; 0x800a37 <derivative+0x3>
  position = 0.0;  angle = 0.0;
    1356:	10 92 8e 0a 	sts	0x0A8E, r1	; 0x800a8e <position>
    135a:	10 92 8f 0a 	sts	0x0A8F, r1	; 0x800a8f <position+0x1>
    135e:	10 92 90 0a 	sts	0x0A90, r1	; 0x800a90 <position+0x2>
    1362:	10 92 91 0a 	sts	0x0A91, r1	; 0x800a91 <position+0x3>
    1366:	10 92 a5 0a 	sts	0x0AA5, r1	; 0x800aa5 <angle>
    136a:	10 92 a6 0a 	sts	0x0AA6, r1	; 0x800aa6 <angle+0x1>
    136e:	10 92 a7 0a 	sts	0x0AA7, r1	; 0x800aa7 <angle+0x2>
    1372:	10 92 a8 0a 	sts	0x0AA8, r1	; 0x800aa8 <angle+0x3>
const char err_Cursor_X [21] PROGMEM =         "Cursor_X out of rang"; 
// Enum for HMI state machine
enum {Main, Para1, Para2, PIDr, SBP};
//------------------------------------------------------------------
void  vHMI ( void * pvParameters)
{ unsigned char  lauf, para = NADA , status = Main;
    1376:	f1 2c       	mov	r15, r1
  integral = 0.0;  derivative = 0.0;
  position = 0.0;  angle = 0.0;
  // Super loop of task vHMI
  for (;;)
  {	vTaskDelay(20);  // 20x 3ms = 60ms
		PORTG = PORTG ^ 2;
    1378:	0f 2e       	mov	r0, r31
    137a:	f5 e6       	ldi	r31, 0x65	; 101
    137c:	8f 2e       	mov	r8, r31
    137e:	91 2c       	mov	r9, r1
    1380:	f0 2d       	mov	r31, r0
    1382:	68 94       	set
    1384:	bb 24       	eor	r11, r11
    1386:	b1 f8       	bld	r11, 1
    1388:	06 e8       	ldi	r16, 0x86	; 134
    138a:	1a e0       	ldi	r17, 0x0A	; 10
				{ case UP:  if (Cursor_Y > 1)  Cursor_Y--;  break;
					case DOWN:  if (Cursor_Y < 3)  Cursor_Y++;  break;	
					case ENTER:
					if (Cursor_Y == 1)  derivative = change_para (derivative);
					else if (Cursor_Y == 2)  reference = change_para (reference);
					else if (Cursor_Y == 3)  status = Main;
    138c:	e1 2c       	mov	r14, r1
				}  break;  // case Para2
			case PIDr:
				for (lauf = 0; lauf < 78; lauf++)
					SRAM_LCD_Text[lauf] = pgm_read_byte (&PID_Menu [lauf]);
				floatvalues2LCD (position, angle);
				Cursor_Y = 3;  servo_power = 1;
    138e:	0f 2e       	mov	r0, r31
    1390:	f3 e0       	ldi	r31, 0x03	; 3
    1392:	df 2e       	mov	r13, r31
    1394:	f0 2d       	mov	r31, r0
    1396:	cc 24       	eor	r12, r12
    1398:	c3 94       	inc	r12
				{ case UP:  if (Cursor_Y > 1)  Cursor_Y--;  break;
					case DOWN:  if (Cursor_Y < 3)  Cursor_Y++;  break;	
					case ENTER:
						switch (Cursor_Y)
					{ case 1:  status = Para1;  break;
						case 2:  status = SBP;  break;
    139a:	68 94       	set
    139c:	aa 24       	eor	r10, r10
    139e:	a2 f8       	bld	r10, 2
  reference = 0.0;  proportional = 0.2;
  integral = 0.0;  derivative = 0.0;
  position = 0.0;  angle = 0.0;
  // Super loop of task vHMI
  for (;;)
  {	vTaskDelay(20);  // 20x 3ms = 60ms
    13a0:	84 e1       	ldi	r24, 0x14	; 20
    13a2:	90 e0       	ldi	r25, 0x00	; 0
    13a4:	0e 94 cb 15 	call	0x2b96	; 0x2b96 <vTaskDelay>
		PORTG = PORTG ^ 2;
    13a8:	f4 01       	movw	r30, r8
    13aa:	80 81       	ld	r24, Z
    13ac:	8b 25       	eor	r24, r11
    13ae:	80 83       	st	Z, r24
		switch (status)
    13b0:	f2 e0       	ldi	r31, 0x02	; 2
    13b2:	ff 16       	cp	r15, r31
    13b4:	09 f4       	brne	.+2      	; 0x13b8 <vHMI+0xd0>
    13b6:	ae c0       	rjmp	.+348    	; 0x1514 <vHMI+0x22c>
    13b8:	ff 15       	cp	r31, r15
    13ba:	38 f0       	brcs	.+14     	; 0x13ca <vHMI+0xe2>
    13bc:	ff 20       	and	r15, r15
    13be:	71 f0       	breq	.+28     	; 0x13dc <vHMI+0xf4>
    13c0:	81 e0       	ldi	r24, 0x01	; 1
    13c2:	f8 16       	cp	r15, r24
    13c4:	09 f4       	brne	.+2      	; 0x13c8 <vHMI+0xe0>
    13c6:	42 c0       	rjmp	.+132    	; 0x144c <vHMI+0x164>
    13c8:	52 c1       	rjmp	.+676    	; 0x166e <vHMI+0x386>
    13ca:	e3 e0       	ldi	r30, 0x03	; 3
    13cc:	fe 16       	cp	r15, r30
    13ce:	09 f4       	brne	.+2      	; 0x13d2 <vHMI+0xea>
    13d0:	05 c1       	rjmp	.+522    	; 0x15dc <vHMI+0x2f4>
    13d2:	f4 e0       	ldi	r31, 0x04	; 4
    13d4:	ff 16       	cp	r15, r31
    13d6:	09 f4       	brne	.+2      	; 0x13da <vHMI+0xf2>
    13d8:	38 c1       	rjmp	.+624    	; 0x164a <vHMI+0x362>
    13da:	49 c1       	rjmp	.+658    	; 0x166e <vHMI+0x386>
    13dc:	ea e4       	ldi	r30, 0x4A	; 74
    13de:	f2 e0       	ldi	r31, 0x02	; 2
    13e0:	a8 e3       	ldi	r26, 0x38	; 56
    13e2:	ba e0       	ldi	r27, 0x0A	; 10
		{	case Main:
				for (lauf = 0; lauf < 78; lauf++)
					SRAM_LCD_Text[lauf] = pgm_read_byte (&Main_Menu [lauf]);
    13e4:	84 91       	lpm	r24, Z
    13e6:	8d 93       	st	X+, r24
    13e8:	31 96       	adiw	r30, 0x01	; 1
  for (;;)
  {	vTaskDelay(20);  // 20x 3ms = 60ms
		PORTG = PORTG ^ 2;
		switch (status)
		{	case Main:
				for (lauf = 0; lauf < 78; lauf++)
    13ea:	0a 17       	cp	r16, r26
    13ec:	1b 07       	cpc	r17, r27
    13ee:	d1 f7       	brne	.-12     	; 0x13e4 <vHMI+0xfc>
					SRAM_LCD_Text[lauf] = pgm_read_byte (&Main_Menu [lauf]);
				// All LEDs off
				cli();  PORTC = PORTC & 0b10000000;  sei();
    13f0:	f8 94       	cli
    13f2:	85 b3       	in	r24, 0x15	; 21
    13f4:	80 78       	andi	r24, 0x80	; 128
    13f6:	85 bb       	out	0x15, r24	; 21
    13f8:	78 94       	sei
				switch (para)
    13fa:	89 81       	ldd	r24, Y+1	; 0x01
    13fc:	82 30       	cpi	r24, 0x02	; 2
    13fe:	71 f0       	breq	.+28     	; 0x141c <vHMI+0x134>
    1400:	85 30       	cpi	r24, 0x05	; 5
    1402:	a9 f0       	breq	.+42     	; 0x142e <vHMI+0x146>
    1404:	81 30       	cpi	r24, 0x01	; 1
    1406:	09 f0       	breq	.+2      	; 0x140a <vHMI+0x122>
    1408:	38 c1       	rjmp	.+624    	; 0x167a <vHMI+0x392>
				{ case UP:  if (Cursor_Y > 1)  Cursor_Y--;  break;
    140a:	80 91 33 0a 	lds	r24, 0x0A33	; 0x800a33 <Cursor_Y>
    140e:	82 30       	cpi	r24, 0x02	; 2
    1410:	08 f4       	brcc	.+2      	; 0x1414 <vHMI+0x12c>
    1412:	33 c1       	rjmp	.+614    	; 0x167a <vHMI+0x392>
    1414:	81 50       	subi	r24, 0x01	; 1
    1416:	80 93 33 0a 	sts	0x0A33, r24	; 0x800a33 <Cursor_Y>
    141a:	2f c1       	rjmp	.+606    	; 0x167a <vHMI+0x392>
					case DOWN:  if (Cursor_Y < 3)  Cursor_Y++;  break;	
    141c:	80 91 33 0a 	lds	r24, 0x0A33	; 0x800a33 <Cursor_Y>
    1420:	83 30       	cpi	r24, 0x03	; 3
    1422:	08 f0       	brcs	.+2      	; 0x1426 <vHMI+0x13e>
    1424:	2a c1       	rjmp	.+596    	; 0x167a <vHMI+0x392>
    1426:	8f 5f       	subi	r24, 0xFF	; 255
    1428:	80 93 33 0a 	sts	0x0A33, r24	; 0x800a33 <Cursor_Y>
    142c:	26 c1       	rjmp	.+588    	; 0x167a <vHMI+0x392>
					case ENTER:
						switch (Cursor_Y)
    142e:	80 91 33 0a 	lds	r24, 0x0A33	; 0x800a33 <Cursor_Y>
    1432:	82 30       	cpi	r24, 0x02	; 2
    1434:	39 f0       	breq	.+14     	; 0x1444 <vHMI+0x15c>
    1436:	83 30       	cpi	r24, 0x03	; 3
    1438:	39 f0       	breq	.+14     	; 0x1448 <vHMI+0x160>
    143a:	81 30       	cpi	r24, 0x01	; 1
    143c:	09 f0       	breq	.+2      	; 0x1440 <vHMI+0x158>
    143e:	1d c1       	rjmp	.+570    	; 0x167a <vHMI+0x392>
					{ case 1:  status = Para1;  break;
    1440:	fc 2c       	mov	r15, r12
    1442:	1b c1       	rjmp	.+566    	; 0x167a <vHMI+0x392>
						case 2:  status = SBP;  break;
    1444:	fa 2c       	mov	r15, r10
    1446:	19 c1       	rjmp	.+562    	; 0x167a <vHMI+0x392>
						case 3:  status = PIDr;  break;
    1448:	fd 2c       	mov	r15, r13
    144a:	17 c1       	rjmp	.+558    	; 0x167a <vHMI+0x392>
    144c:	ea ef       	ldi	r30, 0xFA	; 250
    144e:	f1 e0       	ldi	r31, 0x01	; 1
    1450:	a8 e3       	ldi	r26, 0x38	; 56
    1452:	ba e0       	ldi	r27, 0x0A	; 10
					}  break;  // case ENTER	
				}  break; // case Main
			case Para1:
				for (lauf = 0; lauf < 78; lauf++)
					SRAM_LCD_Text[lauf] = pgm_read_byte (&PI_Parameter_Menu [lauf]);
    1454:	84 91       	lpm	r24, Z
    1456:	8d 93       	st	X+, r24
    1458:	31 96       	adiw	r30, 0x01	; 1
						case 2:  status = SBP;  break;
						case 3:  status = PIDr;  break;
					}  break;  // case ENTER	
				}  break; // case Main
			case Para1:
				for (lauf = 0; lauf < 78; lauf++)
    145a:	a0 17       	cp	r26, r16
    145c:	b1 07       	cpc	r27, r17
    145e:	d1 f7       	brne	.-12     	; 0x1454 <vHMI+0x16c>
					SRAM_LCD_Text[lauf] = pgm_read_byte (&PI_Parameter_Menu [lauf]);
				floatvalues2LCD (proportional, integral);
    1460:	20 91 ac 0a 	lds	r18, 0x0AAC	; 0x800aac <integral>
    1464:	30 91 ad 0a 	lds	r19, 0x0AAD	; 0x800aad <integral+0x1>
    1468:	40 91 ae 0a 	lds	r20, 0x0AAE	; 0x800aae <integral+0x2>
    146c:	50 91 af 0a 	lds	r21, 0x0AAF	; 0x800aaf <integral+0x3>
    1470:	60 91 a1 0a 	lds	r22, 0x0AA1	; 0x800aa1 <proportional>
    1474:	70 91 a2 0a 	lds	r23, 0x0AA2	; 0x800aa2 <proportional+0x1>
    1478:	80 91 a3 0a 	lds	r24, 0x0AA3	; 0x800aa3 <proportional+0x2>
    147c:	90 91 a4 0a 	lds	r25, 0x0AA4	; 0x800aa4 <proportional+0x3>
    1480:	09 da       	rcall	.-3054   	; 0x894 <floatvalues2LCD>
				switch (para)
    1482:	89 81       	ldd	r24, Y+1	; 0x01
    1484:	82 30       	cpi	r24, 0x02	; 2
    1486:	71 f0       	breq	.+28     	; 0x14a4 <vHMI+0x1bc>
    1488:	85 30       	cpi	r24, 0x05	; 5
    148a:	a9 f0       	breq	.+42     	; 0x14b6 <vHMI+0x1ce>
    148c:	81 30       	cpi	r24, 0x01	; 1
    148e:	09 f0       	breq	.+2      	; 0x1492 <vHMI+0x1aa>
    1490:	f4 c0       	rjmp	.+488    	; 0x167a <vHMI+0x392>
				{ case UP:  if (Cursor_Y > 1)  Cursor_Y--;  break;
    1492:	80 91 33 0a 	lds	r24, 0x0A33	; 0x800a33 <Cursor_Y>
    1496:	82 30       	cpi	r24, 0x02	; 2
    1498:	08 f4       	brcc	.+2      	; 0x149c <vHMI+0x1b4>
    149a:	ef c0       	rjmp	.+478    	; 0x167a <vHMI+0x392>
    149c:	81 50       	subi	r24, 0x01	; 1
    149e:	80 93 33 0a 	sts	0x0A33, r24	; 0x800a33 <Cursor_Y>
    14a2:	eb c0       	rjmp	.+470    	; 0x167a <vHMI+0x392>
					case DOWN:  if (Cursor_Y < 3)  Cursor_Y++;  break;	
    14a4:	80 91 33 0a 	lds	r24, 0x0A33	; 0x800a33 <Cursor_Y>
    14a8:	83 30       	cpi	r24, 0x03	; 3
    14aa:	08 f0       	brcs	.+2      	; 0x14ae <vHMI+0x1c6>
    14ac:	e6 c0       	rjmp	.+460    	; 0x167a <vHMI+0x392>
    14ae:	8f 5f       	subi	r24, 0xFF	; 255
    14b0:	80 93 33 0a 	sts	0x0A33, r24	; 0x800a33 <Cursor_Y>
    14b4:	e2 c0       	rjmp	.+452    	; 0x167a <vHMI+0x392>
					case ENTER:  
					if (Cursor_Y == 1)  proportional = change_para (proportional);
    14b6:	80 91 33 0a 	lds	r24, 0x0A33	; 0x800a33 <Cursor_Y>
    14ba:	81 30       	cpi	r24, 0x01	; 1
    14bc:	91 f4       	brne	.+36     	; 0x14e2 <vHMI+0x1fa>
    14be:	60 91 a1 0a 	lds	r22, 0x0AA1	; 0x800aa1 <proportional>
    14c2:	70 91 a2 0a 	lds	r23, 0x0AA2	; 0x800aa2 <proportional+0x1>
    14c6:	80 91 a3 0a 	lds	r24, 0x0AA3	; 0x800aa3 <proportional+0x2>
    14ca:	90 91 a4 0a 	lds	r25, 0x0AA4	; 0x800aa4 <proportional+0x3>
    14ce:	2b db       	rcall	.-2474   	; 0xb26 <change_para>
    14d0:	60 93 a1 0a 	sts	0x0AA1, r22	; 0x800aa1 <proportional>
    14d4:	70 93 a2 0a 	sts	0x0AA2, r23	; 0x800aa2 <proportional+0x1>
    14d8:	80 93 a3 0a 	sts	0x0AA3, r24	; 0x800aa3 <proportional+0x2>
    14dc:	90 93 a4 0a 	sts	0x0AA4, r25	; 0x800aa4 <proportional+0x3>
    14e0:	cc c0       	rjmp	.+408    	; 0x167a <vHMI+0x392>
					else if (Cursor_Y == 2)  integral = change_para (integral);
    14e2:	82 30       	cpi	r24, 0x02	; 2
    14e4:	91 f4       	brne	.+36     	; 0x150a <vHMI+0x222>
    14e6:	60 91 ac 0a 	lds	r22, 0x0AAC	; 0x800aac <integral>
    14ea:	70 91 ad 0a 	lds	r23, 0x0AAD	; 0x800aad <integral+0x1>
    14ee:	80 91 ae 0a 	lds	r24, 0x0AAE	; 0x800aae <integral+0x2>
    14f2:	90 91 af 0a 	lds	r25, 0x0AAF	; 0x800aaf <integral+0x3>
    14f6:	17 db       	rcall	.-2514   	; 0xb26 <change_para>
    14f8:	60 93 ac 0a 	sts	0x0AAC, r22	; 0x800aac <integral>
    14fc:	70 93 ad 0a 	sts	0x0AAD, r23	; 0x800aad <integral+0x1>
    1500:	80 93 ae 0a 	sts	0x0AAE, r24	; 0x800aae <integral+0x2>
    1504:	90 93 af 0a 	sts	0x0AAF, r25	; 0x800aaf <integral+0x3>
    1508:	b8 c0       	rjmp	.+368    	; 0x167a <vHMI+0x392>
					else if (Cursor_Y == 3)  status = Para2;
    150a:	83 30       	cpi	r24, 0x03	; 3
    150c:	09 f0       	breq	.+2      	; 0x1510 <vHMI+0x228>
    150e:	b5 c0       	rjmp	.+362    	; 0x167a <vHMI+0x392>
    1510:	fb 2c       	mov	r15, r11
    1512:	b3 c0       	rjmp	.+358    	; 0x167a <vHMI+0x392>
    1514:	ea ea       	ldi	r30, 0xAA	; 170
    1516:	f1 e0       	ldi	r31, 0x01	; 1
    1518:	a8 e3       	ldi	r26, 0x38	; 56
    151a:	ba e0       	ldi	r27, 0x0A	; 10
						break;	
				}  break;  // case Para1
			case Para2:
				for (lauf = 0; lauf < 78; lauf++)
					SRAM_LCD_Text[lauf] = pgm_read_byte (&DRT_Parameter_Menu [lauf]);
    151c:	84 91       	lpm	r24, Z
    151e:	8d 93       	st	X+, r24
    1520:	31 96       	adiw	r30, 0x01	; 1
					else if (Cursor_Y == 2)  integral = change_para (integral);
					else if (Cursor_Y == 3)  status = Para2;
						break;	
				}  break;  // case Para1
			case Para2:
				for (lauf = 0; lauf < 78; lauf++)
    1522:	a0 17       	cp	r26, r16
    1524:	b1 07       	cpc	r27, r17
    1526:	d1 f7       	brne	.-12     	; 0x151c <vHMI+0x234>
					SRAM_LCD_Text[lauf] = pgm_read_byte (&DRT_Parameter_Menu [lauf]);
				floatvalues2LCD (derivative, reference);
    1528:	20 91 88 0a 	lds	r18, 0x0A88	; 0x800a88 <reference>
    152c:	30 91 89 0a 	lds	r19, 0x0A89	; 0x800a89 <reference+0x1>
    1530:	40 91 8a 0a 	lds	r20, 0x0A8A	; 0x800a8a <reference+0x2>
    1534:	50 91 8b 0a 	lds	r21, 0x0A8B	; 0x800a8b <reference+0x3>
    1538:	60 91 34 0a 	lds	r22, 0x0A34	; 0x800a34 <derivative>
    153c:	70 91 35 0a 	lds	r23, 0x0A35	; 0x800a35 <derivative+0x1>
    1540:	80 91 36 0a 	lds	r24, 0x0A36	; 0x800a36 <derivative+0x2>
    1544:	90 91 37 0a 	lds	r25, 0x0A37	; 0x800a37 <derivative+0x3>
    1548:	a5 d9       	rcall	.-3254   	; 0x894 <floatvalues2LCD>
				switch (para)
    154a:	89 81       	ldd	r24, Y+1	; 0x01
    154c:	82 30       	cpi	r24, 0x02	; 2
    154e:	71 f0       	breq	.+28     	; 0x156c <vHMI+0x284>
    1550:	85 30       	cpi	r24, 0x05	; 5
    1552:	a9 f0       	breq	.+42     	; 0x157e <vHMI+0x296>
    1554:	81 30       	cpi	r24, 0x01	; 1
    1556:	09 f0       	breq	.+2      	; 0x155a <vHMI+0x272>
    1558:	90 c0       	rjmp	.+288    	; 0x167a <vHMI+0x392>
				{ case UP:  if (Cursor_Y > 1)  Cursor_Y--;  break;
    155a:	80 91 33 0a 	lds	r24, 0x0A33	; 0x800a33 <Cursor_Y>
    155e:	82 30       	cpi	r24, 0x02	; 2
    1560:	08 f4       	brcc	.+2      	; 0x1564 <vHMI+0x27c>
    1562:	8b c0       	rjmp	.+278    	; 0x167a <vHMI+0x392>
    1564:	81 50       	subi	r24, 0x01	; 1
    1566:	80 93 33 0a 	sts	0x0A33, r24	; 0x800a33 <Cursor_Y>
    156a:	87 c0       	rjmp	.+270    	; 0x167a <vHMI+0x392>
					case DOWN:  if (Cursor_Y < 3)  Cursor_Y++;  break;	
    156c:	80 91 33 0a 	lds	r24, 0x0A33	; 0x800a33 <Cursor_Y>
    1570:	83 30       	cpi	r24, 0x03	; 3
    1572:	08 f0       	brcs	.+2      	; 0x1576 <vHMI+0x28e>
    1574:	82 c0       	rjmp	.+260    	; 0x167a <vHMI+0x392>
    1576:	8f 5f       	subi	r24, 0xFF	; 255
    1578:	80 93 33 0a 	sts	0x0A33, r24	; 0x800a33 <Cursor_Y>
    157c:	7e c0       	rjmp	.+252    	; 0x167a <vHMI+0x392>
					case ENTER:
					if (Cursor_Y == 1)  derivative = change_para (derivative);
    157e:	80 91 33 0a 	lds	r24, 0x0A33	; 0x800a33 <Cursor_Y>
    1582:	81 30       	cpi	r24, 0x01	; 1
    1584:	91 f4       	brne	.+36     	; 0x15aa <vHMI+0x2c2>
    1586:	60 91 34 0a 	lds	r22, 0x0A34	; 0x800a34 <derivative>
    158a:	70 91 35 0a 	lds	r23, 0x0A35	; 0x800a35 <derivative+0x1>
    158e:	80 91 36 0a 	lds	r24, 0x0A36	; 0x800a36 <derivative+0x2>
    1592:	90 91 37 0a 	lds	r25, 0x0A37	; 0x800a37 <derivative+0x3>
    1596:	c7 da       	rcall	.-2674   	; 0xb26 <change_para>
    1598:	60 93 34 0a 	sts	0x0A34, r22	; 0x800a34 <derivative>
    159c:	70 93 35 0a 	sts	0x0A35, r23	; 0x800a35 <derivative+0x1>
    15a0:	80 93 36 0a 	sts	0x0A36, r24	; 0x800a36 <derivative+0x2>
    15a4:	90 93 37 0a 	sts	0x0A37, r25	; 0x800a37 <derivative+0x3>
    15a8:	68 c0       	rjmp	.+208    	; 0x167a <vHMI+0x392>
					else if (Cursor_Y == 2)  reference = change_para (reference);
    15aa:	82 30       	cpi	r24, 0x02	; 2
    15ac:	91 f4       	brne	.+36     	; 0x15d2 <vHMI+0x2ea>
    15ae:	60 91 88 0a 	lds	r22, 0x0A88	; 0x800a88 <reference>
    15b2:	70 91 89 0a 	lds	r23, 0x0A89	; 0x800a89 <reference+0x1>
    15b6:	80 91 8a 0a 	lds	r24, 0x0A8A	; 0x800a8a <reference+0x2>
    15ba:	90 91 8b 0a 	lds	r25, 0x0A8B	; 0x800a8b <reference+0x3>
    15be:	b3 da       	rcall	.-2714   	; 0xb26 <change_para>
    15c0:	60 93 88 0a 	sts	0x0A88, r22	; 0x800a88 <reference>
    15c4:	70 93 89 0a 	sts	0x0A89, r23	; 0x800a89 <reference+0x1>
    15c8:	80 93 8a 0a 	sts	0x0A8A, r24	; 0x800a8a <reference+0x2>
    15cc:	90 93 8b 0a 	sts	0x0A8B, r25	; 0x800a8b <reference+0x3>
    15d0:	54 c0       	rjmp	.+168    	; 0x167a <vHMI+0x392>
					else if (Cursor_Y == 3)  status = Main;
    15d2:	83 30       	cpi	r24, 0x03	; 3
    15d4:	09 f0       	breq	.+2      	; 0x15d8 <vHMI+0x2f0>
    15d6:	51 c0       	rjmp	.+162    	; 0x167a <vHMI+0x392>
    15d8:	fe 2c       	mov	r15, r14
    15da:	4f c0       	rjmp	.+158    	; 0x167a <vHMI+0x392>
    15dc:	ea e5       	ldi	r30, 0x5A	; 90
    15de:	f1 e0       	ldi	r31, 0x01	; 1
    15e0:	a8 e3       	ldi	r26, 0x38	; 56
    15e2:	ba e0       	ldi	r27, 0x0A	; 10
						break;	
				}  break;  // case Para2
			case PIDr:
				for (lauf = 0; lauf < 78; lauf++)
					SRAM_LCD_Text[lauf] = pgm_read_byte (&PID_Menu [lauf]);
    15e4:	84 91       	lpm	r24, Z
    15e6:	8d 93       	st	X+, r24
    15e8:	31 96       	adiw	r30, 0x01	; 1
					else if (Cursor_Y == 2)  reference = change_para (reference);
					else if (Cursor_Y == 3)  status = Main;
						break;	
				}  break;  // case Para2
			case PIDr:
				for (lauf = 0; lauf < 78; lauf++)
    15ea:	0a 17       	cp	r16, r26
    15ec:	1b 07       	cpc	r17, r27
    15ee:	d1 f7       	brne	.-12     	; 0x15e4 <vHMI+0x2fc>
					SRAM_LCD_Text[lauf] = pgm_read_byte (&PID_Menu [lauf]);
				floatvalues2LCD (position, angle);
    15f0:	20 91 a5 0a 	lds	r18, 0x0AA5	; 0x800aa5 <angle>
    15f4:	30 91 a6 0a 	lds	r19, 0x0AA6	; 0x800aa6 <angle+0x1>
    15f8:	40 91 a7 0a 	lds	r20, 0x0AA7	; 0x800aa7 <angle+0x2>
    15fc:	50 91 a8 0a 	lds	r21, 0x0AA8	; 0x800aa8 <angle+0x3>
    1600:	60 91 8e 0a 	lds	r22, 0x0A8E	; 0x800a8e <position>
    1604:	70 91 8f 0a 	lds	r23, 0x0A8F	; 0x800a8f <position+0x1>
    1608:	80 91 90 0a 	lds	r24, 0x0A90	; 0x800a90 <position+0x2>
    160c:	90 91 91 0a 	lds	r25, 0x0A91	; 0x800a91 <position+0x3>
    1610:	41 d9       	rcall	.-3454   	; 0x894 <floatvalues2LCD>
				Cursor_Y = 3;  servo_power = 1;
    1612:	d0 92 33 0a 	sts	0x0A33, r13	; 0x800a33 <Cursor_Y>
    1616:	c0 92 ab 0a 	sts	0x0AAB, r12	; 0x800aab <servo_power>
				vTaskResume (vSensor_Handle);
    161a:	80 91 92 0a 	lds	r24, 0x0A92	; 0x800a92 <vSensor_Handle>
    161e:	90 91 93 0a 	lds	r25, 0x0A93	; 0x800a93 <vSensor_Handle+0x1>
    1622:	0e 94 5f 14 	call	0x28be	; 0x28be <vTaskResume>
				if (para == ENTER)
    1626:	89 81       	ldd	r24, Y+1	; 0x01
    1628:	85 30       	cpi	r24, 0x05	; 5
    162a:	39 f5       	brne	.+78     	; 0x167a <vHMI+0x392>
				{ vTaskSuspend (vSensor_Handle);
    162c:	80 91 92 0a 	lds	r24, 0x0A92	; 0x800a92 <vSensor_Handle>
    1630:	90 91 93 0a 	lds	r25, 0x0A93	; 0x800a93 <vSensor_Handle+0x1>
    1634:	0e 94 12 14 	call	0x2824	; 0x2824 <vTaskSuspend>
					cli();  PORTC = PORTC & 0b10000000;  sei();
    1638:	f8 94       	cli
    163a:	85 b3       	in	r24, 0x15	; 21
    163c:	80 78       	andi	r24, 0x80	; 128
    163e:	85 bb       	out	0x15, r24	; 21
    1640:	78 94       	sei
					status = Main;
					servo_power = 0;
    1642:	e0 92 ab 0a 	sts	0x0AAB, r14	; 0x800aab <servo_power>
				Cursor_Y = 3;  servo_power = 1;
				vTaskResume (vSensor_Handle);
				if (para == ENTER)
				{ vTaskSuspend (vSensor_Handle);
					cli();  PORTC = PORTC & 0b10000000;  sei();
					status = Main;
    1646:	fe 2c       	mov	r15, r14
    1648:	18 c0       	rjmp	.+48     	; 0x167a <vHMI+0x392>
    164a:	ea e0       	ldi	r30, 0x0A	; 10
    164c:	f1 e0       	ldi	r31, 0x01	; 1
    164e:	a8 e3       	ldi	r26, 0x38	; 56
					servo_power = 0;
				}  break;  // case PIDr
			case SBP:
				for (lauf = 0; lauf < 78; lauf++)
					SRAM_LCD_Text[lauf] = pgm_read_byte (&SBP_Menu [lauf]);
    1650:	ba e0       	ldi	r27, 0x0A	; 10
    1652:	84 91       	lpm	r24, Z
    1654:	8d 93       	st	X+, r24
					cli();  PORTC = PORTC & 0b10000000;  sei();
					status = Main;
					servo_power = 0;
				}  break;  // case PIDr
			case SBP:
				for (lauf = 0; lauf < 78; lauf++)
    1656:	31 96       	adiw	r30, 0x01	; 1
    1658:	0a 17       	cp	r16, r26
    165a:	1b 07       	cpc	r17, r27
					SRAM_LCD_Text[lauf] = pgm_read_byte (&SBP_Menu [lauf]);
				show_sensors ();
    165c:	d1 f7       	brne	.-12     	; 0x1652 <vHMI+0x36a>
    165e:	ae dc       	rcall	.-1700   	; 0xfbc <show_sensors>
				Cursor_Y = 3;
    1660:	d0 92 33 0a 	sts	0x0A33, r13	; 0x800a33 <Cursor_Y>
				if (para == ENTER)  status = Main;
    1664:	89 81       	ldd	r24, Y+1	; 0x01
    1666:	85 30       	cpi	r24, 0x05	; 5
    1668:	41 f4       	brne	.+16     	; 0x167a <vHMI+0x392>
				break;  // case SBP
			default: cli();  lcd_clrscr();  lcd_puts_p(err_status);  while(1);
    166a:	fe 2c       	mov	r15, r14
    166c:	06 c0       	rjmp	.+12     	; 0x167a <vHMI+0x392>
    166e:	f8 94       	cli
    1670:	8f d0       	rcall	.+286    	; 0x1790 <lcd_clrscr>
    1672:	85 ef       	ldi	r24, 0xF5	; 245
    1674:	90 e0       	ldi	r25, 0x00	; 0
    1676:	be d0       	rcall	.+380    	; 0x17f4 <lcd_puts_p>
    1678:	ff cf       	rjmp	.-2      	; 0x1678 <vHMI+0x390>
		}  // end switch (status)
    if (xQueueReceive (QueueTaster, &para, 0) != pdTRUE)  para = NADA;
    167a:	2e 2d       	mov	r18, r14
    167c:	40 e0       	ldi	r20, 0x00	; 0
    167e:	50 e0       	ldi	r21, 0x00	; 0
    1680:	be 01       	movw	r22, r28
    1682:	6f 5f       	subi	r22, 0xFF	; 255
    1684:	7f 4f       	sbci	r23, 0xFF	; 255
    1686:	80 91 9f 0a 	lds	r24, 0x0A9F	; 0x800a9f <QueueTaster>
    168a:	90 91 a0 0a 	lds	r25, 0x0AA0	; 0x800aa0 <QueueTaster+0x1>
    168e:	55 d5       	rcall	.+2730   	; 0x213a <xQueueGenericReceive>
    1690:	81 30       	cpi	r24, 0x01	; 1
    1692:	09 f4       	brne	.+2      	; 0x1696 <vHMI+0x3ae>
    1694:	85 ce       	rjmp	.-758    	; 0x13a0 <vHMI+0xb8>
    1696:	e9 82       	std	Y+1, r14	; 0x01
    1698:	83 ce       	rjmp	.-762    	; 0x13a0 <vHMI+0xb8>

0000169a <toggle_e>:
/*************************************************************************
*************************************************************************/
int lcd_getxy(void)
{
    return lcd_waitbusy();
}
    169a:	1c 9a       	sbi	0x03, 4	; 3
    169c:	00 c0       	rjmp	.+0      	; 0x169e <toggle_e+0x4>
    169e:	1c 98       	cbi	0x03, 4	; 3
    16a0:	08 95       	ret

000016a2 <lcd_write>:
    16a2:	cf 93       	push	r28
    16a4:	c8 2f       	mov	r28, r24
    16a6:	66 23       	and	r22, r22
    16a8:	11 f0       	breq	.+4      	; 0x16ae <lcd_write+0xc>
    16aa:	1a 9a       	sbi	0x03, 2	; 3
    16ac:	01 c0       	rjmp	.+2      	; 0x16b0 <lcd_write+0xe>
    16ae:	1a 98       	cbi	0x03, 2	; 3
    16b0:	1b 98       	cbi	0x03, 3	; 3
    16b2:	bc 9a       	sbi	0x17, 4	; 23
    16b4:	bd 9a       	sbi	0x17, 5	; 23
    16b6:	be 9a       	sbi	0x17, 6	; 23
    16b8:	bf 9a       	sbi	0x17, 7	; 23
    16ba:	c7 98       	cbi	0x18, 7	; 24
    16bc:	c6 98       	cbi	0x18, 6	; 24
    16be:	c5 98       	cbi	0x18, 5	; 24
    16c0:	c4 98       	cbi	0x18, 4	; 24
    16c2:	cc 23       	and	r28, r28
    16c4:	0c f4       	brge	.+2      	; 0x16c8 <lcd_write+0x26>
    16c6:	c7 9a       	sbi	0x18, 7	; 24
    16c8:	c6 fd       	sbrc	r28, 6
    16ca:	c6 9a       	sbi	0x18, 6	; 24
    16cc:	c5 fd       	sbrc	r28, 5
    16ce:	c5 9a       	sbi	0x18, 5	; 24
    16d0:	c4 fd       	sbrc	r28, 4
    16d2:	c4 9a       	sbi	0x18, 4	; 24
    16d4:	e2 df       	rcall	.-60     	; 0x169a <toggle_e>
    16d6:	c7 98       	cbi	0x18, 7	; 24
    16d8:	c6 98       	cbi	0x18, 6	; 24
    16da:	c5 98       	cbi	0x18, 5	; 24
    16dc:	c4 98       	cbi	0x18, 4	; 24
    16de:	c3 fd       	sbrc	r28, 3
    16e0:	c7 9a       	sbi	0x18, 7	; 24
    16e2:	c2 fd       	sbrc	r28, 2
    16e4:	c6 9a       	sbi	0x18, 6	; 24
    16e6:	c1 fd       	sbrc	r28, 1
    16e8:	c5 9a       	sbi	0x18, 5	; 24
    16ea:	c0 fd       	sbrc	r28, 0
    16ec:	c4 9a       	sbi	0x18, 4	; 24
    16ee:	d5 df       	rcall	.-86     	; 0x169a <toggle_e>
    16f0:	c4 9a       	sbi	0x18, 4	; 24
    16f2:	c5 9a       	sbi	0x18, 5	; 24
    16f4:	c6 9a       	sbi	0x18, 6	; 24
    16f6:	c7 9a       	sbi	0x18, 7	; 24
    16f8:	cf 91       	pop	r28
    16fa:	08 95       	ret

000016fc <lcd_read>:
    16fc:	88 23       	and	r24, r24
    16fe:	11 f0       	breq	.+4      	; 0x1704 <lcd_read+0x8>
    1700:	1a 9a       	sbi	0x03, 2	; 3
    1702:	01 c0       	rjmp	.+2      	; 0x1706 <lcd_read+0xa>
    1704:	1a 98       	cbi	0x03, 2	; 3
    1706:	1b 9a       	sbi	0x03, 3	; 3
    1708:	bc 98       	cbi	0x17, 4	; 23
    170a:	bd 98       	cbi	0x17, 5	; 23
    170c:	be 98       	cbi	0x17, 6	; 23
    170e:	bf 98       	cbi	0x17, 7	; 23
    1710:	1c 9a       	sbi	0x03, 4	; 3
    1712:	00 c0       	rjmp	.+0      	; 0x1714 <lcd_read+0x18>
    1714:	b4 9b       	sbis	0x16, 4	; 22
    1716:	02 c0       	rjmp	.+4      	; 0x171c <lcd_read+0x20>
    1718:	80 e1       	ldi	r24, 0x10	; 16
    171a:	01 c0       	rjmp	.+2      	; 0x171e <lcd_read+0x22>
    171c:	80 e0       	ldi	r24, 0x00	; 0
    171e:	b5 99       	sbic	0x16, 5	; 22
    1720:	80 62       	ori	r24, 0x20	; 32
    1722:	b6 99       	sbic	0x16, 6	; 22
    1724:	80 64       	ori	r24, 0x40	; 64
    1726:	b7 99       	sbic	0x16, 7	; 22
    1728:	80 68       	ori	r24, 0x80	; 128
    172a:	1c 98       	cbi	0x03, 4	; 3
    172c:	00 c0       	rjmp	.+0      	; 0x172e <lcd_read+0x32>
    172e:	1c 9a       	sbi	0x03, 4	; 3
    1730:	00 c0       	rjmp	.+0      	; 0x1732 <lcd_read+0x36>
    1732:	b4 99       	sbic	0x16, 4	; 22
    1734:	81 60       	ori	r24, 0x01	; 1
    1736:	b5 99       	sbic	0x16, 5	; 22
    1738:	82 60       	ori	r24, 0x02	; 2
    173a:	b6 99       	sbic	0x16, 6	; 22
    173c:	84 60       	ori	r24, 0x04	; 4
    173e:	b7 99       	sbic	0x16, 7	; 22
    1740:	88 60       	ori	r24, 0x08	; 8
    1742:	1c 98       	cbi	0x03, 4	; 3
    1744:	08 95       	ret

00001746 <lcd_waitbusy>:
    1746:	80 e0       	ldi	r24, 0x00	; 0
    1748:	d9 df       	rcall	.-78     	; 0x16fc <lcd_read>
    174a:	88 23       	and	r24, r24
    174c:	e4 f3       	brlt	.-8      	; 0x1746 <lcd_waitbusy>
    174e:	88 e0       	ldi	r24, 0x08	; 8
    1750:	90 e0       	ldi	r25, 0x00	; 0
    1752:	01 97       	sbiw	r24, 0x01	; 1
    1754:	f1 f7       	brne	.-4      	; 0x1752 <lcd_waitbusy+0xc>
    1756:	80 e0       	ldi	r24, 0x00	; 0
    1758:	d1 cf       	rjmp	.-94     	; 0x16fc <lcd_read>
    175a:	08 95       	ret

0000175c <lcd_command>:
    175c:	cf 93       	push	r28
    175e:	c8 2f       	mov	r28, r24
    1760:	f2 df       	rcall	.-28     	; 0x1746 <lcd_waitbusy>
    1762:	60 e0       	ldi	r22, 0x00	; 0
    1764:	8c 2f       	mov	r24, r28
    1766:	9d df       	rcall	.-198    	; 0x16a2 <lcd_write>
    1768:	cf 91       	pop	r28
    176a:	08 95       	ret

0000176c <lcd_gotoxy>:
    176c:	61 11       	cpse	r22, r1
    176e:	03 c0       	rjmp	.+6      	; 0x1776 <lcd_gotoxy+0xa>
    1770:	80 58       	subi	r24, 0x80	; 128
    1772:	f4 cf       	rjmp	.-24     	; 0x175c <lcd_command>
    1774:	08 95       	ret
    1776:	61 30       	cpi	r22, 0x01	; 1
    1778:	19 f4       	brne	.+6      	; 0x1780 <lcd_gotoxy+0x14>
    177a:	80 56       	subi	r24, 0x60	; 96
    177c:	ef cf       	rjmp	.-34     	; 0x175c <lcd_command>
    177e:	08 95       	ret
    1780:	62 30       	cpi	r22, 0x02	; 2
    1782:	19 f4       	brne	.+6      	; 0x178a <lcd_gotoxy+0x1e>
    1784:	80 54       	subi	r24, 0x40	; 64
    1786:	ea cf       	rjmp	.-44     	; 0x175c <lcd_command>
    1788:	08 95       	ret
    178a:	80 52       	subi	r24, 0x20	; 32
    178c:	e7 cf       	rjmp	.-50     	; 0x175c <lcd_command>
    178e:	08 95       	ret

00001790 <lcd_clrscr>:
/*************************************************************************
Clear display and set cursor to home position
*************************************************************************/
void lcd_clrscr(void)
{
    lcd_command(1<<LCD_CLR);
    1790:	81 e0       	ldi	r24, 0x01	; 1
    1792:	e4 cf       	rjmp	.-56     	; 0x175c <lcd_command>
    1794:	08 95       	ret

00001796 <lcd_home>:
/*************************************************************************
Set cursor to home position
*************************************************************************/
void lcd_home(void)
{
    lcd_command(1<<LCD_HOME);
    1796:	82 e0       	ldi	r24, 0x02	; 2
    1798:	e1 cf       	rjmp	.-62     	; 0x175c <lcd_command>
    179a:	08 95       	ret

0000179c <lcd_putc>:
Display character at current cursor position 
Input:    character to be displayed                                       
Returns:  none
*************************************************************************/
void lcd_putc(char c)
{
    179c:	cf 93       	push	r28
    179e:	c8 2f       	mov	r28, r24
    uint8_t pos;


    pos = lcd_waitbusy();   // read busy-flag and address counter
    17a0:	d2 df       	rcall	.-92     	; 0x1746 <lcd_waitbusy>
    if (c=='\n')
    17a2:	ca 30       	cpi	r28, 0x0A	; 10
    17a4:	99 f4       	brne	.+38     	; 0x17cc <lcd_putc+0x30>
    else
        addressCounter = LCD_START_LINE1;
#endif
#if LCD_LINES==4
#if KS0073_4LINES_MODE
    if ( pos < LCD_START_LINE2 )
    17a6:	80 32       	cpi	r24, 0x20	; 32
    17a8:	48 f0       	brcs	.+18     	; 0x17bc <lcd_putc+0x20>
        addressCounter = LCD_START_LINE2;
    else if ( (pos >= LCD_START_LINE2) && (pos < LCD_START_LINE3) )
    17aa:	90 ee       	ldi	r25, 0xE0	; 224
    17ac:	98 0f       	add	r25, r24
    17ae:	90 32       	cpi	r25, 0x20	; 32
    17b0:	38 f0       	brcs	.+14     	; 0x17c0 <lcd_putc+0x24>
        addressCounter = LCD_START_LINE3;
    else if ( (pos >= LCD_START_LINE3) && (pos < LCD_START_LINE4) )
    17b2:	80 54       	subi	r24, 0x40	; 64
    17b4:	80 32       	cpi	r24, 0x20	; 32
    17b6:	30 f0       	brcs	.+12     	; 0x17c4 <lcd_putc+0x28>
        addressCounter = LCD_START_LINE4;
    else 
        addressCounter = LCD_START_LINE1;
    17b8:	80 e0       	ldi	r24, 0x00	; 0
    17ba:	05 c0       	rjmp	.+10     	; 0x17c6 <lcd_putc+0x2a>
        addressCounter = LCD_START_LINE1;
#endif
#if LCD_LINES==4
#if KS0073_4LINES_MODE
    if ( pos < LCD_START_LINE2 )
        addressCounter = LCD_START_LINE2;
    17bc:	80 e2       	ldi	r24, 0x20	; 32
    17be:	03 c0       	rjmp	.+6      	; 0x17c6 <lcd_putc+0x2a>
    else if ( (pos >= LCD_START_LINE2) && (pos < LCD_START_LINE3) )
        addressCounter = LCD_START_LINE3;
    17c0:	80 e4       	ldi	r24, 0x40	; 64
    17c2:	01 c0       	rjmp	.+2      	; 0x17c6 <lcd_putc+0x2a>
    else if ( (pos >= LCD_START_LINE3) && (pos < LCD_START_LINE4) )
        addressCounter = LCD_START_LINE4;
    17c4:	80 e6       	ldi	r24, 0x60	; 96
        addressCounter = LCD_START_LINE4;
    else 
        addressCounter = LCD_START_LINE1;
#endif
#endif
    lcd_command((1<<LCD_DDRAM)+addressCounter);
    17c6:	80 58       	subi	r24, 0x80	; 128
    17c8:	c9 df       	rcall	.-110    	; 0x175c <lcd_command>
    17ca:	03 c0       	rjmp	.+6      	; 0x17d2 <lcd_putc+0x36>
            lcd_write((1<<LCD_DDRAM)+LCD_START_LINE1,0);
        }
#endif
        lcd_waitbusy();
#endif
        lcd_write(c, 1);
    17cc:	61 e0       	ldi	r22, 0x01	; 1
    17ce:	8c 2f       	mov	r24, r28
    17d0:	68 df       	rcall	.-304    	; 0x16a2 <lcd_write>
    }

}/* lcd_putc */
    17d2:	cf 91       	pop	r28
    17d4:	08 95       	ret

000017d6 <lcd_puts>:
Input:    string to be displayed
Returns:  none
*************************************************************************/
void lcd_puts(const char *s)
/* print string on lcd (no auto linefeed) */
{
    17d6:	cf 93       	push	r28
    17d8:	df 93       	push	r29
    register char c;

    while ( (c = *s++) ) {
    17da:	ec 01       	movw	r28, r24
    17dc:	21 96       	adiw	r28, 0x01	; 1
    17de:	fc 01       	movw	r30, r24
    17e0:	80 81       	ld	r24, Z
    17e2:	88 23       	and	r24, r24
    17e4:	21 f0       	breq	.+8      	; 0x17ee <lcd_puts+0x18>
        lcd_putc(c);
    17e6:	da df       	rcall	.-76     	; 0x179c <lcd_putc>
void lcd_puts(const char *s)
/* print string on lcd (no auto linefeed) */
{
    register char c;

    while ( (c = *s++) ) {
    17e8:	89 91       	ld	r24, Y+
    17ea:	81 11       	cpse	r24, r1
    17ec:	fc cf       	rjmp	.-8      	; 0x17e6 <lcd_puts+0x10>
        lcd_putc(c);
    }

}/* lcd_puts */
    17ee:	df 91       	pop	r29
    17f0:	cf 91       	pop	r28
    17f2:	08 95       	ret

000017f4 <lcd_puts_p>:
Input:     string from program memory be be displayed                                        
Returns:   none
*************************************************************************/
void lcd_puts_p(const char *progmem_s)
/* print string from program memory on lcd (no auto linefeed) */
{
    17f4:	cf 93       	push	r28
    17f6:	df 93       	push	r29
    register char c;

    while ( (c = pgm_read_byte(progmem_s++)) ) {
    17f8:	ec 01       	movw	r28, r24
    17fa:	21 96       	adiw	r28, 0x01	; 1
    17fc:	fc 01       	movw	r30, r24
    17fe:	84 91       	lpm	r24, Z
    1800:	88 23       	and	r24, r24
    1802:	31 f0       	breq	.+12     	; 0x1810 <lcd_puts_p+0x1c>
        lcd_putc(c);
    1804:	cb df       	rcall	.-106    	; 0x179c <lcd_putc>
void lcd_puts_p(const char *progmem_s)
/* print string from program memory on lcd (no auto linefeed) */
{
    register char c;

    while ( (c = pgm_read_byte(progmem_s++)) ) {
    1806:	fe 01       	movw	r30, r28
    1808:	84 91       	lpm	r24, Z
    180a:	21 96       	adiw	r28, 0x01	; 1
    180c:	81 11       	cpse	r24, r1
    180e:	fa cf       	rjmp	.-12     	; 0x1804 <lcd_puts_p+0x10>
        lcd_putc(c);
    }

}/* lcd_puts_p */
    1810:	df 91       	pop	r29
    1812:	cf 91       	pop	r28
    1814:	08 95       	ret

00001816 <lcd_init>:
                   LCD_DISP_ON_CURSOR      display on, cursor on
                   LCD_DISP_CURSOR_BLINK   display on, cursor on flashing
Returns:  none
*************************************************************************/
void lcd_init(uint8_t dispAttr)
{
    1816:	1f 93       	push	r17
    1818:	cf 93       	push	r28
    181a:	df 93       	push	r29
    181c:	18 2f       	mov	r17, r24
        DDR(LCD_E_PORT)     |= _BV(LCD_E_PIN);
    }
    else
    {
        /* configure all port bits as output (LCD data and control lines on different ports */
        DDR(LCD_RS_PORT)    |= _BV(LCD_RS_PIN);
    181e:	12 9a       	sbi	0x02, 2	; 2
        DDR(LCD_RW_PORT)    |= _BV(LCD_RW_PIN);
    1820:	13 9a       	sbi	0x02, 3	; 2
        DDR(LCD_E_PORT)     |= _BV(LCD_E_PIN);
    1822:	14 9a       	sbi	0x02, 4	; 2
        DDR(LCD_DATA0_PORT) |= _BV(LCD_DATA0_PIN);
    1824:	bc 9a       	sbi	0x17, 4	; 23
        DDR(LCD_DATA1_PORT) |= _BV(LCD_DATA1_PIN);
    1826:	bd 9a       	sbi	0x17, 5	; 23
        DDR(LCD_DATA2_PORT) |= _BV(LCD_DATA2_PIN);
    1828:	be 9a       	sbi	0x17, 6	; 23
        DDR(LCD_DATA3_PORT) |= _BV(LCD_DATA3_PIN);
    182a:	bf 9a       	sbi	0x17, 7	; 23
static inline void _delayFourCycles(unsigned int __count)
{
    if ( __count == 0 )    
        __asm__ __volatile__( "rjmp 1f\n 1:" );    // 2 cycles
    else
        __asm__ __volatile__ (
    182c:	80 e0       	ldi	r24, 0x00	; 0
    182e:	9a ef       	ldi	r25, 0xFA	; 250
    1830:	01 97       	sbiw	r24, 0x01	; 1
    1832:	f1 f7       	brne	.-4      	; 0x1830 <lcd_init+0x1a>
        DDR(LCD_DATA3_PORT) |= _BV(LCD_DATA3_PIN);
    }
    delay(16000);        /* wait 16ms or more after power-on       */
    
    /* initial write to lcd is 8bit */
    LCD_DATA1_PORT |= _BV(LCD_DATA1_PIN);  // _BV(LCD_FUNCTION)>>4;
    1834:	c5 9a       	sbi	0x18, 5	; 24
    LCD_DATA0_PORT |= _BV(LCD_DATA0_PIN);  // _BV(LCD_FUNCTION_8BIT)>>4;
    1836:	c4 9a       	sbi	0x18, 4	; 24
    lcd_e_toggle();
    1838:	30 df       	rcall	.-416    	; 0x169a <toggle_e>
static inline void _delayFourCycles(unsigned int __count)
{
    if ( __count == 0 )    
        __asm__ __volatile__( "rjmp 1f\n 1:" );    // 2 cycles
    else
        __asm__ __volatile__ (
    183a:	80 e0       	ldi	r24, 0x00	; 0
    183c:	9e e4       	ldi	r25, 0x4E	; 78
    183e:	01 97       	sbiw	r24, 0x01	; 1
    LCD_DATA0_PORT |= _BV(LCD_DATA0_PIN);  // _BV(LCD_FUNCTION_8BIT)>>4;
    lcd_e_toggle();
    delay(4992);         /* delay, busy flag can't be checked here */
   
    /* repeat last command */ 
    lcd_e_toggle();      
    1840:	f1 f7       	brne	.-4      	; 0x183e <lcd_init+0x28>
    1842:	2b df       	rcall	.-426    	; 0x169a <toggle_e>
static inline void _delayFourCycles(unsigned int __count)
{
    if ( __count == 0 )    
        __asm__ __volatile__( "rjmp 1f\n 1:" );    // 2 cycles
    else
        __asm__ __volatile__ (
    1844:	c0 e0       	ldi	r28, 0x00	; 0
    1846:	d1 e0       	ldi	r29, 0x01	; 1
    1848:	ce 01       	movw	r24, r28
    184a:	01 97       	sbiw	r24, 0x01	; 1
    /* repeat last command */ 
    lcd_e_toggle();      
    delay(64);           /* delay, busy flag can't be checked here */
    
    /* repeat last command a third time */
    lcd_e_toggle();      
    184c:	f1 f7       	brne	.-4      	; 0x184a <lcd_init+0x34>
    184e:	25 df       	rcall	.-438    	; 0x169a <toggle_e>
static inline void _delayFourCycles(unsigned int __count)
{
    if ( __count == 0 )    
        __asm__ __volatile__( "rjmp 1f\n 1:" );    // 2 cycles
    else
        __asm__ __volatile__ (
    1850:	ce 01       	movw	r24, r28
    1852:	01 97       	sbiw	r24, 0x01	; 1
    /* repeat last command a third time */
    lcd_e_toggle();      
    delay(64);           /* delay, busy flag can't be checked here */

    /* now configure for 4bit mode */
    LCD_DATA0_PORT &= ~_BV(LCD_DATA0_PIN);   // LCD_FUNCTION_4BIT_1LINE>>4
    1854:	f1 f7       	brne	.-4      	; 0x1852 <lcd_init+0x3c>
    lcd_e_toggle();
    1856:	c4 98       	cbi	0x18, 4	; 24
static inline void _delayFourCycles(unsigned int __count)
{
    if ( __count == 0 )    
        __asm__ __volatile__( "rjmp 1f\n 1:" );    // 2 cycles
    else
        __asm__ __volatile__ (
    1858:	20 df       	rcall	.-448    	; 0x169a <toggle_e>
    delay(64);                              /* wait 64us                    */
#endif

#if KS0073_4LINES_MODE
    /* Display with KS0073 controller requires special commands for enabling 4 line mode */
	lcd_command(KS0073_EXTENDED_FUNCTION_REGISTER_ON);
    185a:	21 97       	sbiw	r28, 0x01	; 1
    185c:	f1 f7       	brne	.-4      	; 0x185a <lcd_init+0x44>
	lcd_command(KS0073_4LINES_MODE);
    185e:	84 e2       	ldi	r24, 0x24	; 36
	lcd_command(KS0073_EXTENDED_FUNCTION_REGISTER_OFF);
    1860:	7d df       	rcall	.-262    	; 0x175c <lcd_command>
    1862:	89 e0       	ldi	r24, 0x09	; 9
#else
    lcd_command(LCD_FUNCTION_DEFAULT);      /* function set: display lines  */
#endif
    lcd_command(LCD_DISP_OFF);              /* display off                  */
    1864:	7b df       	rcall	.-266    	; 0x175c <lcd_command>
    1866:	80 e2       	ldi	r24, 0x20	; 32
    1868:	79 df       	rcall	.-270    	; 0x175c <lcd_command>
    lcd_clrscr();                           /* display clear                */ 
    186a:	88 e0       	ldi	r24, 0x08	; 8
    186c:	77 df       	rcall	.-274    	; 0x175c <lcd_command>
    lcd_command(LCD_MODE_DEFAULT);          /* set entry mode               */
    186e:	90 df       	rcall	.-224    	; 0x1790 <lcd_clrscr>
    1870:	86 e0       	ldi	r24, 0x06	; 6
    1872:	74 df       	rcall	.-280    	; 0x175c <lcd_command>
    lcd_command(dispAttr);                  /* display/cursor control       */
    1874:	81 2f       	mov	r24, r17
    1876:	72 df       	rcall	.-284    	; 0x175c <lcd_command>
    1878:	df 91       	pop	r29

}/* lcd_init */
    187a:	cf 91       	pop	r28
    187c:	1f 91       	pop	r17
    187e:	08 95       	ret

00001880 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    1880:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    1882:	03 96       	adiw	r24, 0x03	; 3
    1884:	92 83       	std	Z+2, r25	; 0x02
    1886:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1888:	2f ef       	ldi	r18, 0xFF	; 255
    188a:	3f ef       	ldi	r19, 0xFF	; 255
    188c:	34 83       	std	Z+4, r19	; 0x04
    188e:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    1890:	96 83       	std	Z+6, r25	; 0x06
    1892:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    1894:	90 87       	std	Z+8, r25	; 0x08
    1896:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = 0;
    1898:	10 82       	st	Z, r1
    189a:	08 95       	ret

0000189c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    189c:	fc 01       	movw	r30, r24
    189e:	11 86       	std	Z+9, r1	; 0x09
    18a0:	10 86       	std	Z+8, r1	; 0x08
    18a2:	08 95       	ret

000018a4 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    18a4:	cf 93       	push	r28
    18a6:	df 93       	push	r29
    18a8:	fc 01       	movw	r30, r24
    18aa:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    18ac:	21 81       	ldd	r18, Z+1	; 0x01
    18ae:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    18b0:	e9 01       	movw	r28, r18
    18b2:	8a 81       	ldd	r24, Y+2	; 0x02
    18b4:	9b 81       	ldd	r25, Y+3	; 0x03
    18b6:	13 96       	adiw	r26, 0x03	; 3
    18b8:	9c 93       	st	X, r25
    18ba:	8e 93       	st	-X, r24
    18bc:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
    18be:	81 81       	ldd	r24, Z+1	; 0x01
    18c0:	92 81       	ldd	r25, Z+2	; 0x02
    18c2:	15 96       	adiw	r26, 0x05	; 5
    18c4:	9c 93       	st	X, r25
    18c6:	8e 93       	st	-X, r24
    18c8:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    18ca:	8a 81       	ldd	r24, Y+2	; 0x02
    18cc:	9b 81       	ldd	r25, Y+3	; 0x03
    18ce:	ec 01       	movw	r28, r24
    18d0:	7d 83       	std	Y+5, r23	; 0x05
    18d2:	6c 83       	std	Y+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    18d4:	e9 01       	movw	r28, r18
    18d6:	7b 83       	std	Y+3, r23	; 0x03
    18d8:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    18da:	72 83       	std	Z+2, r23	; 0x02
    18dc:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    18de:	19 96       	adiw	r26, 0x09	; 9
    18e0:	fc 93       	st	X, r31
    18e2:	ee 93       	st	-X, r30
    18e4:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
    18e6:	80 81       	ld	r24, Z
    18e8:	8f 5f       	subi	r24, 0xFF	; 255
    18ea:	80 83       	st	Z, r24
}
    18ec:	df 91       	pop	r29
    18ee:	cf 91       	pop	r28
    18f0:	08 95       	ret

000018f2 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    18f2:	cf 93       	push	r28
    18f4:	df 93       	push	r29
    18f6:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    18f8:	48 81       	ld	r20, Y
    18fa:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as 
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the 
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    18fc:	4f 3f       	cpi	r20, 0xFF	; 255
    18fe:	2f ef       	ldi	r18, 0xFF	; 255
    1900:	52 07       	cpc	r21, r18
    1902:	31 f4       	brne	.+12     	; 0x1910 <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1904:	dc 01       	movw	r26, r24
    1906:	17 96       	adiw	r26, 0x07	; 7
    1908:	ed 91       	ld	r30, X+
    190a:	fc 91       	ld	r31, X
    190c:	18 97       	sbiw	r26, 0x08	; 8
    190e:	17 c0       	rjmp	.+46     	; 0x193e <vListInsert+0x4c>
	}
	else
	{
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    1910:	fc 01       	movw	r30, r24
    1912:	33 96       	adiw	r30, 0x03	; 3
    1914:	dc 01       	movw	r26, r24
    1916:	15 96       	adiw	r26, 0x05	; 5
    1918:	2d 91       	ld	r18, X+
    191a:	3c 91       	ld	r19, X
    191c:	16 97       	sbiw	r26, 0x06	; 6
    191e:	d9 01       	movw	r26, r18
    1920:	2d 91       	ld	r18, X+
    1922:	3c 91       	ld	r19, X
    1924:	42 17       	cp	r20, r18
    1926:	53 07       	cpc	r21, r19
    1928:	50 f0       	brcs	.+20     	; 0x193e <vListInsert+0x4c>
    192a:	02 80       	ldd	r0, Z+2	; 0x02
    192c:	f3 81       	ldd	r31, Z+3	; 0x03
    192e:	e0 2d       	mov	r30, r0
    1930:	a2 81       	ldd	r26, Z+2	; 0x02
    1932:	b3 81       	ldd	r27, Z+3	; 0x03
    1934:	2d 91       	ld	r18, X+
    1936:	3c 91       	ld	r19, X
    1938:	42 17       	cp	r20, r18
    193a:	53 07       	cpc	r21, r19
    193c:	b0 f7       	brcc	.-20     	; 0x192a <vListInsert+0x38>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    193e:	a2 81       	ldd	r26, Z+2	; 0x02
    1940:	b3 81       	ldd	r27, Z+3	; 0x03
    1942:	bb 83       	std	Y+3, r27	; 0x03
    1944:	aa 83       	std	Y+2, r26	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1946:	15 96       	adiw	r26, 0x05	; 5
    1948:	dc 93       	st	X, r29
    194a:	ce 93       	st	-X, r28
    194c:	14 97       	sbiw	r26, 0x04	; 4
	pxNewListItem->pxPrevious = pxIterator;
    194e:	fd 83       	std	Y+5, r31	; 0x05
    1950:	ec 83       	std	Y+4, r30	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    1952:	d3 83       	std	Z+3, r29	; 0x03
    1954:	c2 83       	std	Z+2, r28	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1956:	99 87       	std	Y+9, r25	; 0x09
    1958:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    195a:	fc 01       	movw	r30, r24
    195c:	20 81       	ld	r18, Z
    195e:	2f 5f       	subi	r18, 0xFF	; 255
    1960:	20 83       	st	Z, r18
}
    1962:	df 91       	pop	r29
    1964:	cf 91       	pop	r28
    1966:	08 95       	ret

00001968 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    1968:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    196a:	a2 81       	ldd	r26, Z+2	; 0x02
    196c:	b3 81       	ldd	r27, Z+3	; 0x03
    196e:	84 81       	ldd	r24, Z+4	; 0x04
    1970:	95 81       	ldd	r25, Z+5	; 0x05
    1972:	15 96       	adiw	r26, 0x05	; 5
    1974:	9c 93       	st	X, r25
    1976:	8e 93       	st	-X, r24
    1978:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    197a:	a4 81       	ldd	r26, Z+4	; 0x04
    197c:	b5 81       	ldd	r27, Z+5	; 0x05
    197e:	82 81       	ldd	r24, Z+2	; 0x02
    1980:	93 81       	ldd	r25, Z+3	; 0x03
    1982:	13 96       	adiw	r26, 0x03	; 3
    1984:	9c 93       	st	X, r25
    1986:	8e 93       	st	-X, r24
    1988:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    198a:	a0 85       	ldd	r26, Z+8	; 0x08
    198c:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    198e:	11 96       	adiw	r26, 0x01	; 1
    1990:	8d 91       	ld	r24, X+
    1992:	9c 91       	ld	r25, X
    1994:	12 97       	sbiw	r26, 0x02	; 2
    1996:	e8 17       	cp	r30, r24
    1998:	f9 07       	cpc	r31, r25
    199a:	31 f4       	brne	.+12     	; 0x19a8 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    199c:	84 81       	ldd	r24, Z+4	; 0x04
    199e:	95 81       	ldd	r25, Z+5	; 0x05
    19a0:	12 96       	adiw	r26, 0x02	; 2
    19a2:	9c 93       	st	X, r25
    19a4:	8e 93       	st	-X, r24
    19a6:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
    19a8:	11 86       	std	Z+9, r1	; 0x09
    19aa:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    19ac:	8c 91       	ld	r24, X
    19ae:	81 50       	subi	r24, 0x01	; 1
    19b0:	8c 93       	st	X, r24
    19b2:	08 95       	ret

000019b4 <vPID>:
// Modul includes
#include "global.h"
#include "PID.h"
//----------------------------------------------------------
void  vPID ( void * pvParameters)
{ float x = 0.0, yp = 0.0;
    19b4:	cf 93       	push	r28
    19b6:	df 93       	push	r29
    19b8:	cd b7       	in	r28, 0x3d	; 61
    19ba:	de b7       	in	r29, 0x3e	; 62
    19bc:	60 97       	sbiw	r28, 0x10	; 16
    19be:	0f b6       	in	r0, 0x3f	; 63
    19c0:	f8 94       	cli
    19c2:	de bf       	out	0x3e, r29	; 62
    19c4:	0f be       	out	0x3f, r0	; 63
    19c6:	cd bf       	out	0x3d, r28	; 61
    19c8:	19 82       	std	Y+1, r1	; 0x01
    19ca:	1a 82       	std	Y+2, r1	; 0x02
    19cc:	1b 82       	std	Y+3, r1	; 0x03
    19ce:	1c 82       	std	Y+4, r1	; 0x04
	// Place here your local parameters
	float ek1=0.0,ek, ek2=0.0,yc,TN,TV,Kpid,delt=0.02;
    19d0:	21 2c       	mov	r2, r1
    19d2:	31 2c       	mov	r3, r1
    19d4:	00 e0       	ldi	r16, 0x00	; 0
    19d6:	10 e0       	ldi	r17, 0x00	; 0
// Modul includes
#include "global.h"
#include "PID.h"
//----------------------------------------------------------
void  vPID ( void * pvParameters)
{ float x = 0.0, yp = 0.0;
    19d8:	41 2c       	mov	r4, r1
    19da:	51 2c       	mov	r5, r1
    19dc:	32 01       	movw	r6, r4
	float ek1=0.0,ek, ek2=0.0,yc,TN,TV,Kpid,delt=0.02;

  // Super loop of task
  while (1)
  { // Get position value from sensor queue
    xQueueReceive (QueueSensor, &x, portMAX_DELAY);
    19de:	20 e0       	ldi	r18, 0x00	; 0
    19e0:	4f ef       	ldi	r20, 0xFF	; 255
    19e2:	5f ef       	ldi	r21, 0xFF	; 255
    19e4:	be 01       	movw	r22, r28
    19e6:	6f 5f       	subi	r22, 0xFF	; 255
    19e8:	7f 4f       	sbci	r23, 0xFF	; 255
    19ea:	80 91 96 0a 	lds	r24, 0x0A96	; 0x800a96 <QueueSensor>
    19ee:	90 91 97 0a 	lds	r25, 0x0A97	; 0x800a97 <QueueSensor+0x1>
    19f2:	a3 d3       	rcall	.+1862   	; 0x213a <xQueueGenericReceive>
		Kpid=proportional;
    19f4:	80 90 a1 0a 	lds	r8, 0x0AA1	; 0x800aa1 <proportional>
    19f8:	90 90 a2 0a 	lds	r9, 0x0AA2	; 0x800aa2 <proportional+0x1>
    19fc:	a0 90 a3 0a 	lds	r10, 0x0AA3	; 0x800aa3 <proportional+0x2>
    1a00:	b0 90 a4 0a 	lds	r11, 0x0AA4	; 0x800aa4 <proportional+0x3>
		TN=Kpid/integral;
		TV=derivative/Kpid;
	
		ek=reference-x;
    1a04:	29 81       	ldd	r18, Y+1	; 0x01
    1a06:	3a 81       	ldd	r19, Y+2	; 0x02
    1a08:	4b 81       	ldd	r20, Y+3	; 0x03
    1a0a:	5c 81       	ldd	r21, Y+4	; 0x04
    1a0c:	60 91 88 0a 	lds	r22, 0x0A88	; 0x800a88 <reference>
    1a10:	70 91 89 0a 	lds	r23, 0x0A89	; 0x800a89 <reference+0x1>
    1a14:	80 91 8a 0a 	lds	r24, 0x0A8A	; 0x800a8a <reference+0x2>
    1a18:	90 91 8b 0a 	lds	r25, 0x0A8B	; 0x800a8b <reference+0x3>
    1a1c:	0e 94 92 17 	call	0x2f24	; 0x2f24 <__subsf3>
    1a20:	6d 87       	std	Y+13, r22	; 0x0d
    1a22:	7e 87       	std	Y+14, r23	; 0x0e
    1a24:	8f 87       	std	Y+15, r24	; 0x0f
    1a26:	98 8b       	std	Y+16, r25	; 0x10
	
		yc=yp+Kpid*(((1+(TV/delt))*ek)+(1-(delt/TN)+(2*(TV/delt))*ek1)+(TV/delt)*ek2);
    1a28:	a5 01       	movw	r20, r10
    1a2a:	94 01       	movw	r18, r8
    1a2c:	60 91 34 0a 	lds	r22, 0x0A34	; 0x800a34 <derivative>
    1a30:	70 91 35 0a 	lds	r23, 0x0A35	; 0x800a35 <derivative+0x1>
    1a34:	80 91 36 0a 	lds	r24, 0x0A36	; 0x800a36 <derivative+0x2>
    1a38:	90 91 37 0a 	lds	r25, 0x0A37	; 0x800a37 <derivative+0x3>
    1a3c:	0e 94 fb 17 	call	0x2ff6	; 0x2ff6 <__divsf3>
    1a40:	2a e0       	ldi	r18, 0x0A	; 10
    1a42:	37 ed       	ldi	r19, 0xD7	; 215
    1a44:	43 ea       	ldi	r20, 0xA3	; 163
    1a46:	5c e3       	ldi	r21, 0x3C	; 60
    1a48:	0e 94 fb 17 	call	0x2ff6	; 0x2ff6 <__divsf3>
    1a4c:	69 87       	std	Y+9, r22	; 0x09
    1a4e:	7a 87       	std	Y+10, r23	; 0x0a
    1a50:	8b 87       	std	Y+11, r24	; 0x0b
    1a52:	9c 87       	std	Y+12, r25	; 0x0c
    1a54:	20 91 ac 0a 	lds	r18, 0x0AAC	; 0x800aac <integral>
    1a58:	30 91 ad 0a 	lds	r19, 0x0AAD	; 0x800aad <integral+0x1>
    1a5c:	40 91 ae 0a 	lds	r20, 0x0AAE	; 0x800aae <integral+0x2>
    1a60:	50 91 af 0a 	lds	r21, 0x0AAF	; 0x800aaf <integral+0x3>
    1a64:	c5 01       	movw	r24, r10
    1a66:	b4 01       	movw	r22, r8
    1a68:	0e 94 fb 17 	call	0x2ff6	; 0x2ff6 <__divsf3>
    1a6c:	9b 01       	movw	r18, r22
    1a6e:	ac 01       	movw	r20, r24
    1a70:	6a e0       	ldi	r22, 0x0A	; 10
    1a72:	77 ed       	ldi	r23, 0xD7	; 215
    1a74:	83 ea       	ldi	r24, 0xA3	; 163
    1a76:	9c e3       	ldi	r25, 0x3C	; 60
    1a78:	0e 94 fb 17 	call	0x2ff6	; 0x2ff6 <__divsf3>
    1a7c:	9b 01       	movw	r18, r22
    1a7e:	ac 01       	movw	r20, r24
    1a80:	60 e0       	ldi	r22, 0x00	; 0
    1a82:	70 e0       	ldi	r23, 0x00	; 0
    1a84:	80 e8       	ldi	r24, 0x80	; 128
    1a86:	9f e3       	ldi	r25, 0x3F	; 63
    1a88:	0e 94 92 17 	call	0x2f24	; 0x2f24 <__subsf3>
    1a8c:	6b 01       	movw	r12, r22
    1a8e:	7c 01       	movw	r14, r24
    1a90:	29 85       	ldd	r18, Y+9	; 0x09
    1a92:	3a 85       	ldd	r19, Y+10	; 0x0a
    1a94:	4b 85       	ldd	r20, Y+11	; 0x0b
    1a96:	5c 85       	ldd	r21, Y+12	; 0x0c
    1a98:	ca 01       	movw	r24, r20
    1a9a:	b9 01       	movw	r22, r18
    1a9c:	0e 94 93 17 	call	0x2f26	; 0x2f26 <__addsf3>
    1aa0:	21 2f       	mov	r18, r17
    1aa2:	30 2f       	mov	r19, r16
    1aa4:	43 2d       	mov	r20, r3
    1aa6:	52 2d       	mov	r21, r2
    1aa8:	0e 94 4a 19 	call	0x3294	; 0x3294 <__mulsf3>
    1aac:	9b 01       	movw	r18, r22
    1aae:	ac 01       	movw	r20, r24
    1ab0:	c7 01       	movw	r24, r14
    1ab2:	b6 01       	movw	r22, r12
    1ab4:	0e 94 93 17 	call	0x2f26	; 0x2f26 <__addsf3>
    1ab8:	6b 01       	movw	r12, r22
    1aba:	7c 01       	movw	r14, r24
    1abc:	20 e0       	ldi	r18, 0x00	; 0
    1abe:	30 e0       	ldi	r19, 0x00	; 0
    1ac0:	40 e8       	ldi	r20, 0x80	; 128
    1ac2:	5f e3       	ldi	r21, 0x3F	; 63
    1ac4:	69 85       	ldd	r22, Y+9	; 0x09
    1ac6:	7a 85       	ldd	r23, Y+10	; 0x0a
    1ac8:	8b 85       	ldd	r24, Y+11	; 0x0b
    1aca:	9c 85       	ldd	r25, Y+12	; 0x0c
    1acc:	0e 94 93 17 	call	0x2f26	; 0x2f26 <__addsf3>
    1ad0:	2d 85       	ldd	r18, Y+13	; 0x0d
    1ad2:	3e 85       	ldd	r19, Y+14	; 0x0e
    1ad4:	4f 85       	ldd	r20, Y+15	; 0x0f
    1ad6:	58 89       	ldd	r21, Y+16	; 0x10
    1ad8:	0e 94 4a 19 	call	0x3294	; 0x3294 <__mulsf3>
    1adc:	9b 01       	movw	r18, r22
    1ade:	ac 01       	movw	r20, r24
    1ae0:	c7 01       	movw	r24, r14
    1ae2:	b6 01       	movw	r22, r12
    1ae4:	0e 94 93 17 	call	0x2f26	; 0x2f26 <__addsf3>
    1ae8:	6b 01       	movw	r12, r22
    1aea:	7c 01       	movw	r14, r24
    1aec:	29 85       	ldd	r18, Y+9	; 0x09
    1aee:	3a 85       	ldd	r19, Y+10	; 0x0a
    1af0:	4b 85       	ldd	r20, Y+11	; 0x0b
    1af2:	5c 85       	ldd	r21, Y+12	; 0x0c
    1af4:	61 2f       	mov	r22, r17
    1af6:	70 2f       	mov	r23, r16
    1af8:	83 2d       	mov	r24, r3
    1afa:	92 2d       	mov	r25, r2
    1afc:	0e 94 4a 19 	call	0x3294	; 0x3294 <__mulsf3>
    1b00:	9b 01       	movw	r18, r22
    1b02:	ac 01       	movw	r20, r24
    1b04:	c7 01       	movw	r24, r14
    1b06:	b6 01       	movw	r22, r12
    1b08:	0e 94 93 17 	call	0x2f26	; 0x2f26 <__addsf3>
    1b0c:	a5 01       	movw	r20, r10
    1b0e:	94 01       	movw	r18, r8
    1b10:	0e 94 4a 19 	call	0x3294	; 0x3294 <__mulsf3>
    1b14:	9b 01       	movw	r18, r22
    1b16:	ac 01       	movw	r20, r24
    1b18:	c3 01       	movw	r24, r6
    1b1a:	b2 01       	movw	r22, r4
    1b1c:	0e 94 93 17 	call	0x2f26	; 0x2f26 <__addsf3>
    1b20:	2b 01       	movw	r4, r22
    1b22:	3c 01       	movw	r6, r24
    1b24:	6d 83       	std	Y+5, r22	; 0x05
    1b26:	7e 83       	std	Y+6, r23	; 0x06
    1b28:	8f 83       	std	Y+7, r24	; 0x07
    1b2a:	98 87       	std	Y+8, r25	; 0x08
		// For example a simple P control startup formula  
	
		
		
		// Write angle value to servo queue
		xQueueSend (QueueServo, &yc, portMAX_DELAY);
    1b2c:	20 e0       	ldi	r18, 0x00	; 0
    1b2e:	4f ef       	ldi	r20, 0xFF	; 255
    1b30:	5f ef       	ldi	r21, 0xFF	; 255
    1b32:	be 01       	movw	r22, r28
    1b34:	6b 5f       	subi	r22, 0xFB	; 251
    1b36:	7f 4f       	sbci	r23, 0xFF	; 255
    1b38:	80 91 94 0a 	lds	r24, 0x0A94	; 0x800a94 <QueueServo>
    1b3c:	90 91 95 0a 	lds	r25, 0x0A95	; 0x800a95 <QueueServo+0x1>
    1b40:	4f d2       	rcall	.+1182   	; 0x1fe0 <xQueueGenericSend>
		TV=derivative/Kpid;
	
		ek=reference-x;
	
		yc=yp+Kpid*(((1+(TV/delt))*ek)+(1-(delt/TN)+(2*(TV/delt))*ek1)+(TV/delt)*ek2);
		ek1=ek;
    1b42:	1d 85       	ldd	r17, Y+13	; 0x0d
    1b44:	0e 85       	ldd	r16, Y+14	; 0x0e
    1b46:	3f 84       	ldd	r3, Y+15	; 0x0f
    1b48:	28 88       	ldd	r2, Y+16	; 0x10
    1b4a:	49 cf       	rjmp	.-366    	; 0x19de <vPID+0x2a>

00001b4c <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1b4c:	31 e1       	ldi	r19, 0x11	; 17
    1b4e:	fc 01       	movw	r30, r24
    1b50:	30 83       	st	Z, r19
    1b52:	31 97       	sbiw	r30, 0x01	; 1
    1b54:	22 e2       	ldi	r18, 0x22	; 34
    1b56:	20 83       	st	Z, r18
    1b58:	31 97       	sbiw	r30, 0x01	; 1
    1b5a:	a3 e3       	ldi	r26, 0x33	; 51
    1b5c:	a0 83       	st	Z, r26
    1b5e:	31 97       	sbiw	r30, 0x01	; 1
    1b60:	60 83       	st	Z, r22
    1b62:	31 97       	sbiw	r30, 0x01	; 1
    1b64:	70 83       	st	Z, r23
    1b66:	31 97       	sbiw	r30, 0x01	; 1
    1b68:	10 82       	st	Z, r1
    1b6a:	31 97       	sbiw	r30, 0x01	; 1
    1b6c:	60 e8       	ldi	r22, 0x80	; 128
    1b6e:	60 83       	st	Z, r22
    1b70:	31 97       	sbiw	r30, 0x01	; 1
    1b72:	10 82       	st	Z, r1
    1b74:	31 97       	sbiw	r30, 0x01	; 1
    1b76:	62 e0       	ldi	r22, 0x02	; 2
    1b78:	60 83       	st	Z, r22
    1b7a:	31 97       	sbiw	r30, 0x01	; 1
    1b7c:	63 e0       	ldi	r22, 0x03	; 3
    1b7e:	60 83       	st	Z, r22
    1b80:	31 97       	sbiw	r30, 0x01	; 1
    1b82:	64 e0       	ldi	r22, 0x04	; 4
    1b84:	60 83       	st	Z, r22
    1b86:	31 97       	sbiw	r30, 0x01	; 1
    1b88:	65 e0       	ldi	r22, 0x05	; 5
    1b8a:	60 83       	st	Z, r22
    1b8c:	31 97       	sbiw	r30, 0x01	; 1
    1b8e:	66 e0       	ldi	r22, 0x06	; 6
    1b90:	60 83       	st	Z, r22
    1b92:	31 97       	sbiw	r30, 0x01	; 1
    1b94:	67 e0       	ldi	r22, 0x07	; 7
    1b96:	60 83       	st	Z, r22
    1b98:	31 97       	sbiw	r30, 0x01	; 1
    1b9a:	68 e0       	ldi	r22, 0x08	; 8
    1b9c:	60 83       	st	Z, r22
    1b9e:	31 97       	sbiw	r30, 0x01	; 1
    1ba0:	69 e0       	ldi	r22, 0x09	; 9
    1ba2:	60 83       	st	Z, r22
    1ba4:	31 97       	sbiw	r30, 0x01	; 1
    1ba6:	60 e1       	ldi	r22, 0x10	; 16
    1ba8:	60 83       	st	Z, r22
    1baa:	31 97       	sbiw	r30, 0x01	; 1
    1bac:	30 83       	st	Z, r19
    1bae:	31 97       	sbiw	r30, 0x01	; 1
    1bb0:	32 e1       	ldi	r19, 0x12	; 18
    1bb2:	30 83       	st	Z, r19
    1bb4:	31 97       	sbiw	r30, 0x01	; 1
    1bb6:	33 e1       	ldi	r19, 0x13	; 19
    1bb8:	30 83       	st	Z, r19
    1bba:	31 97       	sbiw	r30, 0x01	; 1
    1bbc:	34 e1       	ldi	r19, 0x14	; 20
    1bbe:	30 83       	st	Z, r19
    1bc0:	31 97       	sbiw	r30, 0x01	; 1
    1bc2:	35 e1       	ldi	r19, 0x15	; 21
    1bc4:	30 83       	st	Z, r19
    1bc6:	31 97       	sbiw	r30, 0x01	; 1
    1bc8:	36 e1       	ldi	r19, 0x16	; 22
    1bca:	30 83       	st	Z, r19
    1bcc:	31 97       	sbiw	r30, 0x01	; 1
    1bce:	37 e1       	ldi	r19, 0x17	; 23
    1bd0:	30 83       	st	Z, r19
    1bd2:	31 97       	sbiw	r30, 0x01	; 1
    1bd4:	38 e1       	ldi	r19, 0x18	; 24
    1bd6:	30 83       	st	Z, r19
    1bd8:	31 97       	sbiw	r30, 0x01	; 1
    1bda:	39 e1       	ldi	r19, 0x19	; 25
    1bdc:	30 83       	st	Z, r19
    1bde:	31 97       	sbiw	r30, 0x01	; 1
    1be0:	30 e2       	ldi	r19, 0x20	; 32
    1be2:	30 83       	st	Z, r19
    1be4:	31 97       	sbiw	r30, 0x01	; 1
    1be6:	31 e2       	ldi	r19, 0x21	; 33
    1be8:	30 83       	st	Z, r19
    1bea:	31 97       	sbiw	r30, 0x01	; 1
    1bec:	20 83       	st	Z, r18
    1bee:	31 97       	sbiw	r30, 0x01	; 1
    1bf0:	23 e2       	ldi	r18, 0x23	; 35
    1bf2:	20 83       	st	Z, r18
    1bf4:	31 97       	sbiw	r30, 0x01	; 1
    1bf6:	40 83       	st	Z, r20
    1bf8:	31 97       	sbiw	r30, 0x01	; 1
    1bfa:	50 83       	st	Z, r21
    1bfc:	31 97       	sbiw	r30, 0x01	; 1
    1bfe:	26 e2       	ldi	r18, 0x26	; 38
    1c00:	20 83       	st	Z, r18
    1c02:	31 97       	sbiw	r30, 0x01	; 1
    1c04:	27 e2       	ldi	r18, 0x27	; 39
    1c06:	20 83       	st	Z, r18
    1c08:	31 97       	sbiw	r30, 0x01	; 1
    1c0a:	28 e2       	ldi	r18, 0x28	; 40
    1c0c:	20 83       	st	Z, r18
    1c0e:	31 97       	sbiw	r30, 0x01	; 1
    1c10:	29 e2       	ldi	r18, 0x29	; 41
    1c12:	20 83       	st	Z, r18
    1c14:	31 97       	sbiw	r30, 0x01	; 1
    1c16:	20 e3       	ldi	r18, 0x30	; 48
    1c18:	20 83       	st	Z, r18
    1c1a:	31 97       	sbiw	r30, 0x01	; 1
    1c1c:	21 e3       	ldi	r18, 0x31	; 49
    1c1e:	20 83       	st	Z, r18
    1c20:	86 97       	sbiw	r24, 0x26	; 38
    1c22:	08 95       	ret

00001c24 <xPortStartScheduler>:
    1c24:	82 e0       	ldi	r24, 0x02	; 2
    1c26:	8b bd       	out	0x2b, r24	; 43
    1c28:	8d ee       	ldi	r24, 0xED	; 237
    1c2a:	8a bd       	out	0x2a, r24	; 42
    1c2c:	8b e0       	ldi	r24, 0x0B	; 11
    1c2e:	8e bd       	out	0x2e, r24	; 46
    1c30:	87 b7       	in	r24, 0x37	; 55
    1c32:	80 61       	ori	r24, 0x10	; 16
    1c34:	87 bf       	out	0x37, r24	; 55
    1c36:	a0 91 31 0a 	lds	r26, 0x0A31	; 0x800a31 <pxCurrentTCB>
    1c3a:	b0 91 32 0a 	lds	r27, 0x0A32	; 0x800a32 <pxCurrentTCB+0x1>
    1c3e:	cd 91       	ld	r28, X+
    1c40:	cd bf       	out	0x3d, r28	; 61
    1c42:	dd 91       	ld	r29, X+
    1c44:	de bf       	out	0x3e, r29	; 62
    1c46:	ff 91       	pop	r31
    1c48:	ef 91       	pop	r30
    1c4a:	df 91       	pop	r29
    1c4c:	cf 91       	pop	r28
    1c4e:	bf 91       	pop	r27
    1c50:	af 91       	pop	r26
    1c52:	9f 91       	pop	r25
    1c54:	8f 91       	pop	r24
    1c56:	7f 91       	pop	r23
    1c58:	6f 91       	pop	r22
    1c5a:	5f 91       	pop	r21
    1c5c:	4f 91       	pop	r20
    1c5e:	3f 91       	pop	r19
    1c60:	2f 91       	pop	r18
    1c62:	1f 91       	pop	r17
    1c64:	0f 91       	pop	r16
    1c66:	ff 90       	pop	r15
    1c68:	ef 90       	pop	r14
    1c6a:	df 90       	pop	r13
    1c6c:	cf 90       	pop	r12
    1c6e:	bf 90       	pop	r11
    1c70:	af 90       	pop	r10
    1c72:	9f 90       	pop	r9
    1c74:	8f 90       	pop	r8
    1c76:	7f 90       	pop	r7
    1c78:	6f 90       	pop	r6
    1c7a:	5f 90       	pop	r5
    1c7c:	4f 90       	pop	r4
    1c7e:	3f 90       	pop	r3
    1c80:	2f 90       	pop	r2
    1c82:	1f 90       	pop	r1
    1c84:	0f 90       	pop	r0
    1c86:	0f be       	out	0x3f, r0	; 63
    1c88:	0f 90       	pop	r0
    1c8a:	08 95       	ret
    1c8c:	81 e0       	ldi	r24, 0x01	; 1
    1c8e:	08 95       	ret

00001c90 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1c90:	0f 92       	push	r0
    1c92:	0f b6       	in	r0, 0x3f	; 63
    1c94:	f8 94       	cli
    1c96:	0f 92       	push	r0
    1c98:	1f 92       	push	r1
    1c9a:	11 24       	eor	r1, r1
    1c9c:	2f 92       	push	r2
    1c9e:	3f 92       	push	r3
    1ca0:	4f 92       	push	r4
    1ca2:	5f 92       	push	r5
    1ca4:	6f 92       	push	r6
    1ca6:	7f 92       	push	r7
    1ca8:	8f 92       	push	r8
    1caa:	9f 92       	push	r9
    1cac:	af 92       	push	r10
    1cae:	bf 92       	push	r11
    1cb0:	cf 92       	push	r12
    1cb2:	df 92       	push	r13
    1cb4:	ef 92       	push	r14
    1cb6:	ff 92       	push	r15
    1cb8:	0f 93       	push	r16
    1cba:	1f 93       	push	r17
    1cbc:	2f 93       	push	r18
    1cbe:	3f 93       	push	r19
    1cc0:	4f 93       	push	r20
    1cc2:	5f 93       	push	r21
    1cc4:	6f 93       	push	r22
    1cc6:	7f 93       	push	r23
    1cc8:	8f 93       	push	r24
    1cca:	9f 93       	push	r25
    1ccc:	af 93       	push	r26
    1cce:	bf 93       	push	r27
    1cd0:	cf 93       	push	r28
    1cd2:	df 93       	push	r29
    1cd4:	ef 93       	push	r30
    1cd6:	ff 93       	push	r31
    1cd8:	a0 91 31 0a 	lds	r26, 0x0A31	; 0x800a31 <pxCurrentTCB>
    1cdc:	b0 91 32 0a 	lds	r27, 0x0A32	; 0x800a32 <pxCurrentTCB+0x1>
    1ce0:	0d b6       	in	r0, 0x3d	; 61
    1ce2:	0d 92       	st	X+, r0
    1ce4:	0e b6       	in	r0, 0x3e	; 62
    1ce6:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1ce8:	96 d7       	rcall	.+3884   	; 0x2c16 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1cea:	a0 91 31 0a 	lds	r26, 0x0A31	; 0x800a31 <pxCurrentTCB>
    1cee:	b0 91 32 0a 	lds	r27, 0x0A32	; 0x800a32 <pxCurrentTCB+0x1>
    1cf2:	cd 91       	ld	r28, X+
    1cf4:	cd bf       	out	0x3d, r28	; 61
    1cf6:	dd 91       	ld	r29, X+
    1cf8:	de bf       	out	0x3e, r29	; 62
    1cfa:	ff 91       	pop	r31
    1cfc:	ef 91       	pop	r30
    1cfe:	df 91       	pop	r29
    1d00:	cf 91       	pop	r28
    1d02:	bf 91       	pop	r27
    1d04:	af 91       	pop	r26
    1d06:	9f 91       	pop	r25
    1d08:	8f 91       	pop	r24
    1d0a:	7f 91       	pop	r23
    1d0c:	6f 91       	pop	r22
    1d0e:	5f 91       	pop	r21
    1d10:	4f 91       	pop	r20
    1d12:	3f 91       	pop	r19
    1d14:	2f 91       	pop	r18
    1d16:	1f 91       	pop	r17
    1d18:	0f 91       	pop	r16
    1d1a:	ff 90       	pop	r15
    1d1c:	ef 90       	pop	r14
    1d1e:	df 90       	pop	r13
    1d20:	cf 90       	pop	r12
    1d22:	bf 90       	pop	r11
    1d24:	af 90       	pop	r10
    1d26:	9f 90       	pop	r9
    1d28:	8f 90       	pop	r8
    1d2a:	7f 90       	pop	r7
    1d2c:	6f 90       	pop	r6
    1d2e:	5f 90       	pop	r5
    1d30:	4f 90       	pop	r4
    1d32:	3f 90       	pop	r3
    1d34:	2f 90       	pop	r2
    1d36:	1f 90       	pop	r1
    1d38:	0f 90       	pop	r0
    1d3a:	0f be       	out	0x3f, r0	; 63
    1d3c:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1d3e:	08 95       	ret

00001d40 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1d40:	0f 92       	push	r0
    1d42:	0f b6       	in	r0, 0x3f	; 63
    1d44:	f8 94       	cli
    1d46:	0f 92       	push	r0
    1d48:	1f 92       	push	r1
    1d4a:	11 24       	eor	r1, r1
    1d4c:	2f 92       	push	r2
    1d4e:	3f 92       	push	r3
    1d50:	4f 92       	push	r4
    1d52:	5f 92       	push	r5
    1d54:	6f 92       	push	r6
    1d56:	7f 92       	push	r7
    1d58:	8f 92       	push	r8
    1d5a:	9f 92       	push	r9
    1d5c:	af 92       	push	r10
    1d5e:	bf 92       	push	r11
    1d60:	cf 92       	push	r12
    1d62:	df 92       	push	r13
    1d64:	ef 92       	push	r14
    1d66:	ff 92       	push	r15
    1d68:	0f 93       	push	r16
    1d6a:	1f 93       	push	r17
    1d6c:	2f 93       	push	r18
    1d6e:	3f 93       	push	r19
    1d70:	4f 93       	push	r20
    1d72:	5f 93       	push	r21
    1d74:	6f 93       	push	r22
    1d76:	7f 93       	push	r23
    1d78:	8f 93       	push	r24
    1d7a:	9f 93       	push	r25
    1d7c:	af 93       	push	r26
    1d7e:	bf 93       	push	r27
    1d80:	cf 93       	push	r28
    1d82:	df 93       	push	r29
    1d84:	ef 93       	push	r30
    1d86:	ff 93       	push	r31
    1d88:	a0 91 31 0a 	lds	r26, 0x0A31	; 0x800a31 <pxCurrentTCB>
    1d8c:	b0 91 32 0a 	lds	r27, 0x0A32	; 0x800a32 <pxCurrentTCB+0x1>
    1d90:	0d b6       	in	r0, 0x3d	; 61
    1d92:	0d 92       	st	X+, r0
    1d94:	0e b6       	in	r0, 0x3e	; 62
    1d96:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    1d98:	f9 d5       	rcall	.+3058   	; 0x298c <vTaskIncrementTick>
	vTaskSwitchContext();
    1d9a:	3d d7       	rcall	.+3706   	; 0x2c16 <vTaskSwitchContext>
    1d9c:	a0 91 31 0a 	lds	r26, 0x0A31	; 0x800a31 <pxCurrentTCB>
	portRESTORE_CONTEXT();
    1da0:	b0 91 32 0a 	lds	r27, 0x0A32	; 0x800a32 <pxCurrentTCB+0x1>
    1da4:	cd 91       	ld	r28, X+
    1da6:	cd bf       	out	0x3d, r28	; 61
    1da8:	dd 91       	ld	r29, X+
    1daa:	de bf       	out	0x3e, r29	; 62
    1dac:	ff 91       	pop	r31
    1dae:	ef 91       	pop	r30
    1db0:	df 91       	pop	r29
    1db2:	cf 91       	pop	r28
    1db4:	bf 91       	pop	r27
    1db6:	af 91       	pop	r26
    1db8:	9f 91       	pop	r25
    1dba:	8f 91       	pop	r24
    1dbc:	7f 91       	pop	r23
    1dbe:	6f 91       	pop	r22
    1dc0:	5f 91       	pop	r21
    1dc2:	4f 91       	pop	r20
    1dc4:	3f 91       	pop	r19
    1dc6:	2f 91       	pop	r18
    1dc8:	1f 91       	pop	r17
    1dca:	0f 91       	pop	r16
    1dcc:	ff 90       	pop	r15
    1dce:	ef 90       	pop	r14
    1dd0:	df 90       	pop	r13
    1dd2:	cf 90       	pop	r12
    1dd4:	bf 90       	pop	r11
    1dd6:	af 90       	pop	r10
    1dd8:	9f 90       	pop	r9
    1dda:	8f 90       	pop	r8
    1ddc:	7f 90       	pop	r7
    1dde:	6f 90       	pop	r6
    1de0:	5f 90       	pop	r5
    1de2:	4f 90       	pop	r4
    1de4:	3f 90       	pop	r3
    1de6:	2f 90       	pop	r2
    1de8:	1f 90       	pop	r1
    1dea:	0f 90       	pop	r0
    1dec:	0f be       	out	0x3f, r0	; 63
    1dee:	0f 90       	pop	r0
    1df0:	08 95       	ret

00001df2 <__vector_12>:

	asm volatile ( "ret" );
    1df2:	a6 df       	rcall	.-180    	; 0x1d40 <vPortYieldFromTick>
	//void SIG_OUTPUT_COMPARE1A( void )
	ISR(TIMER1_COMPA_vect) __attribute__ ( ( signal, naked ) );
	ISR(TIMER1_COMPA_vect)
	{
        vPortYieldFromTick();
        asm volatile ( "reti" );
    1df4:	18 95       	reti

00001df6 <prvUnlockQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1df6:	0f 93       	push	r16
    1df8:	1f 93       	push	r17
    1dfa:	cf 93       	push	r28
    1dfc:	df 93       	push	r29
    1dfe:	ec 01       	movw	r28, r24
    1e00:	0f b6       	in	r0, 0x3f	; 63
    1e02:	f8 94       	cli
    1e04:	0f 92       	push	r0
    1e06:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1e08:	18 16       	cp	r1, r24
    1e0a:	ac f4       	brge	.+42     	; 0x1e36 <prvUnlockQueue+0x40>
    1e0c:	89 89       	ldd	r24, Y+17	; 0x11
    1e0e:	81 11       	cpse	r24, r1
    1e10:	05 c0       	rjmp	.+10     	; 0x1e1c <prvUnlockQueue+0x26>
    1e12:	11 c0       	rjmp	.+34     	; 0x1e36 <prvUnlockQueue+0x40>
    1e14:	89 89       	ldd	r24, Y+17	; 0x11
    1e16:	81 11       	cpse	r24, r1
    1e18:	04 c0       	rjmp	.+8      	; 0x1e22 <prvUnlockQueue+0x2c>
    1e1a:	0d c0       	rjmp	.+26     	; 0x1e36 <prvUnlockQueue+0x40>
    1e1c:	8e 01       	movw	r16, r28
    1e1e:	0f 5e       	subi	r16, 0xEF	; 239
    1e20:	1f 4f       	sbci	r17, 0xFF	; 255
    1e22:	c8 01       	movw	r24, r16
    1e24:	e7 d7       	rcall	.+4046   	; 0x2df4 <xTaskRemoveFromEventList>
    1e26:	81 11       	cpse	r24, r1
    1e28:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <vTaskMissedYield>
    1e2c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1e2e:	81 50       	subi	r24, 0x01	; 1
    1e30:	8e 8f       	std	Y+30, r24	; 0x1e
    1e32:	18 16       	cp	r1, r24
    1e34:	7c f3       	brlt	.-34     	; 0x1e14 <prvUnlockQueue+0x1e>
    1e36:	8f ef       	ldi	r24, 0xFF	; 255
    1e38:	8e 8f       	std	Y+30, r24	; 0x1e
    1e3a:	0f 90       	pop	r0
    1e3c:	0f be       	out	0x3f, r0	; 63
    1e3e:	0f b6       	in	r0, 0x3f	; 63
    1e40:	f8 94       	cli
    1e42:	0f 92       	push	r0
    1e44:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1e46:	18 16       	cp	r1, r24
    1e48:	ac f4       	brge	.+42     	; 0x1e74 <prvUnlockQueue+0x7e>
    1e4a:	88 85       	ldd	r24, Y+8	; 0x08
    1e4c:	81 11       	cpse	r24, r1
    1e4e:	05 c0       	rjmp	.+10     	; 0x1e5a <prvUnlockQueue+0x64>
    1e50:	11 c0       	rjmp	.+34     	; 0x1e74 <prvUnlockQueue+0x7e>
    1e52:	88 85       	ldd	r24, Y+8	; 0x08
    1e54:	81 11       	cpse	r24, r1
    1e56:	04 c0       	rjmp	.+8      	; 0x1e60 <prvUnlockQueue+0x6a>
    1e58:	0d c0       	rjmp	.+26     	; 0x1e74 <prvUnlockQueue+0x7e>
    1e5a:	8e 01       	movw	r16, r28
    1e5c:	08 5f       	subi	r16, 0xF8	; 248
    1e5e:	1f 4f       	sbci	r17, 0xFF	; 255
    1e60:	c8 01       	movw	r24, r16
    1e62:	c8 d7       	rcall	.+3984   	; 0x2df4 <xTaskRemoveFromEventList>
    1e64:	81 11       	cpse	r24, r1
    1e66:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <vTaskMissedYield>
    1e6a:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1e6c:	81 50       	subi	r24, 0x01	; 1
    1e6e:	8d 8f       	std	Y+29, r24	; 0x1d
    1e70:	18 16       	cp	r1, r24
    1e72:	7c f3       	brlt	.-34     	; 0x1e52 <prvUnlockQueue+0x5c>
    1e74:	8f ef       	ldi	r24, 0xFF	; 255
    1e76:	8d 8f       	std	Y+29, r24	; 0x1d
    1e78:	0f 90       	pop	r0
    1e7a:	0f be       	out	0x3f, r0	; 63
    1e7c:	df 91       	pop	r29
    1e7e:	cf 91       	pop	r28
    1e80:	1f 91       	pop	r17
    1e82:	0f 91       	pop	r16
    1e84:	08 95       	ret

00001e86 <prvCopyDataToQueue>:
    1e86:	cf 93       	push	r28
    1e88:	df 93       	push	r29
    1e8a:	ec 01       	movw	r28, r24
    1e8c:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1e8e:	88 23       	and	r24, r24
    1e90:	a9 f1       	breq	.+106    	; 0x1efc <prvCopyDataToQueue+0x76>
    1e92:	41 11       	cpse	r20, r1
    1e94:	17 c0       	rjmp	.+46     	; 0x1ec4 <prvCopyDataToQueue+0x3e>
    1e96:	48 2f       	mov	r20, r24
    1e98:	50 e0       	ldi	r21, 0x00	; 0
    1e9a:	8c 81       	ldd	r24, Y+4	; 0x04
    1e9c:	9d 81       	ldd	r25, Y+5	; 0x05
    1e9e:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <memcpy>
    1ea2:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1ea4:	8c 81       	ldd	r24, Y+4	; 0x04
    1ea6:	9d 81       	ldd	r25, Y+5	; 0x05
    1ea8:	82 0f       	add	r24, r18
    1eaa:	91 1d       	adc	r25, r1
    1eac:	9d 83       	std	Y+5, r25	; 0x05
    1eae:	8c 83       	std	Y+4, r24	; 0x04
    1eb0:	2a 81       	ldd	r18, Y+2	; 0x02
    1eb2:	3b 81       	ldd	r19, Y+3	; 0x03
    1eb4:	82 17       	cp	r24, r18
    1eb6:	93 07       	cpc	r25, r19
    1eb8:	08 f1       	brcs	.+66     	; 0x1efc <prvCopyDataToQueue+0x76>
    1eba:	88 81       	ld	r24, Y
    1ebc:	99 81       	ldd	r25, Y+1	; 0x01
    1ebe:	9d 83       	std	Y+5, r25	; 0x05
    1ec0:	8c 83       	std	Y+4, r24	; 0x04
    1ec2:	1c c0       	rjmp	.+56     	; 0x1efc <prvCopyDataToQueue+0x76>
    1ec4:	48 2f       	mov	r20, r24
    1ec6:	50 e0       	ldi	r21, 0x00	; 0
    1ec8:	8e 81       	ldd	r24, Y+6	; 0x06
    1eca:	9f 81       	ldd	r25, Y+7	; 0x07
    1ecc:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <memcpy>
    1ed0:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1ed2:	90 e0       	ldi	r25, 0x00	; 0
    1ed4:	91 95       	neg	r25
    1ed6:	81 95       	neg	r24
    1ed8:	91 09       	sbc	r25, r1
    1eda:	2e 81       	ldd	r18, Y+6	; 0x06
    1edc:	3f 81       	ldd	r19, Y+7	; 0x07
    1ede:	28 0f       	add	r18, r24
    1ee0:	39 1f       	adc	r19, r25
    1ee2:	3f 83       	std	Y+7, r19	; 0x07
    1ee4:	2e 83       	std	Y+6, r18	; 0x06
    1ee6:	48 81       	ld	r20, Y
    1ee8:	59 81       	ldd	r21, Y+1	; 0x01
    1eea:	24 17       	cp	r18, r20
    1eec:	35 07       	cpc	r19, r21
    1eee:	30 f4       	brcc	.+12     	; 0x1efc <prvCopyDataToQueue+0x76>
    1ef0:	2a 81       	ldd	r18, Y+2	; 0x02
    1ef2:	3b 81       	ldd	r19, Y+3	; 0x03
    1ef4:	82 0f       	add	r24, r18
    1ef6:	93 1f       	adc	r25, r19
    1ef8:	9f 83       	std	Y+7, r25	; 0x07
    1efa:	8e 83       	std	Y+6, r24	; 0x06
    1efc:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1efe:	8f 5f       	subi	r24, 0xFF	; 255
    1f00:	8a 8f       	std	Y+26, r24	; 0x1a
    1f02:	df 91       	pop	r29
    1f04:	cf 91       	pop	r28
    1f06:	08 95       	ret

00001f08 <prvCopyDataFromQueue>:
    1f08:	fc 01       	movw	r30, r24
    1f0a:	80 81       	ld	r24, Z
    1f0c:	91 81       	ldd	r25, Z+1	; 0x01
    1f0e:	00 97       	sbiw	r24, 0x00	; 0
    1f10:	a1 f0       	breq	.+40     	; 0x1f3a <prvCopyDataFromQueue+0x32>
    1f12:	44 8d       	ldd	r20, Z+28	; 0x1c
    1f14:	50 e0       	ldi	r21, 0x00	; 0
    1f16:	26 81       	ldd	r18, Z+6	; 0x06
    1f18:	37 81       	ldd	r19, Z+7	; 0x07
    1f1a:	24 0f       	add	r18, r20
    1f1c:	35 1f       	adc	r19, r21
    1f1e:	37 83       	std	Z+7, r19	; 0x07
    1f20:	26 83       	std	Z+6, r18	; 0x06
    1f22:	a2 81       	ldd	r26, Z+2	; 0x02
    1f24:	b3 81       	ldd	r27, Z+3	; 0x03
    1f26:	2a 17       	cp	r18, r26
    1f28:	3b 07       	cpc	r19, r27
    1f2a:	10 f0       	brcs	.+4      	; 0x1f30 <prvCopyDataFromQueue+0x28>
    1f2c:	97 83       	std	Z+7, r25	; 0x07
    1f2e:	86 83       	std	Z+6, r24	; 0x06
    1f30:	cb 01       	movw	r24, r22
    1f32:	66 81       	ldd	r22, Z+6	; 0x06
    1f34:	77 81       	ldd	r23, Z+7	; 0x07
    1f36:	0c 94 e1 19 	jmp	0x33c2	; 0x33c2 <memcpy>
    1f3a:	08 95       	ret

00001f3c <xQueueCreate>:
    1f3c:	cf 92       	push	r12
    1f3e:	df 92       	push	r13
    1f40:	ef 92       	push	r14
    1f42:	ff 92       	push	r15
    1f44:	0f 93       	push	r16
    1f46:	1f 93       	push	r17
    1f48:	cf 93       	push	r28
    1f4a:	df 93       	push	r29
    1f4c:	88 23       	and	r24, r24
    1f4e:	d1 f1       	breq	.+116    	; 0x1fc4 <xQueueCreate+0x88>
    1f50:	e6 2e       	mov	r14, r22
    1f52:	f8 2e       	mov	r15, r24
    1f54:	8f e1       	ldi	r24, 0x1F	; 31
    1f56:	90 e0       	ldi	r25, 0x00	; 0
    1f58:	0e 94 9a 02 	call	0x534	; 0x534 <pvPortMalloc>
    1f5c:	ec 01       	movw	r28, r24
    1f5e:	89 2b       	or	r24, r25
    1f60:	a1 f1       	breq	.+104    	; 0x1fca <xQueueCreate+0x8e>
    1f62:	ce 2c       	mov	r12, r14
    1f64:	d1 2c       	mov	r13, r1
    1f66:	fc 9c       	mul	r15, r12
    1f68:	80 01       	movw	r16, r0
    1f6a:	fd 9c       	mul	r15, r13
    1f6c:	10 0d       	add	r17, r0
    1f6e:	11 24       	eor	r1, r1
    1f70:	c8 01       	movw	r24, r16
    1f72:	01 96       	adiw	r24, 0x01	; 1
    1f74:	0e 94 9a 02 	call	0x534	; 0x534 <pvPortMalloc>
    1f78:	99 83       	std	Y+1, r25	; 0x01
    1f7a:	88 83       	st	Y, r24
    1f7c:	00 97       	sbiw	r24, 0x00	; 0
    1f7e:	e1 f0       	breq	.+56     	; 0x1fb8 <xQueueCreate+0x7c>
    1f80:	9c 01       	movw	r18, r24
    1f82:	20 0f       	add	r18, r16
    1f84:	31 1f       	adc	r19, r17
    1f86:	3b 83       	std	Y+3, r19	; 0x03
    1f88:	2a 83       	std	Y+2, r18	; 0x02
    1f8a:	1a 8e       	std	Y+26, r1	; 0x1a
    1f8c:	9d 83       	std	Y+5, r25	; 0x05
    1f8e:	8c 83       	std	Y+4, r24	; 0x04
    1f90:	0c 19       	sub	r16, r12
    1f92:	1d 09       	sbc	r17, r13
    1f94:	08 0f       	add	r16, r24
    1f96:	19 1f       	adc	r17, r25
    1f98:	1f 83       	std	Y+7, r17	; 0x07
    1f9a:	0e 83       	std	Y+6, r16	; 0x06
    1f9c:	fb 8e       	std	Y+27, r15	; 0x1b
    1f9e:	ec 8e       	std	Y+28, r14	; 0x1c
    1fa0:	8f ef       	ldi	r24, 0xFF	; 255
    1fa2:	8d 8f       	std	Y+29, r24	; 0x1d
    1fa4:	8e 8f       	std	Y+30, r24	; 0x1e
    1fa6:	ce 01       	movw	r24, r28
    1fa8:	08 96       	adiw	r24, 0x08	; 8
    1faa:	6a dc       	rcall	.-1836   	; 0x1880 <vListInitialise>
    1fac:	ce 01       	movw	r24, r28
    1fae:	41 96       	adiw	r24, 0x11	; 17
    1fb0:	67 dc       	rcall	.-1842   	; 0x1880 <vListInitialise>
    1fb2:	8c 2f       	mov	r24, r28
    1fb4:	9d 2f       	mov	r25, r29
    1fb6:	0b c0       	rjmp	.+22     	; 0x1fce <xQueueCreate+0x92>
    1fb8:	ce 01       	movw	r24, r28
    1fba:	0e 94 c0 02 	call	0x580	; 0x580 <vPortFree>
    1fbe:	80 e0       	ldi	r24, 0x00	; 0
    1fc0:	90 e0       	ldi	r25, 0x00	; 0
    1fc2:	05 c0       	rjmp	.+10     	; 0x1fce <xQueueCreate+0x92>
    1fc4:	80 e0       	ldi	r24, 0x00	; 0
    1fc6:	90 e0       	ldi	r25, 0x00	; 0
    1fc8:	02 c0       	rjmp	.+4      	; 0x1fce <xQueueCreate+0x92>
    1fca:	80 e0       	ldi	r24, 0x00	; 0
    1fcc:	90 e0       	ldi	r25, 0x00	; 0
    1fce:	df 91       	pop	r29
    1fd0:	cf 91       	pop	r28
    1fd2:	1f 91       	pop	r17
    1fd4:	0f 91       	pop	r16
    1fd6:	ff 90       	pop	r15
    1fd8:	ef 90       	pop	r14
    1fda:	df 90       	pop	r13
    1fdc:	cf 90       	pop	r12
    1fde:	08 95       	ret

00001fe0 <xQueueGenericSend>:
    1fe0:	4f 92       	push	r4
    1fe2:	5f 92       	push	r5
    1fe4:	6f 92       	push	r6
    1fe6:	7f 92       	push	r7
    1fe8:	8f 92       	push	r8
    1fea:	9f 92       	push	r9
    1fec:	af 92       	push	r10
    1fee:	bf 92       	push	r11
    1ff0:	cf 92       	push	r12
    1ff2:	df 92       	push	r13
    1ff4:	ef 92       	push	r14
    1ff6:	ff 92       	push	r15
    1ff8:	0f 93       	push	r16
    1ffa:	1f 93       	push	r17
    1ffc:	cf 93       	push	r28
    1ffe:	df 93       	push	r29
    2000:	00 d0       	rcall	.+0      	; 0x2002 <xQueueGenericSend+0x22>
    2002:	00 d0       	rcall	.+0      	; 0x2004 <xQueueGenericSend+0x24>
    2004:	1f 92       	push	r1
    2006:	cd b7       	in	r28, 0x3d	; 61
    2008:	de b7       	in	r29, 0x3e	; 62
    200a:	8c 01       	movw	r16, r24
    200c:	6b 01       	movw	r12, r22
    200e:	5d 83       	std	Y+5, r21	; 0x05
    2010:	4c 83       	std	Y+4, r20	; 0x04
    2012:	72 2e       	mov	r7, r18
    2014:	44 24       	eor	r4, r4
    2016:	43 94       	inc	r4
    2018:	4c 01       	movw	r8, r24
    201a:	88 e0       	ldi	r24, 0x08	; 8
    201c:	88 0e       	add	r8, r24
    201e:	91 1c       	adc	r9, r1
    2020:	e1 2c       	mov	r14, r1
    2022:	66 24       	eor	r6, r6
    2024:	63 94       	inc	r6
    2026:	58 01       	movw	r10, r16
    2028:	e1 e1       	ldi	r30, 0x11	; 17
    202a:	ae 0e       	add	r10, r30
    202c:	b1 1c       	adc	r11, r1
    202e:	55 24       	eor	r5, r5
    2030:	5a 94       	dec	r5
    2032:	8c 81       	ldd	r24, Y+4	; 0x04
    2034:	9d 81       	ldd	r25, Y+5	; 0x05
    2036:	89 2b       	or	r24, r25
    2038:	09 f4       	brne	.+2      	; 0x203c <xQueueGenericSend+0x5c>
    203a:	3a c0       	rjmp	.+116    	; 0x20b0 <xQueueGenericSend+0xd0>
    203c:	9c d4       	rcall	.+2360   	; 0x2976 <vTaskSuspendAll>
    203e:	0f b6       	in	r0, 0x3f	; 63
    2040:	f8 94       	cli
    2042:	0f 92       	push	r0
    2044:	f8 01       	movw	r30, r16
    2046:	85 8d       	ldd	r24, Z+29	; 0x1d
    2048:	8f 3f       	cpi	r24, 0xFF	; 255
    204a:	09 f4       	brne	.+2      	; 0x204e <xQueueGenericSend+0x6e>
    204c:	15 8e       	std	Z+29, r1	; 0x1d
    204e:	f8 01       	movw	r30, r16
    2050:	86 8d       	ldd	r24, Z+30	; 0x1e
    2052:	8f 3f       	cpi	r24, 0xFF	; 255
    2054:	09 f4       	brne	.+2      	; 0x2058 <xQueueGenericSend+0x78>
    2056:	16 8e       	std	Z+30, r1	; 0x1e
    2058:	0f 90       	pop	r0
    205a:	0f be       	out	0x3f, r0	; 63
    205c:	f1 e0       	ldi	r31, 0x01	; 1
    205e:	4f 12       	cpse	r4, r31
    2060:	03 c0       	rjmp	.+6      	; 0x2068 <xQueueGenericSend+0x88>
    2062:	ce 01       	movw	r24, r28
    2064:	01 96       	adiw	r24, 0x01	; 1
    2066:	11 d7       	rcall	.+3618   	; 0x2e8a <vTaskSetTimeOutState>
    2068:	0f b6       	in	r0, 0x3f	; 63
    206a:	f8 94       	cli
    206c:	0f 92       	push	r0
    206e:	f8 01       	movw	r30, r16
    2070:	92 8d       	ldd	r25, Z+26	; 0x1a
    2072:	0f 90       	pop	r0
    2074:	0f be       	out	0x3f, r0	; 63
    2076:	83 8d       	ldd	r24, Z+27	; 0x1b
    2078:	98 13       	cpse	r25, r24
    207a:	17 c0       	rjmp	.+46     	; 0x20aa <xQueueGenericSend+0xca>
    207c:	be 01       	movw	r22, r28
    207e:	6c 5f       	subi	r22, 0xFC	; 252
    2080:	7f 4f       	sbci	r23, 0xFF	; 255
    2082:	ce 01       	movw	r24, r28
    2084:	01 96       	adiw	r24, 0x01	; 1
    2086:	0c d7       	rcall	.+3608   	; 0x2ea0 <xTaskCheckForTimeOut>
    2088:	81 11       	cpse	r24, r1
    208a:	0b c0       	rjmp	.+22     	; 0x20a2 <xQueueGenericSend+0xc2>
    208c:	6c 81       	ldd	r22, Y+4	; 0x04
    208e:	7d 81       	ldd	r23, Y+5	; 0x05
    2090:	c4 01       	movw	r24, r8
    2092:	60 d6       	rcall	.+3264   	; 0x2d54 <vTaskPlaceOnEventList>
    2094:	c8 01       	movw	r24, r16
    2096:	af de       	rcall	.-674    	; 0x1df6 <prvUnlockQueue>
    2098:	f9 d4       	rcall	.+2546   	; 0x2a8c <xTaskResumeAll>
    209a:	81 11       	cpse	r24, r1
    209c:	09 c0       	rjmp	.+18     	; 0x20b0 <xQueueGenericSend+0xd0>
    209e:	f8 dd       	rcall	.-1040   	; 0x1c90 <vPortYield>
    20a0:	07 c0       	rjmp	.+14     	; 0x20b0 <xQueueGenericSend+0xd0>
    20a2:	c8 01       	movw	r24, r16
    20a4:	a8 de       	rcall	.-688    	; 0x1df6 <prvUnlockQueue>
    20a6:	f2 d4       	rcall	.+2532   	; 0x2a8c <xTaskResumeAll>
    20a8:	03 c0       	rjmp	.+6      	; 0x20b0 <xQueueGenericSend+0xd0>
    20aa:	c8 01       	movw	r24, r16
    20ac:	a4 de       	rcall	.-696    	; 0x1df6 <prvUnlockQueue>
    20ae:	ee d4       	rcall	.+2524   	; 0x2a8c <xTaskResumeAll>
    20b0:	0f b6       	in	r0, 0x3f	; 63
    20b2:	f8 94       	cli
    20b4:	0f 92       	push	r0
    20b6:	f8 01       	movw	r30, r16
    20b8:	92 8d       	ldd	r25, Z+26	; 0x1a
    20ba:	83 8d       	ldd	r24, Z+27	; 0x1b
    20bc:	98 17       	cp	r25, r24
    20be:	78 f4       	brcc	.+30     	; 0x20de <xQueueGenericSend+0xfe>
    20c0:	47 2d       	mov	r20, r7
    20c2:	b6 01       	movw	r22, r12
    20c4:	c8 01       	movw	r24, r16
    20c6:	df de       	rcall	.-578    	; 0x1e86 <prvCopyDataToQueue>
    20c8:	f8 01       	movw	r30, r16
    20ca:	81 89       	ldd	r24, Z+17	; 0x11
    20cc:	88 23       	and	r24, r24
    20ce:	49 f0       	breq	.+18     	; 0x20e2 <xQueueGenericSend+0x102>
    20d0:	c5 01       	movw	r24, r10
    20d2:	90 d6       	rcall	.+3360   	; 0x2df4 <xTaskRemoveFromEventList>
    20d4:	81 30       	cpi	r24, 0x01	; 1
    20d6:	39 f4       	brne	.+14     	; 0x20e6 <xQueueGenericSend+0x106>
    20d8:	db dd       	rcall	.-1098   	; 0x1c90 <vPortYield>
    20da:	f6 2c       	mov	r15, r6
    20dc:	05 c0       	rjmp	.+10     	; 0x20e8 <xQueueGenericSend+0x108>
    20de:	fe 2c       	mov	r15, r14
    20e0:	03 c0       	rjmp	.+6      	; 0x20e8 <xQueueGenericSend+0x108>
    20e2:	f6 2c       	mov	r15, r6
    20e4:	01 c0       	rjmp	.+2      	; 0x20e8 <xQueueGenericSend+0x108>
    20e6:	f6 2c       	mov	r15, r6
    20e8:	0f 90       	pop	r0
    20ea:	0f be       	out	0x3f, r0	; 63
    20ec:	f1 10       	cpse	r15, r1
    20ee:	0e c0       	rjmp	.+28     	; 0x210c <xQueueGenericSend+0x12c>
    20f0:	8c 81       	ldd	r24, Y+4	; 0x04
    20f2:	9d 81       	ldd	r25, Y+5	; 0x05
    20f4:	89 2b       	or	r24, r25
    20f6:	51 f0       	breq	.+20     	; 0x210c <xQueueGenericSend+0x12c>
    20f8:	be 01       	movw	r22, r28
    20fa:	6c 5f       	subi	r22, 0xFC	; 252
    20fc:	7f 4f       	sbci	r23, 0xFF	; 255
    20fe:	ce 01       	movw	r24, r28
    2100:	01 96       	adiw	r24, 0x01	; 1
    2102:	ce d6       	rcall	.+3484   	; 0x2ea0 <xTaskCheckForTimeOut>
    2104:	45 2c       	mov	r4, r5
    2106:	88 23       	and	r24, r24
    2108:	09 f4       	brne	.+2      	; 0x210c <xQueueGenericSend+0x12c>
    210a:	93 cf       	rjmp	.-218    	; 0x2032 <xQueueGenericSend+0x52>
    210c:	8f 2d       	mov	r24, r15
    210e:	0f 90       	pop	r0
    2110:	0f 90       	pop	r0
    2112:	0f 90       	pop	r0
    2114:	0f 90       	pop	r0
    2116:	0f 90       	pop	r0
    2118:	df 91       	pop	r29
    211a:	cf 91       	pop	r28
    211c:	1f 91       	pop	r17
    211e:	0f 91       	pop	r16
    2120:	ff 90       	pop	r15
    2122:	ef 90       	pop	r14
    2124:	df 90       	pop	r13
    2126:	cf 90       	pop	r12
    2128:	bf 90       	pop	r11
    212a:	af 90       	pop	r10
    212c:	9f 90       	pop	r9
    212e:	8f 90       	pop	r8
    2130:	7f 90       	pop	r7
    2132:	6f 90       	pop	r6
    2134:	5f 90       	pop	r5
    2136:	4f 90       	pop	r4
    2138:	08 95       	ret

0000213a <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    213a:	4f 92       	push	r4
    213c:	5f 92       	push	r5
    213e:	6f 92       	push	r6
    2140:	7f 92       	push	r7
    2142:	8f 92       	push	r8
    2144:	9f 92       	push	r9
    2146:	af 92       	push	r10
    2148:	bf 92       	push	r11
    214a:	cf 92       	push	r12
    214c:	df 92       	push	r13
    214e:	ef 92       	push	r14
    2150:	ff 92       	push	r15
    2152:	0f 93       	push	r16
    2154:	1f 93       	push	r17
    2156:	cf 93       	push	r28
    2158:	df 93       	push	r29
    215a:	00 d0       	rcall	.+0      	; 0x215c <xQueueGenericReceive+0x22>
    215c:	00 d0       	rcall	.+0      	; 0x215e <xQueueGenericReceive+0x24>
    215e:	1f 92       	push	r1
    2160:	cd b7       	in	r28, 0x3d	; 61
    2162:	de b7       	in	r29, 0x3e	; 62
    2164:	8c 01       	movw	r16, r24
    2166:	6b 01       	movw	r12, r22
    2168:	5d 83       	std	Y+5, r21	; 0x05
    216a:	4c 83       	std	Y+4, r20	; 0x04
    216c:	62 2e       	mov	r6, r18
signed portBASE_TYPE xReturn = pdTRUE;
    216e:	ee 24       	eor	r14, r14
    2170:	e3 94       	inc	r14
							portEXIT_CRITICAL();
						}
					}
					#endif

					vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2172:	5c 01       	movw	r10, r24
    2174:	81 e1       	ldi	r24, 0x11	; 17
    2176:	a8 0e       	add	r10, r24
    2178:	b1 1c       	adc	r11, r1

				xReturn = pdPASS;
			}
			else
			{
				xReturn = errQUEUE_EMPTY;
    217a:	71 2c       	mov	r7, r1
						}
					}

				}

				xReturn = pdPASS;
    217c:	55 24       	eor	r5, r5
    217e:	53 94       	inc	r5
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    2180:	48 01       	movw	r8, r16
    2182:	e8 e0       	ldi	r30, 0x08	; 8
    2184:	8e 0e       	add	r8, r30
    2186:	91 1c       	adc	r9, r1
    2188:	44 24       	eor	r4, r4
    218a:	4a 94       	dec	r4
signed portCHAR *pcOriginalReadPosition;

	do
	{
		/* If there are no messages in the queue we may have to block. */
		if( xTicksToWait > ( portTickType ) 0 )
    218c:	8c 81       	ldd	r24, Y+4	; 0x04
    218e:	9d 81       	ldd	r25, Y+5	; 0x05
    2190:	89 2b       	or	r24, r25
    2192:	09 f4       	brne	.+2      	; 0x2196 <xQueueGenericReceive+0x5c>
    2194:	39 c0       	rjmp	.+114    	; 0x2208 <xQueueGenericReceive+0xce>
		{
			vTaskSuspendAll();
    2196:	ef d3       	rcall	.+2014   	; 0x2976 <vTaskSuspendAll>
			prvLockQueue( pxQueue );
    2198:	0f b6       	in	r0, 0x3f	; 63
    219a:	f8 94       	cli
    219c:	0f 92       	push	r0
    219e:	f8 01       	movw	r30, r16
    21a0:	85 8d       	ldd	r24, Z+29	; 0x1d
    21a2:	8f 3f       	cpi	r24, 0xFF	; 255
    21a4:	09 f4       	brne	.+2      	; 0x21a8 <xQueueGenericReceive+0x6e>
    21a6:	15 8e       	std	Z+29, r1	; 0x1d
    21a8:	f8 01       	movw	r30, r16
    21aa:	86 8d       	ldd	r24, Z+30	; 0x1e
    21ac:	8f 3f       	cpi	r24, 0xFF	; 255
    21ae:	09 f4       	brne	.+2      	; 0x21b2 <xQueueGenericReceive+0x78>
    21b0:	16 8e       	std	Z+30, r1	; 0x1e
    21b2:	0f 90       	pop	r0
    21b4:	0f be       	out	0x3f, r0	; 63

			if( xReturn == pdTRUE )
    21b6:	f1 e0       	ldi	r31, 0x01	; 1
    21b8:	ef 12       	cpse	r14, r31
    21ba:	03 c0       	rjmp	.+6      	; 0x21c2 <xQueueGenericReceive+0x88>
			{
				/* This is the first time through - we need to capture the
				time while the scheduler is locked to ensure we attempt to
				block at least once. */
				vTaskSetTimeOutState( &xTimeOut );
    21bc:	ce 01       	movw	r24, r28
    21be:	01 96       	adiw	r24, 0x01	; 1
    21c0:	64 d6       	rcall	.+3272   	; 0x2e8a <vTaskSetTimeOutState>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    21c2:	0f b6       	in	r0, 0x3f	; 63
    21c4:	f8 94       	cli
    21c6:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    21c8:	f8 01       	movw	r30, r16
    21ca:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    21cc:	0f 90       	pop	r0
    21ce:	0f be       	out	0x3f, r0	; 63
				time while the scheduler is locked to ensure we attempt to
				block at least once. */
				vTaskSetTimeOutState( &xTimeOut );
			}

			if( prvIsQueueEmpty( pxQueue ) )
    21d0:	81 11       	cpse	r24, r1
    21d2:	17 c0       	rjmp	.+46     	; 0x2202 <xQueueGenericReceive+0xc8>
			{
	    		/* Need to call xTaskCheckForTimeout again as time could
	    		have passed since it was last called if this is not the
	    		first time around this loop. */
				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    21d4:	be 01       	movw	r22, r28
    21d6:	6c 5f       	subi	r22, 0xFC	; 252
    21d8:	7f 4f       	sbci	r23, 0xFF	; 255
    21da:	ce 01       	movw	r24, r28
    21dc:	01 96       	adiw	r24, 0x01	; 1
    21de:	60 d6       	rcall	.+3264   	; 0x2ea0 <xTaskCheckForTimeOut>
    21e0:	81 11       	cpse	r24, r1
    21e2:	0b c0       	rjmp	.+22     	; 0x21fa <xQueueGenericReceive+0xc0>
							portEXIT_CRITICAL();
						}
					}
					#endif

					vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    21e4:	6c 81       	ldd	r22, Y+4	; 0x04
    21e6:	7d 81       	ldd	r23, Y+5	; 0x05
    21e8:	c5 01       	movw	r24, r10
					prvUnlockQueue( pxQueue );
    21ea:	b4 d5       	rcall	.+2920   	; 0x2d54 <vTaskPlaceOnEventList>
    21ec:	c8 01       	movw	r24, r16
					if( !xTaskResumeAll() )
    21ee:	03 de       	rcall	.-1018   	; 0x1df6 <prvUnlockQueue>
    21f0:	4d d4       	rcall	.+2202   	; 0x2a8c <xTaskResumeAll>
					{
						taskYIELD();
    21f2:	81 11       	cpse	r24, r1
    21f4:	09 c0       	rjmp	.+18     	; 0x2208 <xQueueGenericReceive+0xce>
					}
				}
				else
				{
					prvUnlockQueue( pxQueue );
    21f6:	4c dd       	rcall	.-1384   	; 0x1c90 <vPortYield>
    21f8:	07 c0       	rjmp	.+14     	; 0x2208 <xQueueGenericReceive+0xce>
    21fa:	c8 01       	movw	r24, r16
					( void ) xTaskResumeAll();
    21fc:	fc dd       	rcall	.-1032   	; 0x1df6 <prvUnlockQueue>
    21fe:	46 d4       	rcall	.+2188   	; 0x2a8c <xTaskResumeAll>
    2200:	03 c0       	rjmp	.+6      	; 0x2208 <xQueueGenericReceive+0xce>
				}
			}
			else
			{
				prvUnlockQueue( pxQueue );
    2202:	c8 01       	movw	r24, r16
    2204:	f8 dd       	rcall	.-1040   	; 0x1df6 <prvUnlockQueue>
    2206:	42 d4       	rcall	.+2180   	; 0x2a8c <xTaskResumeAll>
				( void ) xTaskResumeAll();
    2208:	0f b6       	in	r0, 0x3f	; 63
    220a:	f8 94       	cli
		}

/* The two tasks are blocked on the queue, the low priority task is polling/running. */

/* An interrupt occurs here - which unblocks the HP tasks, but they do not run. */
		taskENTER_CRITICAL();
    220c:	0f 92       	push	r0
    220e:	f8 01       	movw	r30, r16
		{
/* Because the interrupt occurred the LP task manages to grab the data as the other two tasks are not yet running. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    2210:	82 8d       	ldd	r24, Z+26	; 0x1a
    2212:	88 23       	and	r24, r24
    2214:	11 f1       	breq	.+68     	; 0x225a <xQueueGenericReceive+0x120>
    2216:	e6 80       	ldd	r14, Z+6	; 0x06
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    2218:	f7 80       	ldd	r15, Z+7	; 0x07
    221a:	b6 01       	movw	r22, r12

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    221c:	c8 01       	movw	r24, r16
    221e:	74 de       	rcall	.-792    	; 0x1f08 <prvCopyDataFromQueue>
    2220:	61 10       	cpse	r6, r1

				if( xJustPeeking == pdFALSE )
    2222:	0e c0       	rjmp	.+28     	; 0x2240 <xQueueGenericReceive+0x106>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    2224:	f8 01       	movw	r30, r16
    2226:	82 8d       	ldd	r24, Z+26	; 0x1a
    2228:	81 50       	subi	r24, 0x01	; 1
    222a:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    222c:	80 85       	ldd	r24, Z+8	; 0x08
    222e:	88 23       	and	r24, r24
    2230:	b1 f0       	breq	.+44     	; 0x225e <xQueueGenericReceive+0x124>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    2232:	c4 01       	movw	r24, r8
    2234:	df d5       	rcall	.+3006   	; 0x2df4 <xTaskRemoveFromEventList>
    2236:	81 30       	cpi	r24, 0x01	; 1
    2238:	a1 f4       	brne	.+40     	; 0x2262 <xQueueGenericReceive+0x128>
						{
							taskYIELD();
    223a:	2a dd       	rcall	.-1452   	; 0x1c90 <vPortYield>
						}
					}

				}

				xReturn = pdPASS;
    223c:	f5 2c       	mov	r15, r5
    223e:	16 c0       	rjmp	.+44     	; 0x226c <xQueueGenericReceive+0x132>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    2240:	f8 01       	movw	r30, r16
    2242:	f7 82       	std	Z+7, r15	; 0x07
    2244:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
    2246:	81 89       	ldd	r24, Z+17	; 0x11
    2248:	88 23       	and	r24, r24
    224a:	69 f0       	breq	.+26     	; 0x2266 <xQueueGenericReceive+0x12c>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    224c:	c5 01       	movw	r24, r10
    224e:	d2 d5       	rcall	.+2980   	; 0x2df4 <xTaskRemoveFromEventList>
    2250:	88 23       	and	r24, r24
    2252:	59 f0       	breq	.+22     	; 0x226a <xQueueGenericReceive+0x130>
    2254:	1d dd       	rcall	.-1478   	; 0x1c90 <vPortYield>
						{
							/* The task waiting has a higher priority than this task. */
							taskYIELD();
    2256:	f5 2c       	mov	r15, r5
    2258:	09 c0       	rjmp	.+18     	; 0x226c <xQueueGenericReceive+0x132>
						}
					}

				}

				xReturn = pdPASS;
    225a:	f7 2c       	mov	r15, r7
    225c:	07 c0       	rjmp	.+14     	; 0x226c <xQueueGenericReceive+0x132>
			}
			else
			{
				xReturn = errQUEUE_EMPTY;
    225e:	f5 2c       	mov	r15, r5
    2260:	05 c0       	rjmp	.+10     	; 0x226c <xQueueGenericReceive+0x132>
						}
					}

				}

				xReturn = pdPASS;
    2262:	f5 2c       	mov	r15, r5
    2264:	03 c0       	rjmp	.+6      	; 0x226c <xQueueGenericReceive+0x132>
    2266:	f5 2c       	mov	r15, r5
    2268:	01 c0       	rjmp	.+2      	; 0x226c <xQueueGenericReceive+0x132>
    226a:	f5 2c       	mov	r15, r5
    226c:	0f 90       	pop	r0
			else
			{
				xReturn = errQUEUE_EMPTY;
			}
		}
		taskEXIT_CRITICAL();
    226e:	0f be       	out	0x3f, r0	; 63
    2270:	f1 10       	cpse	r15, r1

		if( xReturn == errQUEUE_EMPTY )
    2272:	0e c0       	rjmp	.+28     	; 0x2290 <xQueueGenericReceive+0x156>
    2274:	8c 81       	ldd	r24, Y+4	; 0x04
		{
			if( xTicksToWait > ( portTickType ) 0 )
    2276:	9d 81       	ldd	r25, Y+5	; 0x05
    2278:	89 2b       	or	r24, r25
    227a:	51 f0       	breq	.+20     	; 0x2290 <xQueueGenericReceive+0x156>
    227c:	be 01       	movw	r22, r28
			{
				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    227e:	6c 5f       	subi	r22, 0xFC	; 252
    2280:	7f 4f       	sbci	r23, 0xFF	; 255
    2282:	ce 01       	movw	r24, r28
    2284:	01 96       	adiw	r24, 0x01	; 1
    2286:	0c d6       	rcall	.+3096   	; 0x2ea0 <xTaskCheckForTimeOut>
    2288:	e4 2c       	mov	r14, r4
    228a:	88 23       	and	r24, r24
    228c:	09 f4       	brne	.+2      	; 0x2290 <xQueueGenericReceive+0x156>
    228e:	7e cf       	rjmp	.-260    	; 0x218c <xQueueGenericReceive+0x52>
    2290:	8f 2d       	mov	r24, r15
    2292:	0f 90       	pop	r0
		}

	} while( xReturn == queueERRONEOUS_UNBLOCK );

	return xReturn;
}
    2294:	0f 90       	pop	r0
    2296:	0f 90       	pop	r0
    2298:	0f 90       	pop	r0
    229a:	0f 90       	pop	r0
    229c:	df 91       	pop	r29
    229e:	cf 91       	pop	r28
    22a0:	1f 91       	pop	r17
    22a2:	0f 91       	pop	r16
    22a4:	ff 90       	pop	r15
    22a6:	ef 90       	pop	r14
    22a8:	df 90       	pop	r13
    22aa:	cf 90       	pop	r12
    22ac:	bf 90       	pop	r11
    22ae:	af 90       	pop	r10
    22b0:	9f 90       	pop	r9
    22b2:	8f 90       	pop	r8
    22b4:	7f 90       	pop	r7
    22b6:	6f 90       	pop	r6
    22b8:	5f 90       	pop	r5
    22ba:	4f 90       	pop	r4
    22bc:	08 95       	ret

000022be <vSensor>:
#include "PID.h"
// external Arrays
extern float  ref_value [7][7];
//----------------------------------------------------------
void  vSensor ( void * pvParameters)
{ unsigned char fototrans, ft_c, led = 0, zeros = 0;
    22be:	cf 93       	push	r28
    22c0:	df 93       	push	r29
    22c2:	cd b7       	in	r28, 0x3d	; 61
    22c4:	de b7       	in	r29, 0x3e	; 62
    22c6:	ac 97       	sbiw	r28, 0x2c	; 44
    22c8:	0f b6       	in	r0, 0x3f	; 63
    22ca:	f8 94       	cli
    22cc:	de bf       	out	0x3e, r29	; 62
    22ce:	0f be       	out	0x3f, r0	; 63
    22d0:	cd bf       	out	0x3d, r28	; 61
  float pos_part = 0.0, smooth_pos = 0.0;
    22d2:	19 82       	std	Y+1, r1	; 0x01
    22d4:	1a 82       	std	Y+2, r1	; 0x02
    22d6:	1b 82       	std	Y+3, r1	; 0x03
    22d8:	1c 82       	std	Y+4, r1	; 0x04
	float old = 0.0, old1 = 0.0, old2 = 0.0, old3 = 0.0;
	float old4 = 0.0, old5 = 0.0, old6 = 0.0, old7 = 0.0;
	float  old8 = 0.0, old9 = 0.0;
	// LED sequencer on
	cli();  PORTC = (1 << led) | (PORTC & 0b10000000);  sei();
    22da:	f8 94       	cli
    22dc:	85 b3       	in	r24, 0x15	; 21
    22de:	80 78       	andi	r24, 0x80	; 128
    22e0:	81 60       	ori	r24, 0x01	; 1
    22e2:	85 bb       	out	0x15, r24	; 21
    22e4:	78 94       	sei
void  vSensor ( void * pvParameters)
{ unsigned char fototrans, ft_c, led = 0, zeros = 0;
  float pos_part = 0.0, smooth_pos = 0.0;
	float old = 0.0, old1 = 0.0, old2 = 0.0, old3 = 0.0;
	float old4 = 0.0, old5 = 0.0, old6 = 0.0, old7 = 0.0;
	float  old8 = 0.0, old9 = 0.0;
    22e6:	19 a6       	std	Y+41, r1	; 0x29
    22e8:	1a a6       	std	Y+42, r1	; 0x2a
    22ea:	1b a6       	std	Y+43, r1	; 0x2b
    22ec:	1c a6       	std	Y+44, r1	; 0x2c
    22ee:	1d a2       	std	Y+37, r1	; 0x25
    22f0:	1e a2       	std	Y+38, r1	; 0x26
    22f2:	1f a2       	std	Y+39, r1	; 0x27
    22f4:	18 a6       	std	Y+40, r1	; 0x28
//----------------------------------------------------------
void  vSensor ( void * pvParameters)
{ unsigned char fototrans, ft_c, led = 0, zeros = 0;
  float pos_part = 0.0, smooth_pos = 0.0;
	float old = 0.0, old1 = 0.0, old2 = 0.0, old3 = 0.0;
	float old4 = 0.0, old5 = 0.0, old6 = 0.0, old7 = 0.0;
    22f6:	19 a2       	std	Y+33, r1	; 0x21
    22f8:	1a a2       	std	Y+34, r1	; 0x22
    22fa:	1b a2       	std	Y+35, r1	; 0x23
    22fc:	1c a2       	std	Y+36, r1	; 0x24
    22fe:	1d 8e       	std	Y+29, r1	; 0x1d
    2300:	1e 8e       	std	Y+30, r1	; 0x1e
    2302:	1f 8e       	std	Y+31, r1	; 0x1f
    2304:	18 a2       	std	Y+32, r1	; 0x20
    2306:	19 8e       	std	Y+25, r1	; 0x19
    2308:	1a 8e       	std	Y+26, r1	; 0x1a
    230a:	1b 8e       	std	Y+27, r1	; 0x1b
    230c:	1c 8e       	std	Y+28, r1	; 0x1c
    230e:	1d 8a       	std	Y+21, r1	; 0x15
    2310:	1e 8a       	std	Y+22, r1	; 0x16
    2312:	1f 8a       	std	Y+23, r1	; 0x17
    2314:	18 8e       	std	Y+24, r1	; 0x18
extern float  ref_value [7][7];
//----------------------------------------------------------
void  vSensor ( void * pvParameters)
{ unsigned char fototrans, ft_c, led = 0, zeros = 0;
  float pos_part = 0.0, smooth_pos = 0.0;
	float old = 0.0, old1 = 0.0, old2 = 0.0, old3 = 0.0;
    2316:	19 8a       	std	Y+17, r1	; 0x11
    2318:	1a 8a       	std	Y+18, r1	; 0x12
    231a:	1b 8a       	std	Y+19, r1	; 0x13
    231c:	1c 8a       	std	Y+20, r1	; 0x14
    231e:	1d 86       	std	Y+13, r1	; 0x0d
    2320:	1e 86       	std	Y+14, r1	; 0x0e
    2322:	1f 86       	std	Y+15, r1	; 0x0f
    2324:	18 8a       	std	Y+16, r1	; 0x10
    2326:	19 86       	std	Y+9, r1	; 0x09
    2328:	1a 86       	std	Y+10, r1	; 0x0a
    232a:	1b 86       	std	Y+11, r1	; 0x0b
    232c:	1c 86       	std	Y+12, r1	; 0x0c
    232e:	1d 82       	std	Y+5, r1	; 0x05
    2330:	1e 82       	std	Y+6, r1	; 0x06
    2332:	1f 82       	std	Y+7, r1	; 0x07
    2334:	18 86       	std	Y+8, r1	; 0x08
// external Arrays
extern float  ref_value [7][7];
//----------------------------------------------------------
void  vSensor ( void * pvParameters)
{ unsigned char fototrans, ft_c, led = 0, zeros = 0;
  float pos_part = 0.0, smooth_pos = 0.0;
    2336:	a1 2c       	mov	r10, r1
    2338:	b1 2c       	mov	r11, r1
    233a:	91 2c       	mov	r9, r1
    233c:	61 2c       	mov	r6, r1
#include "PID.h"
// external Arrays
extern float  ref_value [7][7];
//----------------------------------------------------------
void  vSensor ( void * pvParameters)
{ unsigned char fototrans, ft_c, led = 0, zeros = 0;
    233e:	71 2c       	mov	r7, r1
    2340:	81 2c       	mov	r8, r1
	float  old8 = 0.0, old9 = 0.0;
	// LED sequencer on
	cli();  PORTC = (1 << led) | (PORTC & 0b10000000);  sei();
	// Super loop of task vSensor
  for (;;)  
  { vTaskDelay (1);  // 1x 3ms
    2342:	81 e0       	ldi	r24, 0x01	; 1
    2344:	90 e0       	ldi	r25, 0x00	; 0
    2346:	27 d4       	rcall	.+2126   	; 0x2b96 <vTaskDelay>
		// Get part of position info from light breakers values
		fototrans = ((PIND & 0xf0) >> 4) | ((PINA & 0x0f) << 4);
    2348:	80 b3       	in	r24, 0x10	; 16
    234a:	99 b3       	in	r25, 0x19	; 25
    234c:	c8 2e       	mov	r12, r24
    234e:	c6 94       	lsr	r12
    2350:	c6 94       	lsr	r12
    2352:	c6 94       	lsr	r12
    2354:	c6 94       	lsr	r12
    2356:	20 e1       	ldi	r18, 0x10	; 16
    2358:	92 9f       	mul	r25, r18
    235a:	c0 01       	movw	r24, r0
    235c:	11 24       	eor	r1, r1
    235e:	8c 29       	or	r24, r12
    2360:	e8 2c       	mov	r14, r8
    2362:	f1 2c       	mov	r15, r1
    2364:	97 01       	movw	r18, r14
    2366:	22 0f       	add	r18, r18
    2368:	33 1f       	adc	r19, r19
    236a:	22 0f       	add	r18, r18
    236c:	33 1f       	adc	r19, r19
    236e:	a9 01       	movw	r20, r18
    2370:	40 50       	subi	r20, 0x00	; 0
    2372:	5f 4f       	sbci	r21, 0xFF	; 255
    2374:	7a 01       	movw	r14, r20
    2376:	00 e0       	ldi	r16, 0x00	; 0
    2378:	10 e0       	ldi	r17, 0x00	; 0
		// Calculate part of position value
		for (ft_c = 0; ft_c < 7; ft_c++)
		{ if ( ! (fototrans & (1 << ft_c)))
    237a:	c8 2e       	mov	r12, r24
    237c:	d1 2c       	mov	r13, r1
    237e:	c6 01       	movw	r24, r12
    2380:	00 2e       	mov	r0, r16
    2382:	02 c0       	rjmp	.+4      	; 0x2388 <vSensor+0xca>
    2384:	95 95       	asr	r25
    2386:	87 95       	ror	r24
    2388:	0a 94       	dec	r0
    238a:	e2 f7       	brpl	.-8      	; 0x2384 <vSensor+0xc6>
    238c:	80 fd       	sbrc	r24, 0
    238e:	1b c0       	rjmp	.+54     	; 0x23c6 <vSensor+0x108>
			{ if (fabs(ref_value [ft_c][led]) > 0.0005)  zeros++;
    2390:	f7 01       	movw	r30, r14
    2392:	20 80       	ld	r2, Z
    2394:	31 80       	ldd	r3, Z+1	; 0x01
    2396:	42 80       	ldd	r4, Z+2	; 0x02
    2398:	53 80       	ldd	r5, Z+3	; 0x03
    239a:	c2 01       	movw	r24, r4
    239c:	b1 01       	movw	r22, r2
    239e:	9f 77       	andi	r25, 0x7F	; 127
    23a0:	2f e6       	ldi	r18, 0x6F	; 111
    23a2:	32 e1       	ldi	r19, 0x12	; 18
    23a4:	43 e0       	ldi	r20, 0x03	; 3
    23a6:	5a e3       	ldi	r21, 0x3A	; 58
    23a8:	71 d7       	rcall	.+3810   	; 0x328c <__gesf2>
    23aa:	18 16       	cp	r1, r24
    23ac:	0c f4       	brge	.+2      	; 0x23b0 <vSensor+0xf2>
    23ae:	73 94       	inc	r7
				pos_part = pos_part + ref_value [ft_c][led];
    23b0:	a2 01       	movw	r20, r4
    23b2:	91 01       	movw	r18, r2
    23b4:	6a 2d       	mov	r22, r10
    23b6:	7b 2d       	mov	r23, r11
    23b8:	89 2d       	mov	r24, r9
    23ba:	96 2d       	mov	r25, r6
    23bc:	b4 d5       	rcall	.+2920   	; 0x2f26 <__addsf3>
    23be:	a6 2e       	mov	r10, r22
    23c0:	b7 2e       	mov	r11, r23
    23c2:	98 2e       	mov	r9, r24
    23c4:	69 2e       	mov	r6, r25
    23c6:	0f 5f       	subi	r16, 0xFF	; 255
    23c8:	1f 4f       	sbci	r17, 0xFF	; 255
    23ca:	fc e1       	ldi	r31, 0x1C	; 28
    23cc:	ef 0e       	add	r14, r31
    23ce:	f1 1c       	adc	r15, r1
  for (;;)  
  { vTaskDelay (1);  // 1x 3ms
		// Get part of position info from light breakers values
		fototrans = ((PIND & 0xf0) >> 4) | ((PINA & 0x0f) << 4);
		// Calculate part of position value
		for (ft_c = 0; ft_c < 7; ft_c++)
    23d0:	07 30       	cpi	r16, 0x07	; 7
    23d2:	11 05       	cpc	r17, r1
    23d4:	a1 f6       	brne	.-88     	; 0x237e <vSensor+0xc0>
			{ if (fabs(ref_value [ft_c][led]) > 0.0005)  zeros++;
				pos_part = pos_part + ref_value [ft_c][led];
			}
		}
		// Rotate to next LED (0..6)
		led++;
    23d6:	83 94       	inc	r8
		if (led > 6)
    23d8:	26 e0       	ldi	r18, 0x06	; 6
    23da:	28 15       	cp	r18, r8
    23dc:	08 f0       	brcs	.+2      	; 0x23e0 <vSensor+0x122>
    23de:	cf c0       	rjmp	.+414    	; 0x257e <vSensor+0x2c0>
		{ 
      if (zeros > 0)  position = pos_part / (float) zeros;
    23e0:	77 20       	and	r7, r7
    23e2:	a9 f0       	breq	.+42     	; 0x240e <vSensor+0x150>
    23e4:	67 2d       	mov	r22, r7
    23e6:	70 e0       	ldi	r23, 0x00	; 0
    23e8:	80 e0       	ldi	r24, 0x00	; 0
    23ea:	90 e0       	ldi	r25, 0x00	; 0
    23ec:	9d d6       	rcall	.+3386   	; 0x3128 <__floatunsisf>
    23ee:	9b 01       	movw	r18, r22
    23f0:	ac 01       	movw	r20, r24
    23f2:	6a 2d       	mov	r22, r10
    23f4:	7b 2d       	mov	r23, r11
    23f6:	89 2d       	mov	r24, r9
    23f8:	96 2d       	mov	r25, r6
    23fa:	fd d5       	rcall	.+3066   	; 0x2ff6 <__divsf3>
    23fc:	60 93 8e 0a 	sts	0x0A8E, r22	; 0x800a8e <position>
    2400:	70 93 8f 0a 	sts	0x0A8F, r23	; 0x800a8f <position+0x1>
    2404:	80 93 90 0a 	sts	0x0A90, r24	; 0x800a90 <position+0x2>
    2408:	90 93 91 0a 	sts	0x0A91, r25	; 0x800a91 <position+0x3>
    240c:	0c c0       	rjmp	.+24     	; 0x2426 <vSensor+0x168>
			else  position = 0.0;
    240e:	80 e0       	ldi	r24, 0x00	; 0
    2410:	90 e0       	ldi	r25, 0x00	; 0
    2412:	a0 e0       	ldi	r26, 0x00	; 0
    2414:	b0 e0       	ldi	r27, 0x00	; 0
    2416:	80 93 8e 0a 	sts	0x0A8E, r24	; 0x800a8e <position>
    241a:	90 93 8f 0a 	sts	0x0A8F, r25	; 0x800a8f <position+0x1>
    241e:	a0 93 90 0a 	sts	0x0A90, r26	; 0x800a90 <position+0x2>
    2422:	b0 93 91 0a 	sts	0x0A91, r27	; 0x800a91 <position+0x3>
			smooth_pos = (position + old + old1 + old2 + old3 \
    2426:	f0 90 8e 0a 	lds	r15, 0x0A8E	; 0x800a8e <position>
    242a:	00 91 8f 0a 	lds	r16, 0x0A8F	; 0x800a8f <position+0x1>
    242e:	10 91 90 0a 	lds	r17, 0x0A90	; 0x800a90 <position+0x2>
    2432:	e0 90 91 0a 	lds	r14, 0x0A91	; 0x800a91 <position+0x3>
    2436:	2f 2d       	mov	r18, r15
    2438:	30 2f       	mov	r19, r16
    243a:	41 2f       	mov	r20, r17
    243c:	5e 2d       	mov	r21, r14
    243e:	6d 81       	ldd	r22, Y+5	; 0x05
    2440:	7e 81       	ldd	r23, Y+6	; 0x06
    2442:	8f 81       	ldd	r24, Y+7	; 0x07
    2444:	98 85       	ldd	r25, Y+8	; 0x08
    2446:	6f d5       	rcall	.+2782   	; 0x2f26 <__addsf3>
    2448:	29 85       	ldd	r18, Y+9	; 0x09
    244a:	3a 85       	ldd	r19, Y+10	; 0x0a
    244c:	4b 85       	ldd	r20, Y+11	; 0x0b
    244e:	5c 85       	ldd	r21, Y+12	; 0x0c
    2450:	6a d5       	rcall	.+2772   	; 0x2f26 <__addsf3>
    2452:	2d 85       	ldd	r18, Y+13	; 0x0d
    2454:	3e 85       	ldd	r19, Y+14	; 0x0e
    2456:	4f 85       	ldd	r20, Y+15	; 0x0f
    2458:	58 89       	ldd	r21, Y+16	; 0x10
    245a:	65 d5       	rcall	.+2762   	; 0x2f26 <__addsf3>
    245c:	29 89       	ldd	r18, Y+17	; 0x11
    245e:	3a 89       	ldd	r19, Y+18	; 0x12
    2460:	4b 89       	ldd	r20, Y+19	; 0x13
    2462:	5c 89       	ldd	r21, Y+20	; 0x14
    2464:	60 d5       	rcall	.+2752   	; 0x2f26 <__addsf3>
    2466:	2d 89       	ldd	r18, Y+21	; 0x15
    2468:	3e 89       	ldd	r19, Y+22	; 0x16
    246a:	4f 89       	ldd	r20, Y+23	; 0x17
    246c:	58 8d       	ldd	r21, Y+24	; 0x18
    246e:	5b d5       	rcall	.+2742   	; 0x2f26 <__addsf3>
    2470:	29 8d       	ldd	r18, Y+25	; 0x19
    2472:	3a 8d       	ldd	r19, Y+26	; 0x1a
    2474:	4b 8d       	ldd	r20, Y+27	; 0x1b
    2476:	5c 8d       	ldd	r21, Y+28	; 0x1c
    2478:	56 d5       	rcall	.+2732   	; 0x2f26 <__addsf3>
    247a:	2d 8d       	ldd	r18, Y+29	; 0x1d
    247c:	3e 8d       	ldd	r19, Y+30	; 0x1e
    247e:	4f 8d       	ldd	r20, Y+31	; 0x1f
    2480:	58 a1       	ldd	r21, Y+32	; 0x20
    2482:	51 d5       	rcall	.+2722   	; 0x2f26 <__addsf3>
    2484:	29 a1       	ldd	r18, Y+33	; 0x21
    2486:	3a a1       	ldd	r19, Y+34	; 0x22
    2488:	4b a1       	ldd	r20, Y+35	; 0x23
    248a:	5c a1       	ldd	r21, Y+36	; 0x24
    248c:	4c d5       	rcall	.+2712   	; 0x2f26 <__addsf3>
    248e:	2d a1       	ldd	r18, Y+37	; 0x25
    2490:	3e a1       	ldd	r19, Y+38	; 0x26
    2492:	4f a1       	ldd	r20, Y+39	; 0x27
    2494:	58 a5       	ldd	r21, Y+40	; 0x28
    2496:	47 d5       	rcall	.+2702   	; 0x2f26 <__addsf3>
    2498:	29 a5       	ldd	r18, Y+41	; 0x29
    249a:	3a a5       	ldd	r19, Y+42	; 0x2a
    249c:	4b a5       	ldd	r20, Y+43	; 0x2b
    249e:	5c a5       	ldd	r21, Y+44	; 0x2c
    24a0:	42 d5       	rcall	.+2692   	; 0x2f26 <__addsf3>
    24a2:	20 e0       	ldi	r18, 0x00	; 0
    24a4:	30 e0       	ldi	r19, 0x00	; 0
    24a6:	40 e3       	ldi	r20, 0x30	; 48
    24a8:	51 e4       	ldi	r21, 0x41	; 65
    24aa:	a5 d5       	rcall	.+2890   	; 0x2ff6 <__divsf3>
    24ac:	69 83       	std	Y+1, r22	; 0x01
    24ae:	7a 83       	std	Y+2, r23	; 0x02
    24b0:	8b 83       	std	Y+3, r24	; 0x03
    24b2:	9c 83       	std	Y+4, r25	; 0x04
				+ old4 + old5 + old6 + old7 + old8 + old9) / 11.0;
			old9 = old8;  old8 = old7;  old7 = old6;
			old6 = old5;  old5 = old4;  old4 = old3;
			old3 = old2;  old2 = old1;  old1 = old;  old = position;
			PORTG = PORTG ^ 1;
    24b4:	e5 e6       	ldi	r30, 0x65	; 101
    24b6:	f0 e0       	ldi	r31, 0x00	; 0
    24b8:	80 81       	ld	r24, Z
    24ba:	f1 e0       	ldi	r31, 0x01	; 1
    24bc:	8f 27       	eor	r24, r31
    24be:	e5 e6       	ldi	r30, 0x65	; 101
    24c0:	f0 e0       	ldi	r31, 0x00	; 0
 			xQueueSend (QueueSensor, &smooth_pos, portMAX_DELAY); 	
    24c2:	80 83       	st	Z, r24
    24c4:	20 e0       	ldi	r18, 0x00	; 0
    24c6:	4f ef       	ldi	r20, 0xFF	; 255
    24c8:	5f ef       	ldi	r21, 0xFF	; 255
    24ca:	be 01       	movw	r22, r28
    24cc:	6f 5f       	subi	r22, 0xFF	; 255
    24ce:	7f 4f       	sbci	r23, 0xFF	; 255
    24d0:	80 91 96 0a 	lds	r24, 0x0A96	; 0x800a96 <QueueSensor>
    24d4:	90 91 97 0a 	lds	r25, 0x0A97	; 0x800a97 <QueueSensor+0x1>
    24d8:	83 dd       	rcall	.-1274   	; 0x1fe0 <xQueueGenericSend>
		{ 
      if (zeros > 0)  position = pos_part / (float) zeros;
			else  position = 0.0;
			smooth_pos = (position + old + old1 + old2 + old3 \
				+ old4 + old5 + old6 + old7 + old8 + old9) / 11.0;
			old9 = old8;  old8 = old7;  old7 = old6;
    24da:	fd a1       	ldd	r31, Y+37	; 0x25
    24dc:	f9 a7       	std	Y+41, r31	; 0x29
    24de:	2e a1       	ldd	r18, Y+38	; 0x26
    24e0:	2a a7       	std	Y+42, r18	; 0x2a
    24e2:	4f a1       	ldd	r20, Y+39	; 0x27
    24e4:	4b a7       	std	Y+43, r20	; 0x2b
    24e6:	58 a5       	ldd	r21, Y+40	; 0x28
    24e8:	5c a7       	std	Y+44, r21	; 0x2c
    24ea:	89 a1       	ldd	r24, Y+33	; 0x21
    24ec:	8d a3       	std	Y+37, r24	; 0x25
    24ee:	9a a1       	ldd	r25, Y+34	; 0x22
    24f0:	9e a3       	std	Y+38, r25	; 0x26
    24f2:	eb a1       	ldd	r30, Y+35	; 0x23
    24f4:	ef a3       	std	Y+39, r30	; 0x27
    24f6:	fc a1       	ldd	r31, Y+36	; 0x24
    24f8:	f8 a7       	std	Y+40, r31	; 0x28
    24fa:	2d 8d       	ldd	r18, Y+29	; 0x1d
    24fc:	29 a3       	std	Y+33, r18	; 0x21
    24fe:	4e 8d       	ldd	r20, Y+30	; 0x1e
    2500:	4a a3       	std	Y+34, r20	; 0x22
    2502:	5f 8d       	ldd	r21, Y+31	; 0x1f
    2504:	5b a3       	std	Y+35, r21	; 0x23
    2506:	88 a1       	ldd	r24, Y+32	; 0x20
    2508:	8c a3       	std	Y+36, r24	; 0x24
			old6 = old5;  old5 = old4;  old4 = old3;
    250a:	99 8d       	ldd	r25, Y+25	; 0x19
    250c:	9d 8f       	std	Y+29, r25	; 0x1d
    250e:	ea 8d       	ldd	r30, Y+26	; 0x1a
    2510:	ee 8f       	std	Y+30, r30	; 0x1e
    2512:	fb 8d       	ldd	r31, Y+27	; 0x1b
    2514:	ff 8f       	std	Y+31, r31	; 0x1f
    2516:	2c 8d       	ldd	r18, Y+28	; 0x1c
    2518:	28 a3       	std	Y+32, r18	; 0x20
    251a:	4d 89       	ldd	r20, Y+21	; 0x15
    251c:	49 8f       	std	Y+25, r20	; 0x19
    251e:	5e 89       	ldd	r21, Y+22	; 0x16
    2520:	5a 8f       	std	Y+26, r21	; 0x1a
    2522:	8f 89       	ldd	r24, Y+23	; 0x17
    2524:	8b 8f       	std	Y+27, r24	; 0x1b
    2526:	98 8d       	ldd	r25, Y+24	; 0x18
    2528:	9c 8f       	std	Y+28, r25	; 0x1c
    252a:	e9 89       	ldd	r30, Y+17	; 0x11
    252c:	ed 8b       	std	Y+21, r30	; 0x15
    252e:	fa 89       	ldd	r31, Y+18	; 0x12
    2530:	fe 8b       	std	Y+22, r31	; 0x16
    2532:	2b 89       	ldd	r18, Y+19	; 0x13
    2534:	2f 8b       	std	Y+23, r18	; 0x17
    2536:	4c 89       	ldd	r20, Y+20	; 0x14
    2538:	48 8f       	std	Y+24, r20	; 0x18
			old3 = old2;  old2 = old1;  old1 = old;  old = position;
    253a:	5d 85       	ldd	r21, Y+13	; 0x0d
    253c:	59 8b       	std	Y+17, r21	; 0x11
    253e:	8e 85       	ldd	r24, Y+14	; 0x0e
    2540:	8a 8b       	std	Y+18, r24	; 0x12
    2542:	9f 85       	ldd	r25, Y+15	; 0x0f
    2544:	9b 8b       	std	Y+19, r25	; 0x13
    2546:	e8 89       	ldd	r30, Y+16	; 0x10
    2548:	ec 8b       	std	Y+20, r30	; 0x14
    254a:	f9 85       	ldd	r31, Y+9	; 0x09
    254c:	fd 87       	std	Y+13, r31	; 0x0d
    254e:	2a 85       	ldd	r18, Y+10	; 0x0a
    2550:	2e 87       	std	Y+14, r18	; 0x0e
    2552:	4b 85       	ldd	r20, Y+11	; 0x0b
    2554:	4f 87       	std	Y+15, r20	; 0x0f
    2556:	5c 85       	ldd	r21, Y+12	; 0x0c
    2558:	58 8b       	std	Y+16, r21	; 0x10
    255a:	8d 81       	ldd	r24, Y+5	; 0x05
    255c:	89 87       	std	Y+9, r24	; 0x09
    255e:	9e 81       	ldd	r25, Y+6	; 0x06
    2560:	9a 87       	std	Y+10, r25	; 0x0a
    2562:	ef 81       	ldd	r30, Y+7	; 0x07
    2564:	eb 87       	std	Y+11, r30	; 0x0b
    2566:	f8 85       	ldd	r31, Y+8	; 0x08
    2568:	fc 87       	std	Y+12, r31	; 0x0c
    256a:	fd 82       	std	Y+5, r15	; 0x05
    256c:	0e 83       	std	Y+6, r16	; 0x06
    256e:	1f 83       	std	Y+7, r17	; 0x07
    2570:	e8 86       	std	Y+8, r14	; 0x08
			PORTG = PORTG ^ 1;
 			xQueueSend (QueueSensor, &smooth_pos, portMAX_DELAY); 	
 			led = 0;  zeros = 0;  pos_part = 0.0;
    2572:	a1 2c       	mov	r10, r1
    2574:	b1 2c       	mov	r11, r1
    2576:	91 2c       	mov	r9, r1
    2578:	61 2c       	mov	r6, r1
    257a:	71 2c       	mov	r7, r1
    257c:	81 2c       	mov	r8, r1
		}  // end if
		// Switch the real LED values and keep attention to servo ISR
		cli();  PORTC = (1 << led) | (PORTC & 0b10000000);  sei();
    257e:	f8 94       	cli
    2580:	25 b3       	in	r18, 0x15	; 21
    2582:	81 e0       	ldi	r24, 0x01	; 1
    2584:	90 e0       	ldi	r25, 0x00	; 0
    2586:	08 2c       	mov	r0, r8
    2588:	02 c0       	rjmp	.+4      	; 0x258e <vSensor+0x2d0>
    258a:	88 0f       	add	r24, r24
    258c:	99 1f       	adc	r25, r25
    258e:	0a 94       	dec	r0
    2590:	e2 f7       	brpl	.-8      	; 0x258a <vSensor+0x2cc>
    2592:	92 2f       	mov	r25, r18
    2594:	90 78       	andi	r25, 0x80	; 128
    2596:	89 2b       	or	r24, r25
    2598:	85 bb       	out	0x15, r24	; 21
    259a:	78 94       	sei
  } // end
    259c:	d2 ce       	rjmp	.-604    	; 0x2342 <vSensor+0x84>

0000259e <vServo>:
} // end task

//----------------------------------------------------------
void  vServo ( void * pvParameters)
{ unsigned int  MIDPOS = 356;
    259e:	cf 93       	push	r28
    25a0:	df 93       	push	r29
    25a2:	00 d0       	rcall	.+0      	; 0x25a4 <vServo+0x6>
    25a4:	00 d0       	rcall	.+0      	; 0x25a6 <vServo+0x8>
    25a6:	cd b7       	in	r28, 0x3d	; 61
    25a8:	de b7       	in	r29, 0x3e	; 62
		if (beta > +1.0)  beta = +1.0;
		if (beta < -1.0)  beta = -1.0;
		// Give the value to global var
		angle = beta;
		// Generate timer compare value of servo signal
 		OCR3A = MIDPOS; // check horizontal position of BoiP
    25aa:	0f 2e       	mov	r0, r31
    25ac:	f6 e8       	ldi	r31, 0x86	; 134
    25ae:	af 2e       	mov	r10, r31
    25b0:	b1 2c       	mov	r11, r1
    25b2:	f0 2d       	mov	r31, r0
    25b4:	04 e6       	ldi	r16, 0x64	; 100
    25b6:	11 e0       	ldi	r17, 0x01	; 1
void  vServo ( void * pvParameters)
{ unsigned int  MIDPOS = 356;
  float  DELTA = 125.0, beta;
  for (;;)  // Super-Loop
  { // Read sensor data from queue
    xQueueReceive (QueueServo, &beta, portMAX_DELAY); 
    25b8:	20 e0       	ldi	r18, 0x00	; 0
    25ba:	4f ef       	ldi	r20, 0xFF	; 255
    25bc:	5f ef       	ldi	r21, 0xFF	; 255
    25be:	be 01       	movw	r22, r28
    25c0:	6f 5f       	subi	r22, 0xFF	; 255
    25c2:	7f 4f       	sbci	r23, 0xFF	; 255
    25c4:	80 91 94 0a 	lds	r24, 0x0A94	; 0x800a94 <QueueServo>
    25c8:	90 91 95 0a 	lds	r25, 0x0A95	; 0x800a95 <QueueServo+0x1>
    25cc:	b6 dd       	rcall	.-1172   	; 0x213a <xQueueGenericReceive>
		// Check the limit of the value
		if (beta > +1.0)  beta = +1.0;
    25ce:	c9 80       	ldd	r12, Y+1	; 0x01
    25d0:	da 80       	ldd	r13, Y+2	; 0x02
    25d2:	eb 80       	ldd	r14, Y+3	; 0x03
    25d4:	fc 80       	ldd	r15, Y+4	; 0x04
    25d6:	20 e0       	ldi	r18, 0x00	; 0
    25d8:	30 e0       	ldi	r19, 0x00	; 0
    25da:	40 e8       	ldi	r20, 0x80	; 128
    25dc:	5f e3       	ldi	r21, 0x3F	; 63
    25de:	c7 01       	movw	r24, r14
    25e0:	b6 01       	movw	r22, r12
    25e2:	54 d6       	rcall	.+3240   	; 0x328c <__gesf2>
    25e4:	18 16       	cp	r1, r24
    25e6:	4c f4       	brge	.+18     	; 0x25fa <vServo+0x5c>
    25e8:	80 e0       	ldi	r24, 0x00	; 0
    25ea:	90 e0       	ldi	r25, 0x00	; 0
    25ec:	a0 e8       	ldi	r26, 0x80	; 128
    25ee:	bf e3       	ldi	r27, 0x3F	; 63
    25f0:	89 83       	std	Y+1, r24	; 0x01
    25f2:	9a 83       	std	Y+2, r25	; 0x02
    25f4:	ab 83       	std	Y+3, r26	; 0x03
    25f6:	bc 83       	std	Y+4, r27	; 0x04
    25f8:	11 c0       	rjmp	.+34     	; 0x261c <vServo+0x7e>
		if (beta < -1.0)  beta = -1.0;
    25fa:	20 e0       	ldi	r18, 0x00	; 0
    25fc:	30 e0       	ldi	r19, 0x00	; 0
    25fe:	40 e8       	ldi	r20, 0x80	; 128
    2600:	5f eb       	ldi	r21, 0xBF	; 191
    2602:	c7 01       	movw	r24, r14
    2604:	b6 01       	movw	r22, r12
    2606:	f3 d4       	rcall	.+2534   	; 0x2fee <__cmpsf2>
    2608:	88 23       	and	r24, r24
    260a:	44 f4       	brge	.+16     	; 0x261c <vServo+0x7e>
    260c:	80 e0       	ldi	r24, 0x00	; 0
    260e:	90 e0       	ldi	r25, 0x00	; 0
    2610:	a0 e8       	ldi	r26, 0x80	; 128
    2612:	bf eb       	ldi	r27, 0xBF	; 191
    2614:	89 83       	std	Y+1, r24	; 0x01
    2616:	9a 83       	std	Y+2, r25	; 0x02
    2618:	ab 83       	std	Y+3, r26	; 0x03
    261a:	bc 83       	std	Y+4, r27	; 0x04
		// Give the value to global var
		angle = beta;
    261c:	89 81       	ldd	r24, Y+1	; 0x01
    261e:	9a 81       	ldd	r25, Y+2	; 0x02
    2620:	ab 81       	ldd	r26, Y+3	; 0x03
    2622:	bc 81       	ldd	r27, Y+4	; 0x04
    2624:	80 93 a5 0a 	sts	0x0AA5, r24	; 0x800aa5 <angle>
    2628:	90 93 a6 0a 	sts	0x0AA6, r25	; 0x800aa6 <angle+0x1>
    262c:	a0 93 a7 0a 	sts	0x0AA7, r26	; 0x800aa7 <angle+0x2>
    2630:	b0 93 a8 0a 	sts	0x0AA8, r27	; 0x800aa8 <angle+0x3>
		// Generate timer compare value of servo signal
 		OCR3A = MIDPOS; // check horizontal position of BoiP
    2634:	f5 01       	movw	r30, r10
    2636:	11 83       	std	Z+1, r17	; 0x01
    2638:	00 83       	st	Z, r16
 		OCR3A = (unsigned int) (MIDPOS - (int)(beta * DELTA));
    263a:	20 e0       	ldi	r18, 0x00	; 0
    263c:	30 e0       	ldi	r19, 0x00	; 0
    263e:	4a ef       	ldi	r20, 0xFA	; 250
    2640:	52 e4       	ldi	r21, 0x42	; 66
    2642:	69 81       	ldd	r22, Y+1	; 0x01
    2644:	7a 81       	ldd	r23, Y+2	; 0x02
    2646:	8b 81       	ldd	r24, Y+3	; 0x03
    2648:	9c 81       	ldd	r25, Y+4	; 0x04
    264a:	24 d6       	rcall	.+3144   	; 0x3294 <__mulsf3>
    264c:	3c d5       	rcall	.+2680   	; 0x30c6 <__fixsfsi>
    264e:	c8 01       	movw	r24, r16
    2650:	86 1b       	sub	r24, r22
    2652:	97 0b       	sbc	r25, r23
    2654:	f5 01       	movw	r30, r10
    2656:	91 83       	std	Z+1, r25	; 0x01
    2658:	80 83       	st	Z, r24
  } // end for
    265a:	ae cf       	rjmp	.-164    	; 0x25b8 <vServo+0x1a>

0000265c <prvIdleTask>:
			listGET_OWNER_OF_NEXT_ENTRY( pxTCB, &xSuspendedTaskList );
			vListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) );

			prvDeleteTCB( ( tskTCB * ) pxTCB );
		}		
	}
    265c:	cd e0       	ldi	r28, 0x0D	; 13
    265e:	da e0       	ldi	r29, 0x0A	; 10
    2660:	88 81       	ld	r24, Y
    2662:	82 30       	cpi	r24, 0x02	; 2
    2664:	e8 f3       	brcs	.-6      	; 0x2660 <prvIdleTask+0x4>
    2666:	14 db       	rcall	.-2520   	; 0x1c90 <vPortYield>
    2668:	fb cf       	rjmp	.-10     	; 0x2660 <prvIdleTask+0x4>

0000266a <xTaskCreate>:
    266a:	6f 92       	push	r6
    266c:	7f 92       	push	r7
    266e:	8f 92       	push	r8
    2670:	9f 92       	push	r9
    2672:	af 92       	push	r10
    2674:	bf 92       	push	r11
    2676:	cf 92       	push	r12
    2678:	df 92       	push	r13
    267a:	ef 92       	push	r14
    267c:	ff 92       	push	r15
    267e:	0f 93       	push	r16
    2680:	1f 93       	push	r17
    2682:	cf 93       	push	r28
    2684:	df 93       	push	r29
    2686:	4c 01       	movw	r8, r24
    2688:	5b 01       	movw	r10, r22
    268a:	6a 01       	movw	r12, r20
    268c:	39 01       	movw	r6, r18
    268e:	85 e2       	ldi	r24, 0x25	; 37
    2690:	90 e0       	ldi	r25, 0x00	; 0
    2692:	0e 94 9a 02 	call	0x534	; 0x534 <pvPortMalloc>
    2696:	ec 01       	movw	r28, r24
    2698:	89 2b       	or	r24, r25
    269a:	09 f4       	brne	.+2      	; 0x269e <xTaskCreate+0x34>
    269c:	b3 c0       	rjmp	.+358    	; 0x2804 <xTaskCreate+0x19a>
    269e:	c6 01       	movw	r24, r12
    26a0:	0e 94 9a 02 	call	0x534	; 0x534 <pvPortMalloc>
    26a4:	98 8f       	std	Y+24, r25	; 0x18
    26a6:	8f 8b       	std	Y+23, r24	; 0x17
    26a8:	00 97       	sbiw	r24, 0x00	; 0
    26aa:	21 f4       	brne	.+8      	; 0x26b4 <xTaskCreate+0x4a>
    26ac:	ce 01       	movw	r24, r28
    26ae:	0e 94 c0 02 	call	0x580	; 0x580 <vPortFree>
    26b2:	a8 c0       	rjmp	.+336    	; 0x2804 <xTaskCreate+0x19a>
    26b4:	a6 01       	movw	r20, r12
    26b6:	65 ea       	ldi	r22, 0xA5	; 165
    26b8:	70 e0       	ldi	r23, 0x00	; 0
    26ba:	8c d6       	rcall	.+3352   	; 0x33d4 <memset>
    26bc:	4c e0       	ldi	r20, 0x0C	; 12
    26be:	50 e0       	ldi	r21, 0x00	; 0
    26c0:	b5 01       	movw	r22, r10
    26c2:	ce 01       	movw	r24, r28
    26c4:	49 96       	adiw	r24, 0x19	; 25
    26c6:	8d d6       	rcall	.+3354   	; 0x33e2 <strncpy>
    26c8:	1c a2       	std	Y+36, r1	; 0x24
    26ca:	10 2f       	mov	r17, r16
    26cc:	04 30       	cpi	r16, 0x04	; 4
    26ce:	08 f0       	brcs	.+2      	; 0x26d2 <xTaskCreate+0x68>
    26d0:	13 e0       	ldi	r17, 0x03	; 3
    26d2:	1e 8b       	std	Y+22, r17	; 0x16
    26d4:	5e 01       	movw	r10, r28
    26d6:	82 e0       	ldi	r24, 0x02	; 2
    26d8:	a8 0e       	add	r10, r24
    26da:	b1 1c       	adc	r11, r1
    26dc:	c5 01       	movw	r24, r10
    26de:	de d8       	rcall	.-3652   	; 0x189c <vListInitialiseItem>
    26e0:	ce 01       	movw	r24, r28
    26e2:	0c 96       	adiw	r24, 0x0c	; 12
    26e4:	db d8       	rcall	.-3658   	; 0x189c <vListInitialiseItem>
    26e6:	d9 87       	std	Y+9, r29	; 0x09
    26e8:	c8 87       	std	Y+8, r28	; 0x08
    26ea:	84 e0       	ldi	r24, 0x04	; 4
    26ec:	90 e0       	ldi	r25, 0x00	; 0
    26ee:	81 1b       	sub	r24, r17
    26f0:	91 09       	sbc	r25, r1
    26f2:	9d 87       	std	Y+13, r25	; 0x0d
    26f4:	8c 87       	std	Y+12, r24	; 0x0c
    26f6:	db 8b       	std	Y+19, r29	; 0x13
    26f8:	ca 8b       	std	Y+18, r28	; 0x12
    26fa:	e1 e0       	ldi	r30, 0x01	; 1
    26fc:	ce 1a       	sub	r12, r30
    26fe:	d1 08       	sbc	r13, r1
    2700:	8f 89       	ldd	r24, Y+23	; 0x17
    2702:	98 8d       	ldd	r25, Y+24	; 0x18
    2704:	a3 01       	movw	r20, r6
    2706:	b4 01       	movw	r22, r8
    2708:	8c 0d       	add	r24, r12
    270a:	9d 1d       	adc	r25, r13
    270c:	1f da       	rcall	.-3010   	; 0x1b4c <pxPortInitialiseStack>
    270e:	99 83       	std	Y+1, r25	; 0x01
    2710:	88 83       	st	Y, r24
    2712:	0f b6       	in	r0, 0x3f	; 63
    2714:	f8 94       	cli
    2716:	0f 92       	push	r0
    2718:	80 91 e4 09 	lds	r24, 0x09E4	; 0x8009e4 <uxCurrentNumberOfTasks>
    271c:	8f 5f       	subi	r24, 0xFF	; 255
    271e:	80 93 e4 09 	sts	0x09E4, r24	; 0x8009e4 <uxCurrentNumberOfTasks>
    2722:	80 91 e4 09 	lds	r24, 0x09E4	; 0x8009e4 <uxCurrentNumberOfTasks>
    2726:	81 30       	cpi	r24, 0x01	; 1
    2728:	49 f5       	brne	.+82     	; 0x277c <xTaskCreate+0x112>
    272a:	d0 93 32 0a 	sts	0x0A32, r29	; 0x800a32 <pxCurrentTCB+0x1>
    272e:	c0 93 31 0a 	sts	0x0A31, r28	; 0x800a31 <pxCurrentTCB>
    2732:	8d e0       	ldi	r24, 0x0D	; 13
    2734:	9a e0       	ldi	r25, 0x0A	; 10
    2736:	a4 d8       	rcall	.-3768   	; 0x1880 <vListInitialise>
    2738:	86 e1       	ldi	r24, 0x16	; 22
    273a:	9a e0       	ldi	r25, 0x0A	; 10
    273c:	a1 d8       	rcall	.-3774   	; 0x1880 <vListInitialise>
    273e:	8f e1       	ldi	r24, 0x1F	; 31
    2740:	9a e0       	ldi	r25, 0x0A	; 10
    2742:	9e d8       	rcall	.-3780   	; 0x1880 <vListInitialise>
    2744:	88 e2       	ldi	r24, 0x28	; 40
    2746:	9a e0       	ldi	r25, 0x0A	; 10
    2748:	9b d8       	rcall	.-3786   	; 0x1880 <vListInitialise>
    274a:	84 e0       	ldi	r24, 0x04	; 4
    274c:	9a e0       	ldi	r25, 0x0A	; 10
    274e:	98 d8       	rcall	.-3792   	; 0x1880 <vListInitialise>
    2750:	8b ef       	ldi	r24, 0xFB	; 251
    2752:	99 e0       	ldi	r25, 0x09	; 9
    2754:	95 d8       	rcall	.-3798   	; 0x1880 <vListInitialise>
    2756:	8e ee       	ldi	r24, 0xEE	; 238
    2758:	99 e0       	ldi	r25, 0x09	; 9
    275a:	92 d8       	rcall	.-3804   	; 0x1880 <vListInitialise>
    275c:	85 ee       	ldi	r24, 0xE5	; 229
    275e:	99 e0       	ldi	r25, 0x09	; 9
    2760:	8f d8       	rcall	.-3810   	; 0x1880 <vListInitialise>
    2762:	84 e0       	ldi	r24, 0x04	; 4
    2764:	9a e0       	ldi	r25, 0x0A	; 10
    2766:	90 93 fa 09 	sts	0x09FA, r25	; 0x8009fa <pxDelayedTaskList+0x1>
    276a:	80 93 f9 09 	sts	0x09F9, r24	; 0x8009f9 <pxDelayedTaskList>
    276e:	8b ef       	ldi	r24, 0xFB	; 251
    2770:	99 e0       	ldi	r25, 0x09	; 9
    2772:	90 93 f8 09 	sts	0x09F8, r25	; 0x8009f8 <pxOverflowDelayedTaskList+0x1>
    2776:	80 93 f7 09 	sts	0x09F7, r24	; 0x8009f7 <pxOverflowDelayedTaskList>
    277a:	0f c0       	rjmp	.+30     	; 0x279a <xTaskCreate+0x130>
    277c:	80 91 df 09 	lds	r24, 0x09DF	; 0x8009df <xSchedulerRunning>
    2780:	81 11       	cpse	r24, r1
    2782:	0b c0       	rjmp	.+22     	; 0x279a <xTaskCreate+0x130>
    2784:	e0 91 31 0a 	lds	r30, 0x0A31	; 0x800a31 <pxCurrentTCB>
    2788:	f0 91 32 0a 	lds	r31, 0x0A32	; 0x800a32 <pxCurrentTCB+0x1>
    278c:	86 89       	ldd	r24, Z+22	; 0x16
    278e:	08 17       	cp	r16, r24
    2790:	20 f0       	brcs	.+8      	; 0x279a <xTaskCreate+0x130>
    2792:	d0 93 32 0a 	sts	0x0A32, r29	; 0x800a32 <pxCurrentTCB+0x1>
    2796:	c0 93 31 0a 	sts	0x0A31, r28	; 0x800a31 <pxCurrentTCB>
    279a:	8e 89       	ldd	r24, Y+22	; 0x16
    279c:	90 91 e1 09 	lds	r25, 0x09E1	; 0x8009e1 <uxTopUsedPriority>
    27a0:	98 17       	cp	r25, r24
    27a2:	10 f4       	brcc	.+4      	; 0x27a8 <xTaskCreate+0x13e>
    27a4:	80 93 e1 09 	sts	0x09E1, r24	; 0x8009e1 <uxTopUsedPriority>
    27a8:	90 91 e0 09 	lds	r25, 0x09E0	; 0x8009e0 <uxTopReadyPriority>
    27ac:	98 17       	cp	r25, r24
    27ae:	10 f4       	brcc	.+4      	; 0x27b4 <xTaskCreate+0x14a>
    27b0:	80 93 e0 09 	sts	0x09E0, r24	; 0x8009e0 <uxTopReadyPriority>
    27b4:	90 e0       	ldi	r25, 0x00	; 0
    27b6:	9c 01       	movw	r18, r24
    27b8:	22 0f       	add	r18, r18
    27ba:	33 1f       	adc	r19, r19
    27bc:	22 0f       	add	r18, r18
    27be:	33 1f       	adc	r19, r19
    27c0:	22 0f       	add	r18, r18
    27c2:	33 1f       	adc	r19, r19
    27c4:	82 0f       	add	r24, r18
    27c6:	93 1f       	adc	r25, r19
    27c8:	b5 01       	movw	r22, r10
    27ca:	83 5f       	subi	r24, 0xF3	; 243
    27cc:	95 4f       	sbci	r25, 0xF5	; 245
    27ce:	6a d8       	rcall	.-3884   	; 0x18a4 <vListInsertEnd>
    27d0:	0f 90       	pop	r0
    27d2:	0f be       	out	0x3f, r0	; 63
    27d4:	e1 14       	cp	r14, r1
    27d6:	f1 04       	cpc	r15, r1
    27d8:	19 f0       	breq	.+6      	; 0x27e0 <xTaskCreate+0x176>
    27da:	f7 01       	movw	r30, r14
    27dc:	d1 83       	std	Z+1, r29	; 0x01
    27de:	c0 83       	st	Z, r28
    27e0:	80 91 df 09 	lds	r24, 0x09DF	; 0x8009df <xSchedulerRunning>
    27e4:	88 23       	and	r24, r24
    27e6:	51 f0       	breq	.+20     	; 0x27fc <xTaskCreate+0x192>
    27e8:	e0 91 31 0a 	lds	r30, 0x0A31	; 0x800a31 <pxCurrentTCB>
    27ec:	f0 91 32 0a 	lds	r31, 0x0A32	; 0x800a32 <pxCurrentTCB+0x1>
    27f0:	86 89       	ldd	r24, Z+22	; 0x16
    27f2:	80 17       	cp	r24, r16
    27f4:	28 f4       	brcc	.+10     	; 0x2800 <xTaskCreate+0x196>
    27f6:	4c da       	rcall	.-2920   	; 0x1c90 <vPortYield>
    27f8:	81 e0       	ldi	r24, 0x01	; 1
    27fa:	05 c0       	rjmp	.+10     	; 0x2806 <xTaskCreate+0x19c>
    27fc:	81 e0       	ldi	r24, 0x01	; 1
    27fe:	03 c0       	rjmp	.+6      	; 0x2806 <xTaskCreate+0x19c>
    2800:	81 e0       	ldi	r24, 0x01	; 1
    2802:	01 c0       	rjmp	.+2      	; 0x2806 <xTaskCreate+0x19c>
    2804:	8f ef       	ldi	r24, 0xFF	; 255
    2806:	df 91       	pop	r29
    2808:	cf 91       	pop	r28
    280a:	1f 91       	pop	r17
    280c:	0f 91       	pop	r16
    280e:	ff 90       	pop	r15
    2810:	ef 90       	pop	r14
    2812:	df 90       	pop	r13
    2814:	cf 90       	pop	r12
    2816:	bf 90       	pop	r11
    2818:	af 90       	pop	r10
    281a:	9f 90       	pop	r9
    281c:	8f 90       	pop	r8
    281e:	7f 90       	pop	r7
    2820:	6f 90       	pop	r6
    2822:	08 95       	ret

00002824 <vTaskSuspend>:
    2824:	ef 92       	push	r14
    2826:	ff 92       	push	r15
    2828:	0f 93       	push	r16
    282a:	1f 93       	push	r17
    282c:	cf 93       	push	r28
    282e:	df 93       	push	r29
    2830:	ec 01       	movw	r28, r24
    2832:	0f b6       	in	r0, 0x3f	; 63
    2834:	f8 94       	cli
    2836:	0f 92       	push	r0
    2838:	80 91 31 0a 	lds	r24, 0x0A31	; 0x800a31 <pxCurrentTCB>
    283c:	90 91 32 0a 	lds	r25, 0x0A32	; 0x800a32 <pxCurrentTCB+0x1>
    2840:	8c 17       	cp	r24, r28
    2842:	9d 07       	cpc	r25, r29
    2844:	11 f0       	breq	.+4      	; 0x284a <vTaskSuspend+0x26>
    2846:	20 97       	sbiw	r28, 0x00	; 0
    2848:	39 f4       	brne	.+14     	; 0x2858 <vTaskSuspend+0x34>
    284a:	c0 91 31 0a 	lds	r28, 0x0A31	; 0x800a31 <pxCurrentTCB>
    284e:	d0 91 32 0a 	lds	r29, 0x0A32	; 0x800a32 <pxCurrentTCB+0x1>
    2852:	e1 2c       	mov	r14, r1
    2854:	f1 2c       	mov	r15, r1
    2856:	01 c0       	rjmp	.+2      	; 0x285a <vTaskSuspend+0x36>
    2858:	7e 01       	movw	r14, r28
    285a:	8e 01       	movw	r16, r28
    285c:	0e 5f       	subi	r16, 0xFE	; 254
    285e:	1f 4f       	sbci	r17, 0xFF	; 255
    2860:	c8 01       	movw	r24, r16
    2862:	82 d8       	rcall	.-3836   	; 0x1968 <vListRemove>
    2864:	8c 89       	ldd	r24, Y+20	; 0x14
    2866:	9d 89       	ldd	r25, Y+21	; 0x15
    2868:	89 2b       	or	r24, r25
    286a:	19 f0       	breq	.+6      	; 0x2872 <vTaskSuspend+0x4e>
    286c:	ce 01       	movw	r24, r28
    286e:	0c 96       	adiw	r24, 0x0c	; 12
    2870:	7b d8       	rcall	.-3850   	; 0x1968 <vListRemove>
    2872:	b8 01       	movw	r22, r16
    2874:	85 ee       	ldi	r24, 0xE5	; 229
    2876:	99 e0       	ldi	r25, 0x09	; 9
    2878:	15 d8       	rcall	.-4054   	; 0x18a4 <vListInsertEnd>
    287a:	0f 90       	pop	r0
    287c:	0f be       	out	0x3f, r0	; 63
    287e:	ef 28       	or	r14, r15
    2880:	09 f4       	brne	.+2      	; 0x2884 <vTaskSuspend+0x60>
    2882:	06 da       	rcall	.-3060   	; 0x1c90 <vPortYield>
    2884:	df 91       	pop	r29
    2886:	cf 91       	pop	r28
    2888:	1f 91       	pop	r17
    288a:	0f 91       	pop	r16
    288c:	ff 90       	pop	r15
    288e:	ef 90       	pop	r14
    2890:	08 95       	ret

00002892 <xTaskIsTaskSuspended>:
    2892:	fc 01       	movw	r30, r24
    2894:	22 85       	ldd	r18, Z+10	; 0x0a
    2896:	33 85       	ldd	r19, Z+11	; 0x0b
    2898:	25 5e       	subi	r18, 0xE5	; 229
    289a:	39 40       	sbci	r19, 0x09	; 9
    289c:	61 f4       	brne	.+24     	; 0x28b6 <xTaskIsTaskSuspended+0x24>
    289e:	fc 01       	movw	r30, r24
    28a0:	24 89       	ldd	r18, Z+20	; 0x14
    28a2:	35 89       	ldd	r19, Z+21	; 0x15
    28a4:	f9 e0       	ldi	r31, 0x09	; 9
    28a6:	2e 3e       	cpi	r18, 0xEE	; 238
    28a8:	3f 07       	cpc	r19, r31
    28aa:	39 f0       	breq	.+14     	; 0x28ba <xTaskIsTaskSuspended+0x28>
    28ac:	81 e0       	ldi	r24, 0x01	; 1
    28ae:	23 2b       	or	r18, r19
    28b0:	29 f0       	breq	.+10     	; 0x28bc <xTaskIsTaskSuspended+0x2a>
    28b2:	80 e0       	ldi	r24, 0x00	; 0
    28b4:	08 95       	ret
    28b6:	80 e0       	ldi	r24, 0x00	; 0
    28b8:	08 95       	ret
    28ba:	80 e0       	ldi	r24, 0x00	; 0
    28bc:	08 95       	ret

000028be <vTaskResume>:
    28be:	0f 93       	push	r16
    28c0:	1f 93       	push	r17
    28c2:	cf 93       	push	r28
    28c4:	df 93       	push	r29
    28c6:	00 97       	sbiw	r24, 0x00	; 0
    28c8:	a1 f1       	breq	.+104    	; 0x2932 <vTaskResume+0x74>
    28ca:	20 91 31 0a 	lds	r18, 0x0A31	; 0x800a31 <pxCurrentTCB>
    28ce:	30 91 32 0a 	lds	r19, 0x0A32	; 0x800a32 <pxCurrentTCB+0x1>
    28d2:	82 17       	cp	r24, r18
    28d4:	93 07       	cpc	r25, r19
    28d6:	69 f1       	breq	.+90     	; 0x2932 <vTaskResume+0x74>
    28d8:	ec 01       	movw	r28, r24
    28da:	0f b6       	in	r0, 0x3f	; 63
    28dc:	f8 94       	cli
    28de:	0f 92       	push	r0
    28e0:	d8 df       	rcall	.-80     	; 0x2892 <xTaskIsTaskSuspended>
    28e2:	81 30       	cpi	r24, 0x01	; 1
    28e4:	21 f5       	brne	.+72     	; 0x292e <vTaskResume+0x70>
    28e6:	8e 01       	movw	r16, r28
    28e8:	0e 5f       	subi	r16, 0xFE	; 254
    28ea:	1f 4f       	sbci	r17, 0xFF	; 255
    28ec:	c8 01       	movw	r24, r16
    28ee:	3c d8       	rcall	.-3976   	; 0x1968 <vListRemove>
    28f0:	8e 89       	ldd	r24, Y+22	; 0x16
    28f2:	90 91 e0 09 	lds	r25, 0x09E0	; 0x8009e0 <uxTopReadyPriority>
    28f6:	98 17       	cp	r25, r24
    28f8:	10 f4       	brcc	.+4      	; 0x28fe <vTaskResume+0x40>
    28fa:	80 93 e0 09 	sts	0x09E0, r24	; 0x8009e0 <uxTopReadyPriority>
    28fe:	90 e0       	ldi	r25, 0x00	; 0
    2900:	9c 01       	movw	r18, r24
    2902:	22 0f       	add	r18, r18
    2904:	33 1f       	adc	r19, r19
    2906:	22 0f       	add	r18, r18
    2908:	33 1f       	adc	r19, r19
    290a:	22 0f       	add	r18, r18
    290c:	33 1f       	adc	r19, r19
    290e:	82 0f       	add	r24, r18
    2910:	93 1f       	adc	r25, r19
    2912:	b8 01       	movw	r22, r16
    2914:	83 5f       	subi	r24, 0xF3	; 243
    2916:	95 4f       	sbci	r25, 0xF5	; 245
    2918:	0e 94 52 0c 	call	0x18a4	; 0x18a4 <vListInsertEnd>
    291c:	e0 91 31 0a 	lds	r30, 0x0A31	; 0x800a31 <pxCurrentTCB>
    2920:	f0 91 32 0a 	lds	r31, 0x0A32	; 0x800a32 <pxCurrentTCB+0x1>
    2924:	9e 89       	ldd	r25, Y+22	; 0x16
    2926:	86 89       	ldd	r24, Z+22	; 0x16
    2928:	98 17       	cp	r25, r24
    292a:	08 f0       	brcs	.+2      	; 0x292e <vTaskResume+0x70>
    292c:	b1 d9       	rcall	.-3230   	; 0x1c90 <vPortYield>
    292e:	0f 90       	pop	r0
    2930:	0f be       	out	0x3f, r0	; 63
    2932:	df 91       	pop	r29
    2934:	cf 91       	pop	r28
    2936:	1f 91       	pop	r17
    2938:	0f 91       	pop	r16
    293a:	08 95       	ret

0000293c <vTaskStartScheduler>:
    293c:	ef 92       	push	r14
    293e:	ff 92       	push	r15
    2940:	0f 93       	push	r16
    2942:	e1 2c       	mov	r14, r1
    2944:	f1 2c       	mov	r15, r1
    2946:	00 e0       	ldi	r16, 0x00	; 0
    2948:	20 e0       	ldi	r18, 0x00	; 0
    294a:	30 e0       	ldi	r19, 0x00	; 0
    294c:	45 e5       	ldi	r20, 0x55	; 85
    294e:	50 e0       	ldi	r21, 0x00	; 0
    2950:	64 ee       	ldi	r22, 0xE4	; 228
    2952:	71 e0       	ldi	r23, 0x01	; 1
    2954:	8e e2       	ldi	r24, 0x2E	; 46
    2956:	93 e1       	ldi	r25, 0x13	; 19
    2958:	88 de       	rcall	.-752    	; 0x266a <xTaskCreate>
    295a:	81 30       	cpi	r24, 0x01	; 1
    295c:	41 f4       	brne	.+16     	; 0x296e <vTaskStartScheduler+0x32>
    295e:	f8 94       	cli
    2960:	80 93 df 09 	sts	0x09DF, r24	; 0x8009df <xSchedulerRunning>
    2964:	10 92 e3 09 	sts	0x09E3, r1	; 0x8009e3 <xTickCount+0x1>
    2968:	10 92 e2 09 	sts	0x09E2, r1	; 0x8009e2 <xTickCount>
    296c:	5b d9       	rcall	.-3402   	; 0x1c24 <xPortStartScheduler>
    296e:	0f 91       	pop	r16
    2970:	ff 90       	pop	r15
    2972:	ef 90       	pop	r14
    2974:	08 95       	ret

00002976 <vTaskSuspendAll>:
    2976:	0f b6       	in	r0, 0x3f	; 63
    2978:	f8 94       	cli
    297a:	0f 92       	push	r0
    297c:	80 91 de 09 	lds	r24, 0x09DE	; 0x8009de <uxSchedulerSuspended>
    2980:	8f 5f       	subi	r24, 0xFF	; 255
    2982:	80 93 de 09 	sts	0x09DE, r24	; 0x8009de <uxSchedulerSuspended>
    2986:	0f 90       	pop	r0
    2988:	0f be       	out	0x3f, r0	; 63
    298a:	08 95       	ret

0000298c <vTaskIncrementTick>:
    298c:	0f 93       	push	r16
    298e:	1f 93       	push	r17
    2990:	cf 93       	push	r28
    2992:	df 93       	push	r29
    2994:	80 91 de 09 	lds	r24, 0x09DE	; 0x8009de <uxSchedulerSuspended>
    2998:	81 11       	cpse	r24, r1
    299a:	66 c0       	rjmp	.+204    	; 0x2a68 <vTaskIncrementTick+0xdc>
    299c:	80 91 e2 09 	lds	r24, 0x09E2	; 0x8009e2 <xTickCount>
    29a0:	90 91 e3 09 	lds	r25, 0x09E3	; 0x8009e3 <xTickCount+0x1>
    29a4:	01 96       	adiw	r24, 0x01	; 1
    29a6:	90 93 e3 09 	sts	0x09E3, r25	; 0x8009e3 <xTickCount+0x1>
    29aa:	80 93 e2 09 	sts	0x09E2, r24	; 0x8009e2 <xTickCount>
    29ae:	80 91 e2 09 	lds	r24, 0x09E2	; 0x8009e2 <xTickCount>
    29b2:	90 91 e3 09 	lds	r25, 0x09E3	; 0x8009e3 <xTickCount+0x1>
    29b6:	89 2b       	or	r24, r25
    29b8:	09 f0       	breq	.+2      	; 0x29bc <vTaskIncrementTick+0x30>
    29ba:	43 c0       	rjmp	.+134    	; 0x2a42 <vTaskIncrementTick+0xb6>
    29bc:	80 91 f9 09 	lds	r24, 0x09F9	; 0x8009f9 <pxDelayedTaskList>
    29c0:	90 91 fa 09 	lds	r25, 0x09FA	; 0x8009fa <pxDelayedTaskList+0x1>
    29c4:	20 91 f7 09 	lds	r18, 0x09F7	; 0x8009f7 <pxOverflowDelayedTaskList>
    29c8:	30 91 f8 09 	lds	r19, 0x09F8	; 0x8009f8 <pxOverflowDelayedTaskList+0x1>
    29cc:	30 93 fa 09 	sts	0x09FA, r19	; 0x8009fa <pxDelayedTaskList+0x1>
    29d0:	20 93 f9 09 	sts	0x09F9, r18	; 0x8009f9 <pxDelayedTaskList>
    29d4:	90 93 f8 09 	sts	0x09F8, r25	; 0x8009f8 <pxOverflowDelayedTaskList+0x1>
    29d8:	80 93 f7 09 	sts	0x09F7, r24	; 0x8009f7 <pxOverflowDelayedTaskList>
    29dc:	80 91 db 09 	lds	r24, 0x09DB	; 0x8009db <xNumOfOverflows>
    29e0:	8f 5f       	subi	r24, 0xFF	; 255
    29e2:	80 93 db 09 	sts	0x09DB, r24	; 0x8009db <xNumOfOverflows>
    29e6:	2d c0       	rjmp	.+90     	; 0x2a42 <vTaskIncrementTick+0xb6>
    29e8:	80 91 e2 09 	lds	r24, 0x09E2	; 0x8009e2 <xTickCount>
    29ec:	90 91 e3 09 	lds	r25, 0x09E3	; 0x8009e3 <xTickCount+0x1>
    29f0:	2a 81       	ldd	r18, Y+2	; 0x02
    29f2:	3b 81       	ldd	r19, Y+3	; 0x03
    29f4:	82 17       	cp	r24, r18
    29f6:	93 07       	cpc	r25, r19
    29f8:	f0 f1       	brcs	.+124    	; 0x2a76 <vTaskIncrementTick+0xea>
    29fa:	8e 01       	movw	r16, r28
    29fc:	0e 5f       	subi	r16, 0xFE	; 254
    29fe:	1f 4f       	sbci	r17, 0xFF	; 255
    2a00:	c8 01       	movw	r24, r16
    2a02:	0e 94 b4 0c 	call	0x1968	; 0x1968 <vListRemove>
    2a06:	8c 89       	ldd	r24, Y+20	; 0x14
    2a08:	9d 89       	ldd	r25, Y+21	; 0x15
    2a0a:	89 2b       	or	r24, r25
    2a0c:	21 f0       	breq	.+8      	; 0x2a16 <vTaskIncrementTick+0x8a>
    2a0e:	ce 01       	movw	r24, r28
    2a10:	0c 96       	adiw	r24, 0x0c	; 12
    2a12:	0e 94 b4 0c 	call	0x1968	; 0x1968 <vListRemove>
    2a16:	8e 89       	ldd	r24, Y+22	; 0x16
    2a18:	90 91 e0 09 	lds	r25, 0x09E0	; 0x8009e0 <uxTopReadyPriority>
    2a1c:	98 17       	cp	r25, r24
    2a1e:	10 f4       	brcc	.+4      	; 0x2a24 <vTaskIncrementTick+0x98>
    2a20:	80 93 e0 09 	sts	0x09E0, r24	; 0x8009e0 <uxTopReadyPriority>
    2a24:	90 e0       	ldi	r25, 0x00	; 0
    2a26:	9c 01       	movw	r18, r24
    2a28:	22 0f       	add	r18, r18
    2a2a:	33 1f       	adc	r19, r19
    2a2c:	22 0f       	add	r18, r18
    2a2e:	33 1f       	adc	r19, r19
    2a30:	22 0f       	add	r18, r18
    2a32:	33 1f       	adc	r19, r19
    2a34:	82 0f       	add	r24, r18
    2a36:	93 1f       	adc	r25, r19
    2a38:	b8 01       	movw	r22, r16
    2a3a:	83 5f       	subi	r24, 0xF3	; 243
    2a3c:	95 4f       	sbci	r25, 0xF5	; 245
    2a3e:	0e 94 52 0c 	call	0x18a4	; 0x18a4 <vListInsertEnd>
    2a42:	e0 91 f9 09 	lds	r30, 0x09F9	; 0x8009f9 <pxDelayedTaskList>
    2a46:	f0 91 fa 09 	lds	r31, 0x09FA	; 0x8009fa <pxDelayedTaskList+0x1>
    2a4a:	80 81       	ld	r24, Z
    2a4c:	88 23       	and	r24, r24
    2a4e:	99 f0       	breq	.+38     	; 0x2a76 <vTaskIncrementTick+0xea>
    2a50:	e0 91 f9 09 	lds	r30, 0x09F9	; 0x8009f9 <pxDelayedTaskList>
    2a54:	f0 91 fa 09 	lds	r31, 0x09FA	; 0x8009fa <pxDelayedTaskList+0x1>
    2a58:	05 80       	ldd	r0, Z+5	; 0x05
    2a5a:	f6 81       	ldd	r31, Z+6	; 0x06
    2a5c:	e0 2d       	mov	r30, r0
    2a5e:	c6 81       	ldd	r28, Z+6	; 0x06
    2a60:	d7 81       	ldd	r29, Z+7	; 0x07
    2a62:	20 97       	sbiw	r28, 0x00	; 0
    2a64:	09 f6       	brne	.-126    	; 0x29e8 <vTaskIncrementTick+0x5c>
    2a66:	07 c0       	rjmp	.+14     	; 0x2a76 <vTaskIncrementTick+0xea>
    2a68:	80 91 dd 09 	lds	r24, 0x09DD	; 0x8009dd <uxMissedTicks>
    2a6c:	8f 5f       	subi	r24, 0xFF	; 255
    2a6e:	80 93 dd 09 	sts	0x09DD, r24	; 0x8009dd <uxMissedTicks>
    2a72:	0e 94 7b 01 	call	0x2f6	; 0x2f6 <vApplicationTickHook>
    2a76:	80 91 dd 09 	lds	r24, 0x09DD	; 0x8009dd <uxMissedTicks>
    2a7a:	81 11       	cpse	r24, r1
    2a7c:	02 c0       	rjmp	.+4      	; 0x2a82 <vTaskIncrementTick+0xf6>
    2a7e:	0e 94 7b 01 	call	0x2f6	; 0x2f6 <vApplicationTickHook>
    2a82:	df 91       	pop	r29
    2a84:	cf 91       	pop	r28
    2a86:	1f 91       	pop	r17
    2a88:	0f 91       	pop	r16
    2a8a:	08 95       	ret

00002a8c <xTaskResumeAll>:
    2a8c:	cf 92       	push	r12
    2a8e:	df 92       	push	r13
    2a90:	ef 92       	push	r14
    2a92:	ff 92       	push	r15
    2a94:	0f 93       	push	r16
    2a96:	1f 93       	push	r17
    2a98:	cf 93       	push	r28
    2a9a:	df 93       	push	r29
    2a9c:	0f b6       	in	r0, 0x3f	; 63
    2a9e:	f8 94       	cli
    2aa0:	0f 92       	push	r0
    2aa2:	80 91 de 09 	lds	r24, 0x09DE	; 0x8009de <uxSchedulerSuspended>
    2aa6:	81 50       	subi	r24, 0x01	; 1
    2aa8:	80 93 de 09 	sts	0x09DE, r24	; 0x8009de <uxSchedulerSuspended>
    2aac:	80 91 de 09 	lds	r24, 0x09DE	; 0x8009de <uxSchedulerSuspended>
    2ab0:	81 11       	cpse	r24, r1
    2ab2:	63 c0       	rjmp	.+198    	; 0x2b7a <xTaskResumeAll+0xee>
    2ab4:	80 91 e4 09 	lds	r24, 0x09E4	; 0x8009e4 <uxCurrentNumberOfTasks>
    2ab8:	81 11       	cpse	r24, r1
    2aba:	2b c0       	rjmp	.+86     	; 0x2b12 <xTaskResumeAll+0x86>
    2abc:	61 c0       	rjmp	.+194    	; 0x2b80 <xTaskResumeAll+0xf4>
    2abe:	ce 01       	movw	r24, r28
    2ac0:	0c 96       	adiw	r24, 0x0c	; 12
    2ac2:	0e 94 b4 0c 	call	0x1968	; 0x1968 <vListRemove>
    2ac6:	8e 01       	movw	r16, r28
    2ac8:	0e 5f       	subi	r16, 0xFE	; 254
    2aca:	1f 4f       	sbci	r17, 0xFF	; 255
    2acc:	c8 01       	movw	r24, r16
    2ace:	0e 94 b4 0c 	call	0x1968	; 0x1968 <vListRemove>
    2ad2:	8e 89       	ldd	r24, Y+22	; 0x16
    2ad4:	90 91 e0 09 	lds	r25, 0x09E0	; 0x8009e0 <uxTopReadyPriority>
    2ad8:	98 17       	cp	r25, r24
    2ada:	10 f4       	brcc	.+4      	; 0x2ae0 <xTaskResumeAll+0x54>
    2adc:	80 93 e0 09 	sts	0x09E0, r24	; 0x8009e0 <uxTopReadyPriority>
    2ae0:	90 e0       	ldi	r25, 0x00	; 0
    2ae2:	9c 01       	movw	r18, r24
    2ae4:	22 0f       	add	r18, r18
    2ae6:	33 1f       	adc	r19, r19
    2ae8:	22 0f       	add	r18, r18
    2aea:	33 1f       	adc	r19, r19
    2aec:	22 0f       	add	r18, r18
    2aee:	33 1f       	adc	r19, r19
    2af0:	82 0f       	add	r24, r18
    2af2:	93 1f       	adc	r25, r19
    2af4:	b8 01       	movw	r22, r16
    2af6:	83 5f       	subi	r24, 0xF3	; 243
    2af8:	95 4f       	sbci	r25, 0xF5	; 245
    2afa:	0e 94 52 0c 	call	0x18a4	; 0x18a4 <vListInsertEnd>
    2afe:	e0 91 31 0a 	lds	r30, 0x0A31	; 0x800a31 <pxCurrentTCB>
    2b02:	f0 91 32 0a 	lds	r31, 0x0A32	; 0x800a32 <pxCurrentTCB+0x1>
    2b06:	9e 89       	ldd	r25, Y+22	; 0x16
    2b08:	86 89       	ldd	r24, Z+22	; 0x16
    2b0a:	98 17       	cp	r25, r24
    2b0c:	58 f0       	brcs	.+22     	; 0x2b24 <xTaskResumeAll+0x98>
    2b0e:	dc 2c       	mov	r13, r12
    2b10:	09 c0       	rjmp	.+18     	; 0x2b24 <xTaskResumeAll+0x98>
    2b12:	d1 2c       	mov	r13, r1
    2b14:	0f 2e       	mov	r0, r31
    2b16:	fe ee       	ldi	r31, 0xEE	; 238
    2b18:	ef 2e       	mov	r14, r31
    2b1a:	f9 e0       	ldi	r31, 0x09	; 9
    2b1c:	ff 2e       	mov	r15, r31
    2b1e:	f0 2d       	mov	r31, r0
    2b20:	cc 24       	eor	r12, r12
    2b22:	c3 94       	inc	r12
    2b24:	d7 01       	movw	r26, r14
    2b26:	8c 91       	ld	r24, X
    2b28:	88 23       	and	r24, r24
    2b2a:	41 f0       	breq	.+16     	; 0x2b3c <xTaskResumeAll+0xb0>
    2b2c:	15 96       	adiw	r26, 0x05	; 5
    2b2e:	ed 91       	ld	r30, X+
    2b30:	fc 91       	ld	r31, X
    2b32:	16 97       	sbiw	r26, 0x06	; 6
    2b34:	c6 81       	ldd	r28, Z+6	; 0x06
    2b36:	d7 81       	ldd	r29, Z+7	; 0x07
    2b38:	20 97       	sbiw	r28, 0x00	; 0
    2b3a:	09 f6       	brne	.-126    	; 0x2abe <xTaskResumeAll+0x32>
    2b3c:	80 91 dd 09 	lds	r24, 0x09DD	; 0x8009dd <uxMissedTicks>
    2b40:	88 23       	and	r24, r24
    2b42:	79 f0       	breq	.+30     	; 0x2b62 <xTaskResumeAll+0xd6>
    2b44:	80 91 dd 09 	lds	r24, 0x09DD	; 0x8009dd <uxMissedTicks>
    2b48:	88 23       	and	r24, r24
    2b4a:	91 f0       	breq	.+36     	; 0x2b70 <xTaskResumeAll+0xe4>
    2b4c:	1f df       	rcall	.-450    	; 0x298c <vTaskIncrementTick>
    2b4e:	80 91 dd 09 	lds	r24, 0x09DD	; 0x8009dd <uxMissedTicks>
    2b52:	81 50       	subi	r24, 0x01	; 1
    2b54:	80 93 dd 09 	sts	0x09DD, r24	; 0x8009dd <uxMissedTicks>
    2b58:	80 91 dd 09 	lds	r24, 0x09DD	; 0x8009dd <uxMissedTicks>
    2b5c:	81 11       	cpse	r24, r1
    2b5e:	f6 cf       	rjmp	.-20     	; 0x2b4c <xTaskResumeAll+0xc0>
    2b60:	07 c0       	rjmp	.+14     	; 0x2b70 <xTaskResumeAll+0xe4>
    2b62:	b1 e0       	ldi	r27, 0x01	; 1
    2b64:	db 16       	cp	r13, r27
    2b66:	21 f0       	breq	.+8      	; 0x2b70 <xTaskResumeAll+0xe4>
    2b68:	80 91 dc 09 	lds	r24, 0x09DC	; 0x8009dc <xMissedYield>
    2b6c:	81 30       	cpi	r24, 0x01	; 1
    2b6e:	39 f4       	brne	.+14     	; 0x2b7e <xTaskResumeAll+0xf2>
    2b70:	10 92 dc 09 	sts	0x09DC, r1	; 0x8009dc <xMissedYield>
    2b74:	8d d8       	rcall	.-3814   	; 0x1c90 <vPortYield>
    2b76:	81 e0       	ldi	r24, 0x01	; 1
    2b78:	03 c0       	rjmp	.+6      	; 0x2b80 <xTaskResumeAll+0xf4>
    2b7a:	80 e0       	ldi	r24, 0x00	; 0
    2b7c:	01 c0       	rjmp	.+2      	; 0x2b80 <xTaskResumeAll+0xf4>
    2b7e:	80 e0       	ldi	r24, 0x00	; 0
    2b80:	0f 90       	pop	r0
    2b82:	0f be       	out	0x3f, r0	; 63
    2b84:	df 91       	pop	r29
    2b86:	cf 91       	pop	r28
    2b88:	1f 91       	pop	r17
    2b8a:	0f 91       	pop	r16
    2b8c:	ff 90       	pop	r15
    2b8e:	ef 90       	pop	r14
    2b90:	df 90       	pop	r13
    2b92:	cf 90       	pop	r12
    2b94:	08 95       	ret

00002b96 <vTaskDelay>:
    2b96:	cf 93       	push	r28
    2b98:	df 93       	push	r29
    2b9a:	ec 01       	movw	r28, r24
    2b9c:	89 2b       	or	r24, r25
    2b9e:	b9 f1       	breq	.+110    	; 0x2c0e <vTaskDelay+0x78>
    2ba0:	ea de       	rcall	.-556    	; 0x2976 <vTaskSuspendAll>
    2ba2:	80 91 e2 09 	lds	r24, 0x09E2	; 0x8009e2 <xTickCount>
    2ba6:	90 91 e3 09 	lds	r25, 0x09E3	; 0x8009e3 <xTickCount+0x1>
    2baa:	c8 0f       	add	r28, r24
    2bac:	d9 1f       	adc	r29, r25
    2bae:	80 91 31 0a 	lds	r24, 0x0A31	; 0x800a31 <pxCurrentTCB>
    2bb2:	90 91 32 0a 	lds	r25, 0x0A32	; 0x800a32 <pxCurrentTCB+0x1>
    2bb6:	02 96       	adiw	r24, 0x02	; 2
    2bb8:	0e 94 b4 0c 	call	0x1968	; 0x1968 <vListRemove>
    2bbc:	e0 91 31 0a 	lds	r30, 0x0A31	; 0x800a31 <pxCurrentTCB>
    2bc0:	f0 91 32 0a 	lds	r31, 0x0A32	; 0x800a32 <pxCurrentTCB+0x1>
    2bc4:	d3 83       	std	Z+3, r29	; 0x03
    2bc6:	c2 83       	std	Z+2, r28	; 0x02
    2bc8:	80 91 e2 09 	lds	r24, 0x09E2	; 0x8009e2 <xTickCount>
    2bcc:	90 91 e3 09 	lds	r25, 0x09E3	; 0x8009e3 <xTickCount+0x1>
    2bd0:	c8 17       	cp	r28, r24
    2bd2:	d9 07       	cpc	r29, r25
    2bd4:	68 f4       	brcc	.+26     	; 0x2bf0 <vTaskDelay+0x5a>
    2bd6:	60 91 31 0a 	lds	r22, 0x0A31	; 0x800a31 <pxCurrentTCB>
    2bda:	70 91 32 0a 	lds	r23, 0x0A32	; 0x800a32 <pxCurrentTCB+0x1>
    2bde:	80 91 f7 09 	lds	r24, 0x09F7	; 0x8009f7 <pxOverflowDelayedTaskList>
    2be2:	90 91 f8 09 	lds	r25, 0x09F8	; 0x8009f8 <pxOverflowDelayedTaskList+0x1>
    2be6:	6e 5f       	subi	r22, 0xFE	; 254
    2be8:	7f 4f       	sbci	r23, 0xFF	; 255
    2bea:	0e 94 79 0c 	call	0x18f2	; 0x18f2 <vListInsert>
    2bee:	0c c0       	rjmp	.+24     	; 0x2c08 <vTaskDelay+0x72>
    2bf0:	60 91 31 0a 	lds	r22, 0x0A31	; 0x800a31 <pxCurrentTCB>
    2bf4:	70 91 32 0a 	lds	r23, 0x0A32	; 0x800a32 <pxCurrentTCB+0x1>
    2bf8:	80 91 f9 09 	lds	r24, 0x09F9	; 0x8009f9 <pxDelayedTaskList>
    2bfc:	90 91 fa 09 	lds	r25, 0x09FA	; 0x8009fa <pxDelayedTaskList+0x1>
    2c00:	6e 5f       	subi	r22, 0xFE	; 254
    2c02:	7f 4f       	sbci	r23, 0xFF	; 255
    2c04:	0e 94 79 0c 	call	0x18f2	; 0x18f2 <vListInsert>
    2c08:	41 df       	rcall	.-382    	; 0x2a8c <xTaskResumeAll>
    2c0a:	81 11       	cpse	r24, r1
    2c0c:	01 c0       	rjmp	.+2      	; 0x2c10 <vTaskDelay+0x7a>
    2c0e:	40 d8       	rcall	.-3968   	; 0x1c90 <vPortYield>
    2c10:	df 91       	pop	r29
    2c12:	cf 91       	pop	r28
    2c14:	08 95       	ret

00002c16 <vTaskSwitchContext>:

void vTaskSwitchContext( void )
{
	traceTASK_SWITCHED_OUT();

	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    2c16:	80 91 de 09 	lds	r24, 0x09DE	; 0x8009de <uxSchedulerSuspended>
    2c1a:	88 23       	and	r24, r24
    2c1c:	21 f0       	breq	.+8      	; 0x2c26 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    2c1e:	81 e0       	ldi	r24, 0x01	; 1
    2c20:	80 93 dc 09 	sts	0x09DC, r24	; 0x8009dc <xMissedYield>
		return;
    2c24:	08 95       	ret
	}

	taskFIRST_CHECK_FOR_STACK_OVERFLOW();
    2c26:	a0 91 31 0a 	lds	r26, 0x0A31	; 0x800a31 <pxCurrentTCB>
    2c2a:	b0 91 32 0a 	lds	r27, 0x0A32	; 0x800a32 <pxCurrentTCB+0x1>
    2c2e:	e0 91 31 0a 	lds	r30, 0x0A31	; 0x800a31 <pxCurrentTCB>
    2c32:	f0 91 32 0a 	lds	r31, 0x0A32	; 0x800a32 <pxCurrentTCB+0x1>
    2c36:	2d 91       	ld	r18, X+
    2c38:	3c 91       	ld	r19, X
    2c3a:	87 89       	ldd	r24, Z+23	; 0x17
    2c3c:	90 8d       	ldd	r25, Z+24	; 0x18
    2c3e:	82 17       	cp	r24, r18
    2c40:	93 07       	cpc	r25, r19
    2c42:	60 f0       	brcs	.+24     	; 0x2c5c <vTaskSwitchContext+0x46>
    2c44:	60 91 31 0a 	lds	r22, 0x0A31	; 0x800a31 <pxCurrentTCB>
    2c48:	70 91 32 0a 	lds	r23, 0x0A32	; 0x800a32 <pxCurrentTCB+0x1>
    2c4c:	80 91 31 0a 	lds	r24, 0x0A31	; 0x800a31 <pxCurrentTCB>
    2c50:	90 91 32 0a 	lds	r25, 0x0A32	; 0x800a32 <pxCurrentTCB+0x1>
    2c54:	67 5e       	subi	r22, 0xE7	; 231
    2c56:	7f 4f       	sbci	r23, 0xFF	; 255
    2c58:	0e 94 6c 01 	call	0x2d8	; 0x2d8 <vApplicationStackOverflowHook>
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();
    2c5c:	e0 91 31 0a 	lds	r30, 0x0A31	; 0x800a31 <pxCurrentTCB>
    2c60:	f0 91 32 0a 	lds	r31, 0x0A32	; 0x800a32 <pxCurrentTCB+0x1>
    2c64:	44 e1       	ldi	r20, 0x14	; 20
    2c66:	50 e0       	ldi	r21, 0x00	; 0
    2c68:	69 ee       	ldi	r22, 0xE9	; 233
    2c6a:	71 e0       	ldi	r23, 0x01	; 1
    2c6c:	87 89       	ldd	r24, Z+23	; 0x17
    2c6e:	90 8d       	ldd	r25, Z+24	; 0x18
    2c70:	9b d3       	rcall	.+1846   	; 0x33a8 <memcmp>
    2c72:	89 2b       	or	r24, r25
    2c74:	61 f0       	breq	.+24     	; 0x2c8e <vTaskSwitchContext+0x78>
    2c76:	60 91 31 0a 	lds	r22, 0x0A31	; 0x800a31 <pxCurrentTCB>
    2c7a:	70 91 32 0a 	lds	r23, 0x0A32	; 0x800a32 <pxCurrentTCB+0x1>
    2c7e:	80 91 31 0a 	lds	r24, 0x0A31	; 0x800a31 <pxCurrentTCB>
    2c82:	90 91 32 0a 	lds	r25, 0x0A32	; 0x800a32 <pxCurrentTCB+0x1>
    2c86:	67 5e       	subi	r22, 0xE7	; 231
    2c88:	7f 4f       	sbci	r23, 0xFF	; 255
    2c8a:	0e 94 6c 01 	call	0x2d8	; 0x2d8 <vApplicationStackOverflowHook>

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2c8e:	80 91 e0 09 	lds	r24, 0x09E0	; 0x8009e0 <uxTopReadyPriority>
    2c92:	90 e0       	ldi	r25, 0x00	; 0
    2c94:	fc 01       	movw	r30, r24
    2c96:	ee 0f       	add	r30, r30
    2c98:	ff 1f       	adc	r31, r31
    2c9a:	ee 0f       	add	r30, r30
    2c9c:	ff 1f       	adc	r31, r31
    2c9e:	ee 0f       	add	r30, r30
    2ca0:	ff 1f       	adc	r31, r31
    2ca2:	8e 0f       	add	r24, r30
    2ca4:	9f 1f       	adc	r25, r31
    2ca6:	fc 01       	movw	r30, r24
    2ca8:	e3 5f       	subi	r30, 0xF3	; 243
    2caa:	f5 4f       	sbci	r31, 0xF5	; 245
    2cac:	80 81       	ld	r24, Z
    2cae:	81 11       	cpse	r24, r1
    2cb0:	17 c0       	rjmp	.+46     	; 0x2ce0 <vTaskSwitchContext+0xca>
	{
		--uxTopReadyPriority;
    2cb2:	80 91 e0 09 	lds	r24, 0x09E0	; 0x8009e0 <uxTopReadyPriority>
    2cb6:	81 50       	subi	r24, 0x01	; 1
    2cb8:	80 93 e0 09 	sts	0x09E0, r24	; 0x8009e0 <uxTopReadyPriority>

	taskFIRST_CHECK_FOR_STACK_OVERFLOW();
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2cbc:	80 91 e0 09 	lds	r24, 0x09E0	; 0x8009e0 <uxTopReadyPriority>
    2cc0:	90 e0       	ldi	r25, 0x00	; 0
    2cc2:	fc 01       	movw	r30, r24
    2cc4:	ee 0f       	add	r30, r30
    2cc6:	ff 1f       	adc	r31, r31
    2cc8:	ee 0f       	add	r30, r30
    2cca:	ff 1f       	adc	r31, r31
    2ccc:	ee 0f       	add	r30, r30
    2cce:	ff 1f       	adc	r31, r31
    2cd0:	8e 0f       	add	r24, r30
    2cd2:	9f 1f       	adc	r25, r31
    2cd4:	fc 01       	movw	r30, r24
    2cd6:	e3 5f       	subi	r30, 0xF3	; 243
    2cd8:	f5 4f       	sbci	r31, 0xF5	; 245
    2cda:	80 81       	ld	r24, Z
    2cdc:	88 23       	and	r24, r24
    2cde:	49 f3       	breq	.-46     	; 0x2cb2 <vTaskSwitchContext+0x9c>
		--uxTopReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    2ce0:	80 91 e0 09 	lds	r24, 0x09E0	; 0x8009e0 <uxTopReadyPriority>
    2ce4:	90 e0       	ldi	r25, 0x00	; 0
    2ce6:	9c 01       	movw	r18, r24
    2ce8:	22 0f       	add	r18, r18
    2cea:	33 1f       	adc	r19, r19
    2cec:	22 0f       	add	r18, r18
    2cee:	33 1f       	adc	r19, r19
    2cf0:	22 0f       	add	r18, r18
    2cf2:	33 1f       	adc	r19, r19
    2cf4:	28 0f       	add	r18, r24
    2cf6:	39 1f       	adc	r19, r25
    2cf8:	d9 01       	movw	r26, r18
    2cfa:	a3 5f       	subi	r26, 0xF3	; 243
    2cfc:	b5 4f       	sbci	r27, 0xF5	; 245
    2cfe:	11 96       	adiw	r26, 0x01	; 1
    2d00:	ed 91       	ld	r30, X+
    2d02:	fc 91       	ld	r31, X
    2d04:	12 97       	sbiw	r26, 0x02	; 2
    2d06:	02 80       	ldd	r0, Z+2	; 0x02
    2d08:	f3 81       	ldd	r31, Z+3	; 0x03
    2d0a:	e0 2d       	mov	r30, r0
    2d0c:	12 96       	adiw	r26, 0x02	; 2
    2d0e:	fc 93       	st	X, r31
    2d10:	ee 93       	st	-X, r30
    2d12:	11 97       	sbiw	r26, 0x01	; 1
    2d14:	20 5f       	subi	r18, 0xF0	; 240
    2d16:	35 4f       	sbci	r19, 0xF5	; 245
    2d18:	e2 17       	cp	r30, r18
    2d1a:	f3 07       	cpc	r31, r19
    2d1c:	29 f4       	brne	.+10     	; 0x2d28 <vTaskSwitchContext+0x112>
    2d1e:	22 81       	ldd	r18, Z+2	; 0x02
    2d20:	33 81       	ldd	r19, Z+3	; 0x03
    2d22:	fd 01       	movw	r30, r26
    2d24:	32 83       	std	Z+2, r19	; 0x02
    2d26:	21 83       	std	Z+1, r18	; 0x01
    2d28:	fc 01       	movw	r30, r24
    2d2a:	ee 0f       	add	r30, r30
    2d2c:	ff 1f       	adc	r31, r31
    2d2e:	ee 0f       	add	r30, r30
    2d30:	ff 1f       	adc	r31, r31
    2d32:	ee 0f       	add	r30, r30
    2d34:	ff 1f       	adc	r31, r31
    2d36:	8e 0f       	add	r24, r30
    2d38:	9f 1f       	adc	r25, r31
    2d3a:	fc 01       	movw	r30, r24
    2d3c:	e3 5f       	subi	r30, 0xF3	; 243
    2d3e:	f5 4f       	sbci	r31, 0xF5	; 245
    2d40:	01 80       	ldd	r0, Z+1	; 0x01
    2d42:	f2 81       	ldd	r31, Z+2	; 0x02
    2d44:	e0 2d       	mov	r30, r0
    2d46:	86 81       	ldd	r24, Z+6	; 0x06
    2d48:	97 81       	ldd	r25, Z+7	; 0x07
    2d4a:	90 93 32 0a 	sts	0x0A32, r25	; 0x800a32 <pxCurrentTCB+0x1>
    2d4e:	80 93 31 0a 	sts	0x0A31, r24	; 0x800a31 <pxCurrentTCB>
    2d52:	08 95       	ret

00002d54 <vTaskPlaceOnEventList>:
	vWriteTraceToBuffer();
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    2d54:	cf 93       	push	r28
    2d56:	df 93       	push	r29
    2d58:	eb 01       	movw	r28, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    2d5a:	60 91 31 0a 	lds	r22, 0x0A31	; 0x800a31 <pxCurrentTCB>
    2d5e:	70 91 32 0a 	lds	r23, 0x0A32	; 0x800a32 <pxCurrentTCB+0x1>
    2d62:	64 5f       	subi	r22, 0xF4	; 244
    2d64:	7f 4f       	sbci	r23, 0xFF	; 255
    2d66:	0e 94 79 0c 	call	0x18f2	; 0x18f2 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2d6a:	80 91 31 0a 	lds	r24, 0x0A31	; 0x800a31 <pxCurrentTCB>
    2d6e:	90 91 32 0a 	lds	r25, 0x0A32	; 0x800a32 <pxCurrentTCB+0x1>
    2d72:	02 96       	adiw	r24, 0x02	; 2
    2d74:	0e 94 b4 0c 	call	0x1968	; 0x1968 <vListRemove>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{			
		if( xTicksToWait == portMAX_DELAY )
    2d78:	cf 3f       	cpi	r28, 0xFF	; 255
    2d7a:	8f ef       	ldi	r24, 0xFF	; 255
    2d7c:	d8 07       	cpc	r29, r24
    2d7e:	59 f4       	brne	.+22     	; 0x2d96 <vTaskPlaceOnEventList+0x42>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2d80:	60 91 31 0a 	lds	r22, 0x0A31	; 0x800a31 <pxCurrentTCB>
    2d84:	70 91 32 0a 	lds	r23, 0x0A32	; 0x800a32 <pxCurrentTCB+0x1>
    2d88:	6e 5f       	subi	r22, 0xFE	; 254
    2d8a:	7f 4f       	sbci	r23, 0xFF	; 255
    2d8c:	85 ee       	ldi	r24, 0xE5	; 229
    2d8e:	99 e0       	ldi	r25, 0x09	; 9
    2d90:	0e 94 52 0c 	call	0x18a4	; 0x18a4 <vListInsertEnd>
    2d94:	2c c0       	rjmp	.+88     	; 0x2dee <vTaskPlaceOnEventList+0x9a>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    2d96:	60 91 e2 09 	lds	r22, 0x09E2	; 0x8009e2 <xTickCount>
    2d9a:	70 91 e3 09 	lds	r23, 0x09E3	; 0x8009e3 <xTickCount+0x1>
    2d9e:	6c 0f       	add	r22, r28
    2da0:	7d 1f       	adc	r23, r29
		
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    2da2:	e0 91 31 0a 	lds	r30, 0x0A31	; 0x800a31 <pxCurrentTCB>
    2da6:	f0 91 32 0a 	lds	r31, 0x0A32	; 0x800a32 <pxCurrentTCB+0x1>
    2daa:	73 83       	std	Z+3, r23	; 0x03
    2dac:	62 83       	std	Z+2, r22	; 0x02
		
			if( xTimeToWake < xTickCount )
    2dae:	80 91 e2 09 	lds	r24, 0x09E2	; 0x8009e2 <xTickCount>
    2db2:	90 91 e3 09 	lds	r25, 0x09E3	; 0x8009e3 <xTickCount+0x1>
    2db6:	68 17       	cp	r22, r24
    2db8:	79 07       	cpc	r23, r25
    2dba:	68 f4       	brcc	.+26     	; 0x2dd6 <vTaskPlaceOnEventList+0x82>
			{
				/* Wake time has overflowed.  Place this item in the overflow list. */
				vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2dbc:	60 91 31 0a 	lds	r22, 0x0A31	; 0x800a31 <pxCurrentTCB>
    2dc0:	70 91 32 0a 	lds	r23, 0x0A32	; 0x800a32 <pxCurrentTCB+0x1>
    2dc4:	80 91 f7 09 	lds	r24, 0x09F7	; 0x8009f7 <pxOverflowDelayedTaskList>
    2dc8:	90 91 f8 09 	lds	r25, 0x09F8	; 0x8009f8 <pxOverflowDelayedTaskList+0x1>
    2dcc:	6e 5f       	subi	r22, 0xFE	; 254
    2dce:	7f 4f       	sbci	r23, 0xFF	; 255
    2dd0:	0e 94 79 0c 	call	0x18f2	; 0x18f2 <vListInsert>
    2dd4:	0c c0       	rjmp	.+24     	; 0x2dee <vTaskPlaceOnEventList+0x9a>
			}
			else
			{
				/* The wake time has not overflowed, so we can use the current block list. */
				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2dd6:	60 91 31 0a 	lds	r22, 0x0A31	; 0x800a31 <pxCurrentTCB>
    2dda:	70 91 32 0a 	lds	r23, 0x0A32	; 0x800a32 <pxCurrentTCB+0x1>
    2dde:	80 91 f9 09 	lds	r24, 0x09F9	; 0x8009f9 <pxDelayedTaskList>
    2de2:	90 91 fa 09 	lds	r25, 0x09FA	; 0x8009fa <pxDelayedTaskList+0x1>
    2de6:	6e 5f       	subi	r22, 0xFE	; 254
    2de8:	7f 4f       	sbci	r23, 0xFF	; 255
    2dea:	0e 94 79 0c 	call	0x18f2	; 0x18f2 <vListInsert>
				/* The wake time has not overflowed, so we can use the current block list. */
				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
			}
	}
	#endif
}
    2dee:	df 91       	pop	r29
    2df0:	cf 91       	pop	r28
    2df2:	08 95       	ret

00002df4 <xTaskRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    2df4:	0f 93       	push	r16
    2df6:	1f 93       	push	r17
    2df8:	cf 93       	push	r28
    2dfa:	df 93       	push	r29
	it to the ready list.
	
	If an event is for a queue that is locked then this function will never
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2dfc:	dc 01       	movw	r26, r24
    2dfe:	2c 91       	ld	r18, X
    2e00:	22 23       	and	r18, r18
    2e02:	39 f0       	breq	.+14     	; 0x2e12 <xTaskRemoveFromEventList+0x1e>
    2e04:	15 96       	adiw	r26, 0x05	; 5
    2e06:	ed 91       	ld	r30, X+
    2e08:	fc 91       	ld	r31, X
    2e0a:	16 97       	sbiw	r26, 0x06	; 6
    2e0c:	c6 81       	ldd	r28, Z+6	; 0x06
    2e0e:	d7 81       	ldd	r29, Z+7	; 0x07
    2e10:	02 c0       	rjmp	.+4      	; 0x2e16 <xTaskRemoveFromEventList+0x22>
    2e12:	c0 e0       	ldi	r28, 0x00	; 0
    2e14:	d0 e0       	ldi	r29, 0x00	; 0
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    2e16:	8e 01       	movw	r16, r28
    2e18:	04 5f       	subi	r16, 0xF4	; 244
    2e1a:	1f 4f       	sbci	r17, 0xFF	; 255
    2e1c:	c8 01       	movw	r24, r16
    2e1e:	0e 94 b4 0c 	call	0x1968	; 0x1968 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2e22:	80 91 de 09 	lds	r24, 0x09DE	; 0x8009de <uxSchedulerSuspended>
    2e26:	81 11       	cpse	r24, r1
    2e28:	1c c0       	rjmp	.+56     	; 0x2e62 <xTaskRemoveFromEventList+0x6e>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    2e2a:	0a 50       	subi	r16, 0x0A	; 10
    2e2c:	11 09       	sbc	r17, r1
    2e2e:	c8 01       	movw	r24, r16
    2e30:	0e 94 b4 0c 	call	0x1968	; 0x1968 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    2e34:	8e 89       	ldd	r24, Y+22	; 0x16
    2e36:	90 91 e0 09 	lds	r25, 0x09E0	; 0x8009e0 <uxTopReadyPriority>
    2e3a:	98 17       	cp	r25, r24
    2e3c:	10 f4       	brcc	.+4      	; 0x2e42 <xTaskRemoveFromEventList+0x4e>
    2e3e:	80 93 e0 09 	sts	0x09E0, r24	; 0x8009e0 <uxTopReadyPriority>
    2e42:	90 e0       	ldi	r25, 0x00	; 0
    2e44:	9c 01       	movw	r18, r24
    2e46:	22 0f       	add	r18, r18
    2e48:	33 1f       	adc	r19, r19
    2e4a:	22 0f       	add	r18, r18
    2e4c:	33 1f       	adc	r19, r19
    2e4e:	22 0f       	add	r18, r18
    2e50:	33 1f       	adc	r19, r19
    2e52:	82 0f       	add	r24, r18
    2e54:	93 1f       	adc	r25, r19
    2e56:	b8 01       	movw	r22, r16
    2e58:	83 5f       	subi	r24, 0xF3	; 243
    2e5a:	95 4f       	sbci	r25, 0xF5	; 245
    2e5c:	0e 94 52 0c 	call	0x18a4	; 0x18a4 <vListInsertEnd>
    2e60:	05 c0       	rjmp	.+10     	; 0x2e6c <xTaskRemoveFromEventList+0x78>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2e62:	b8 01       	movw	r22, r16
    2e64:	8e ee       	ldi	r24, 0xEE	; 238
    2e66:	99 e0       	ldi	r25, 0x09	; 9
    2e68:	0e 94 52 0c 	call	0x18a4	; 0x18a4 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2e6c:	e0 91 31 0a 	lds	r30, 0x0A31	; 0x800a31 <pxCurrentTCB>
    2e70:	f0 91 32 0a 	lds	r31, 0x0A32	; 0x800a32 <pxCurrentTCB+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    2e74:	81 e0       	ldi	r24, 0x01	; 1
    2e76:	2e 89       	ldd	r18, Y+22	; 0x16
    2e78:	96 89       	ldd	r25, Z+22	; 0x16
    2e7a:	29 17       	cp	r18, r25
    2e7c:	08 f4       	brcc	.+2      	; 0x2e80 <xTaskRemoveFromEventList+0x8c>
    2e7e:	80 e0       	ldi	r24, 0x00	; 0
}
    2e80:	df 91       	pop	r29
    2e82:	cf 91       	pop	r28
    2e84:	1f 91       	pop	r17
    2e86:	0f 91       	pop	r16
    2e88:	08 95       	ret

00002e8a <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    pxTimeOut->xOverflowCount = xNumOfOverflows;
    2e8a:	20 91 db 09 	lds	r18, 0x09DB	; 0x8009db <xNumOfOverflows>
    2e8e:	fc 01       	movw	r30, r24
    2e90:	20 83       	st	Z, r18
    pxTimeOut->xTimeOnEntering = xTickCount;
    2e92:	20 91 e2 09 	lds	r18, 0x09E2	; 0x8009e2 <xTickCount>
    2e96:	30 91 e3 09 	lds	r19, 0x09E3	; 0x8009e3 <xTickCount+0x1>
    2e9a:	32 83       	std	Z+2, r19	; 0x02
    2e9c:	21 83       	std	Z+1, r18	; 0x01
    2e9e:	08 95       	ret

00002ea0 <xTaskCheckForTimeOut>:

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
portBASE_TYPE xReturn;

	portENTER_CRITICAL();
    2ea0:	0f b6       	in	r0, 0x3f	; 63
    2ea2:	f8 94       	cli
    2ea4:	0f 92       	push	r0
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
    2ea6:	db 01       	movw	r26, r22
    2ea8:	2d 91       	ld	r18, X+
    2eaa:	3c 91       	ld	r19, X
    2eac:	2f 3f       	cpi	r18, 0xFF	; 255
    2eae:	bf ef       	ldi	r27, 0xFF	; 255
    2eb0:	3b 07       	cpc	r19, r27
    2eb2:	61 f1       	breq	.+88     	; 0x2f0c <xTaskCheckForTimeOut+0x6c>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xTickCount >= pxTimeOut->xTimeOnEntering ) )
    2eb4:	40 91 db 09 	lds	r20, 0x09DB	; 0x8009db <xNumOfOverflows>
    2eb8:	fc 01       	movw	r30, r24
    2eba:	50 81       	ld	r21, Z
    2ebc:	54 17       	cp	r21, r20
    2ebe:	51 f0       	breq	.+20     	; 0x2ed4 <xTaskCheckForTimeOut+0x34>
    2ec0:	40 91 e2 09 	lds	r20, 0x09E2	; 0x8009e2 <xTickCount>
    2ec4:	50 91 e3 09 	lds	r21, 0x09E3	; 0x8009e3 <xTickCount+0x1>
    2ec8:	01 80       	ldd	r0, Z+1	; 0x01
    2eca:	f2 81       	ldd	r31, Z+2	; 0x02
    2ecc:	e0 2d       	mov	r30, r0
    2ece:	4e 17       	cp	r20, r30
    2ed0:	5f 07       	cpc	r21, r31
    2ed2:	f0 f4       	brcc	.+60     	; 0x2f10 <xTaskCheckForTimeOut+0x70>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( xTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
    2ed4:	40 91 e2 09 	lds	r20, 0x09E2	; 0x8009e2 <xTickCount>
    2ed8:	50 91 e3 09 	lds	r21, 0x09E3	; 0x8009e3 <xTickCount+0x1>
    2edc:	dc 01       	movw	r26, r24
    2ede:	11 96       	adiw	r26, 0x01	; 1
    2ee0:	ed 91       	ld	r30, X+
    2ee2:	fc 91       	ld	r31, X
    2ee4:	12 97       	sbiw	r26, 0x02	; 2
    2ee6:	4e 1b       	sub	r20, r30
    2ee8:	5f 0b       	sbc	r21, r31
    2eea:	42 17       	cp	r20, r18
    2eec:	53 07       	cpc	r21, r19
    2eee:	90 f4       	brcc	.+36     	; 0x2f14 <xTaskCheckForTimeOut+0x74>
    2ef0:	db 01       	movw	r26, r22
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xTickCount - pxTimeOut->xTimeOnEntering );
    2ef2:	40 91 e2 09 	lds	r20, 0x09E2	; 0x8009e2 <xTickCount>
    2ef6:	50 91 e3 09 	lds	r21, 0x09E3	; 0x8009e3 <xTickCount+0x1>
    2efa:	4e 1b       	sub	r20, r30
    2efc:	5f 0b       	sbc	r21, r31
    2efe:	24 1b       	sub	r18, r20
    2f00:	35 0b       	sbc	r19, r21
    2f02:	2d 93       	st	X+, r18
    2f04:	3c 93       	st	X, r19
			vTaskSetTimeOutState( pxTimeOut );
    2f06:	c1 df       	rcall	.-126    	; 0x2e8a <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    2f08:	80 e0       	ldi	r24, 0x00	; 0
    2f0a:	05 c0       	rjmp	.+10     	; 0x2f16 <xTaskCheckForTimeOut+0x76>
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
			{
				xReturn = pdFALSE;
    2f0c:	80 e0       	ldi	r24, 0x00	; 0
    2f0e:	03 c0       	rjmp	.+6      	; 0x2f16 <xTaskCheckForTimeOut+0x76>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    2f10:	81 e0       	ldi	r24, 0x01	; 1
    2f12:	01 c0       	rjmp	.+2      	; 0x2f16 <xTaskCheckForTimeOut+0x76>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    2f14:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portEXIT_CRITICAL();
    2f16:	0f 90       	pop	r0
    2f18:	0f be       	out	0x3f, r0	; 63

    return xReturn;
}
    2f1a:	08 95       	ret

00002f1c <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    2f1c:	81 e0       	ldi	r24, 0x01	; 1
    2f1e:	80 93 dc 09 	sts	0x09DC, r24	; 0x8009dc <xMissedYield>
    2f22:	08 95       	ret

00002f24 <__subsf3>:
    2f24:	50 58       	subi	r21, 0x80	; 128

00002f26 <__addsf3>:
    2f26:	bb 27       	eor	r27, r27
    2f28:	aa 27       	eor	r26, r26
    2f2a:	0e d0       	rcall	.+28     	; 0x2f48 <__addsf3x>
    2f2c:	75 c1       	rjmp	.+746    	; 0x3218 <__fp_round>
    2f2e:	66 d1       	rcall	.+716    	; 0x31fc <__fp_pscA>
    2f30:	30 f0       	brcs	.+12     	; 0x2f3e <__addsf3+0x18>
    2f32:	6b d1       	rcall	.+726    	; 0x320a <__fp_pscB>
    2f34:	20 f0       	brcs	.+8      	; 0x2f3e <__addsf3+0x18>
    2f36:	31 f4       	brne	.+12     	; 0x2f44 <__addsf3+0x1e>
    2f38:	9f 3f       	cpi	r25, 0xFF	; 255
    2f3a:	11 f4       	brne	.+4      	; 0x2f40 <__addsf3+0x1a>
    2f3c:	1e f4       	brtc	.+6      	; 0x2f44 <__addsf3+0x1e>
    2f3e:	5b c1       	rjmp	.+694    	; 0x31f6 <__fp_nan>
    2f40:	0e f4       	brtc	.+2      	; 0x2f44 <__addsf3+0x1e>
    2f42:	e0 95       	com	r30
    2f44:	e7 fb       	bst	r30, 7
    2f46:	51 c1       	rjmp	.+674    	; 0x31ea <__fp_inf>

00002f48 <__addsf3x>:
    2f48:	e9 2f       	mov	r30, r25
    2f4a:	77 d1       	rcall	.+750    	; 0x323a <__fp_split3>
    2f4c:	80 f3       	brcs	.-32     	; 0x2f2e <__addsf3+0x8>
    2f4e:	ba 17       	cp	r27, r26
    2f50:	62 07       	cpc	r22, r18
    2f52:	73 07       	cpc	r23, r19
    2f54:	84 07       	cpc	r24, r20
    2f56:	95 07       	cpc	r25, r21
    2f58:	18 f0       	brcs	.+6      	; 0x2f60 <__addsf3x+0x18>
    2f5a:	71 f4       	brne	.+28     	; 0x2f78 <__addsf3x+0x30>
    2f5c:	9e f5       	brtc	.+102    	; 0x2fc4 <__addsf3x+0x7c>
    2f5e:	8f c1       	rjmp	.+798    	; 0x327e <__fp_zero>
    2f60:	0e f4       	brtc	.+2      	; 0x2f64 <__addsf3x+0x1c>
    2f62:	e0 95       	com	r30
    2f64:	0b 2e       	mov	r0, r27
    2f66:	ba 2f       	mov	r27, r26
    2f68:	a0 2d       	mov	r26, r0
    2f6a:	0b 01       	movw	r0, r22
    2f6c:	b9 01       	movw	r22, r18
    2f6e:	90 01       	movw	r18, r0
    2f70:	0c 01       	movw	r0, r24
    2f72:	ca 01       	movw	r24, r20
    2f74:	a0 01       	movw	r20, r0
    2f76:	11 24       	eor	r1, r1
    2f78:	ff 27       	eor	r31, r31
    2f7a:	59 1b       	sub	r21, r25
    2f7c:	99 f0       	breq	.+38     	; 0x2fa4 <__addsf3x+0x5c>
    2f7e:	59 3f       	cpi	r21, 0xF9	; 249
    2f80:	50 f4       	brcc	.+20     	; 0x2f96 <__addsf3x+0x4e>
    2f82:	50 3e       	cpi	r21, 0xE0	; 224
    2f84:	68 f1       	brcs	.+90     	; 0x2fe0 <__addsf3x+0x98>
    2f86:	1a 16       	cp	r1, r26
    2f88:	f0 40       	sbci	r31, 0x00	; 0
    2f8a:	a2 2f       	mov	r26, r18
    2f8c:	23 2f       	mov	r18, r19
    2f8e:	34 2f       	mov	r19, r20
    2f90:	44 27       	eor	r20, r20
    2f92:	58 5f       	subi	r21, 0xF8	; 248
    2f94:	f3 cf       	rjmp	.-26     	; 0x2f7c <__addsf3x+0x34>
    2f96:	46 95       	lsr	r20
    2f98:	37 95       	ror	r19
    2f9a:	27 95       	ror	r18
    2f9c:	a7 95       	ror	r26
    2f9e:	f0 40       	sbci	r31, 0x00	; 0
    2fa0:	53 95       	inc	r21
    2fa2:	c9 f7       	brne	.-14     	; 0x2f96 <__addsf3x+0x4e>
    2fa4:	7e f4       	brtc	.+30     	; 0x2fc4 <__addsf3x+0x7c>
    2fa6:	1f 16       	cp	r1, r31
    2fa8:	ba 0b       	sbc	r27, r26
    2faa:	62 0b       	sbc	r22, r18
    2fac:	73 0b       	sbc	r23, r19
    2fae:	84 0b       	sbc	r24, r20
    2fb0:	ba f0       	brmi	.+46     	; 0x2fe0 <__addsf3x+0x98>
    2fb2:	91 50       	subi	r25, 0x01	; 1
    2fb4:	a1 f0       	breq	.+40     	; 0x2fde <__addsf3x+0x96>
    2fb6:	ff 0f       	add	r31, r31
    2fb8:	bb 1f       	adc	r27, r27
    2fba:	66 1f       	adc	r22, r22
    2fbc:	77 1f       	adc	r23, r23
    2fbe:	88 1f       	adc	r24, r24
    2fc0:	c2 f7       	brpl	.-16     	; 0x2fb2 <__addsf3x+0x6a>
    2fc2:	0e c0       	rjmp	.+28     	; 0x2fe0 <__addsf3x+0x98>
    2fc4:	ba 0f       	add	r27, r26
    2fc6:	62 1f       	adc	r22, r18
    2fc8:	73 1f       	adc	r23, r19
    2fca:	84 1f       	adc	r24, r20
    2fcc:	48 f4       	brcc	.+18     	; 0x2fe0 <__addsf3x+0x98>
    2fce:	87 95       	ror	r24
    2fd0:	77 95       	ror	r23
    2fd2:	67 95       	ror	r22
    2fd4:	b7 95       	ror	r27
    2fd6:	f7 95       	ror	r31
    2fd8:	9e 3f       	cpi	r25, 0xFE	; 254
    2fda:	08 f0       	brcs	.+2      	; 0x2fde <__addsf3x+0x96>
    2fdc:	b3 cf       	rjmp	.-154    	; 0x2f44 <__addsf3+0x1e>
    2fde:	93 95       	inc	r25
    2fe0:	88 0f       	add	r24, r24
    2fe2:	08 f0       	brcs	.+2      	; 0x2fe6 <__addsf3x+0x9e>
    2fe4:	99 27       	eor	r25, r25
    2fe6:	ee 0f       	add	r30, r30
    2fe8:	97 95       	ror	r25
    2fea:	87 95       	ror	r24
    2fec:	08 95       	ret

00002fee <__cmpsf2>:
    2fee:	d9 d0       	rcall	.+434    	; 0x31a2 <__fp_cmp>
    2ff0:	08 f4       	brcc	.+2      	; 0x2ff4 <__cmpsf2+0x6>
    2ff2:	81 e0       	ldi	r24, 0x01	; 1
    2ff4:	08 95       	ret

00002ff6 <__divsf3>:
    2ff6:	0c d0       	rcall	.+24     	; 0x3010 <__divsf3x>
    2ff8:	0f c1       	rjmp	.+542    	; 0x3218 <__fp_round>
    2ffa:	07 d1       	rcall	.+526    	; 0x320a <__fp_pscB>
    2ffc:	40 f0       	brcs	.+16     	; 0x300e <__divsf3+0x18>
    2ffe:	fe d0       	rcall	.+508    	; 0x31fc <__fp_pscA>
    3000:	30 f0       	brcs	.+12     	; 0x300e <__divsf3+0x18>
    3002:	21 f4       	brne	.+8      	; 0x300c <__divsf3+0x16>
    3004:	5f 3f       	cpi	r21, 0xFF	; 255
    3006:	19 f0       	breq	.+6      	; 0x300e <__divsf3+0x18>
    3008:	f0 c0       	rjmp	.+480    	; 0x31ea <__fp_inf>
    300a:	51 11       	cpse	r21, r1
    300c:	39 c1       	rjmp	.+626    	; 0x3280 <__fp_szero>
    300e:	f3 c0       	rjmp	.+486    	; 0x31f6 <__fp_nan>

00003010 <__divsf3x>:
    3010:	14 d1       	rcall	.+552    	; 0x323a <__fp_split3>
    3012:	98 f3       	brcs	.-26     	; 0x2ffa <__divsf3+0x4>

00003014 <__divsf3_pse>:
    3014:	99 23       	and	r25, r25
    3016:	c9 f3       	breq	.-14     	; 0x300a <__divsf3+0x14>
    3018:	55 23       	and	r21, r21
    301a:	b1 f3       	breq	.-20     	; 0x3008 <__divsf3+0x12>
    301c:	95 1b       	sub	r25, r21
    301e:	55 0b       	sbc	r21, r21
    3020:	bb 27       	eor	r27, r27
    3022:	aa 27       	eor	r26, r26
    3024:	62 17       	cp	r22, r18
    3026:	73 07       	cpc	r23, r19
    3028:	84 07       	cpc	r24, r20
    302a:	38 f0       	brcs	.+14     	; 0x303a <__divsf3_pse+0x26>
    302c:	9f 5f       	subi	r25, 0xFF	; 255
    302e:	5f 4f       	sbci	r21, 0xFF	; 255
    3030:	22 0f       	add	r18, r18
    3032:	33 1f       	adc	r19, r19
    3034:	44 1f       	adc	r20, r20
    3036:	aa 1f       	adc	r26, r26
    3038:	a9 f3       	breq	.-22     	; 0x3024 <__divsf3_pse+0x10>
    303a:	33 d0       	rcall	.+102    	; 0x30a2 <__divsf3_pse+0x8e>
    303c:	0e 2e       	mov	r0, r30
    303e:	3a f0       	brmi	.+14     	; 0x304e <__divsf3_pse+0x3a>
    3040:	e0 e8       	ldi	r30, 0x80	; 128
    3042:	30 d0       	rcall	.+96     	; 0x30a4 <__divsf3_pse+0x90>
    3044:	91 50       	subi	r25, 0x01	; 1
    3046:	50 40       	sbci	r21, 0x00	; 0
    3048:	e6 95       	lsr	r30
    304a:	00 1c       	adc	r0, r0
    304c:	ca f7       	brpl	.-14     	; 0x3040 <__divsf3_pse+0x2c>
    304e:	29 d0       	rcall	.+82     	; 0x30a2 <__divsf3_pse+0x8e>
    3050:	fe 2f       	mov	r31, r30
    3052:	27 d0       	rcall	.+78     	; 0x30a2 <__divsf3_pse+0x8e>
    3054:	66 0f       	add	r22, r22
    3056:	77 1f       	adc	r23, r23
    3058:	88 1f       	adc	r24, r24
    305a:	bb 1f       	adc	r27, r27
    305c:	26 17       	cp	r18, r22
    305e:	37 07       	cpc	r19, r23
    3060:	48 07       	cpc	r20, r24
    3062:	ab 07       	cpc	r26, r27
    3064:	b0 e8       	ldi	r27, 0x80	; 128
    3066:	09 f0       	breq	.+2      	; 0x306a <__divsf3_pse+0x56>
    3068:	bb 0b       	sbc	r27, r27
    306a:	80 2d       	mov	r24, r0
    306c:	bf 01       	movw	r22, r30
    306e:	ff 27       	eor	r31, r31
    3070:	93 58       	subi	r25, 0x83	; 131
    3072:	5f 4f       	sbci	r21, 0xFF	; 255
    3074:	2a f0       	brmi	.+10     	; 0x3080 <__divsf3_pse+0x6c>
    3076:	9e 3f       	cpi	r25, 0xFE	; 254
    3078:	51 05       	cpc	r21, r1
    307a:	68 f0       	brcs	.+26     	; 0x3096 <__divsf3_pse+0x82>
    307c:	b6 c0       	rjmp	.+364    	; 0x31ea <__fp_inf>
    307e:	00 c1       	rjmp	.+512    	; 0x3280 <__fp_szero>
    3080:	5f 3f       	cpi	r21, 0xFF	; 255
    3082:	ec f3       	brlt	.-6      	; 0x307e <__divsf3_pse+0x6a>
    3084:	98 3e       	cpi	r25, 0xE8	; 232
    3086:	dc f3       	brlt	.-10     	; 0x307e <__divsf3_pse+0x6a>
    3088:	86 95       	lsr	r24
    308a:	77 95       	ror	r23
    308c:	67 95       	ror	r22
    308e:	b7 95       	ror	r27
    3090:	f7 95       	ror	r31
    3092:	9f 5f       	subi	r25, 0xFF	; 255
    3094:	c9 f7       	brne	.-14     	; 0x3088 <__divsf3_pse+0x74>
    3096:	88 0f       	add	r24, r24
    3098:	91 1d       	adc	r25, r1
    309a:	96 95       	lsr	r25
    309c:	87 95       	ror	r24
    309e:	97 f9       	bld	r25, 7
    30a0:	08 95       	ret
    30a2:	e1 e0       	ldi	r30, 0x01	; 1
    30a4:	66 0f       	add	r22, r22
    30a6:	77 1f       	adc	r23, r23
    30a8:	88 1f       	adc	r24, r24
    30aa:	bb 1f       	adc	r27, r27
    30ac:	62 17       	cp	r22, r18
    30ae:	73 07       	cpc	r23, r19
    30b0:	84 07       	cpc	r24, r20
    30b2:	ba 07       	cpc	r27, r26
    30b4:	20 f0       	brcs	.+8      	; 0x30be <__divsf3_pse+0xaa>
    30b6:	62 1b       	sub	r22, r18
    30b8:	73 0b       	sbc	r23, r19
    30ba:	84 0b       	sbc	r24, r20
    30bc:	ba 0b       	sbc	r27, r26
    30be:	ee 1f       	adc	r30, r30
    30c0:	88 f7       	brcc	.-30     	; 0x30a4 <__divsf3_pse+0x90>
    30c2:	e0 95       	com	r30
    30c4:	08 95       	ret

000030c6 <__fixsfsi>:
    30c6:	04 d0       	rcall	.+8      	; 0x30d0 <__fixunssfsi>
    30c8:	68 94       	set
    30ca:	b1 11       	cpse	r27, r1
    30cc:	d9 c0       	rjmp	.+434    	; 0x3280 <__fp_szero>
    30ce:	08 95       	ret

000030d0 <__fixunssfsi>:
    30d0:	bc d0       	rcall	.+376    	; 0x324a <__fp_splitA>
    30d2:	88 f0       	brcs	.+34     	; 0x30f6 <__fixunssfsi+0x26>
    30d4:	9f 57       	subi	r25, 0x7F	; 127
    30d6:	90 f0       	brcs	.+36     	; 0x30fc <__fixunssfsi+0x2c>
    30d8:	b9 2f       	mov	r27, r25
    30da:	99 27       	eor	r25, r25
    30dc:	b7 51       	subi	r27, 0x17	; 23
    30de:	a0 f0       	brcs	.+40     	; 0x3108 <__fixunssfsi+0x38>
    30e0:	d1 f0       	breq	.+52     	; 0x3116 <__fixunssfsi+0x46>
    30e2:	66 0f       	add	r22, r22
    30e4:	77 1f       	adc	r23, r23
    30e6:	88 1f       	adc	r24, r24
    30e8:	99 1f       	adc	r25, r25
    30ea:	1a f0       	brmi	.+6      	; 0x30f2 <__fixunssfsi+0x22>
    30ec:	ba 95       	dec	r27
    30ee:	c9 f7       	brne	.-14     	; 0x30e2 <__fixunssfsi+0x12>
    30f0:	12 c0       	rjmp	.+36     	; 0x3116 <__fixunssfsi+0x46>
    30f2:	b1 30       	cpi	r27, 0x01	; 1
    30f4:	81 f0       	breq	.+32     	; 0x3116 <__fixunssfsi+0x46>
    30f6:	c3 d0       	rcall	.+390    	; 0x327e <__fp_zero>
    30f8:	b1 e0       	ldi	r27, 0x01	; 1
    30fa:	08 95       	ret
    30fc:	c0 c0       	rjmp	.+384    	; 0x327e <__fp_zero>
    30fe:	67 2f       	mov	r22, r23
    3100:	78 2f       	mov	r23, r24
    3102:	88 27       	eor	r24, r24
    3104:	b8 5f       	subi	r27, 0xF8	; 248
    3106:	39 f0       	breq	.+14     	; 0x3116 <__fixunssfsi+0x46>
    3108:	b9 3f       	cpi	r27, 0xF9	; 249
    310a:	cc f3       	brlt	.-14     	; 0x30fe <__fixunssfsi+0x2e>
    310c:	86 95       	lsr	r24
    310e:	77 95       	ror	r23
    3110:	67 95       	ror	r22
    3112:	b3 95       	inc	r27
    3114:	d9 f7       	brne	.-10     	; 0x310c <__fixunssfsi+0x3c>
    3116:	3e f4       	brtc	.+14     	; 0x3126 <__fixunssfsi+0x56>
    3118:	90 95       	com	r25
    311a:	80 95       	com	r24
    311c:	70 95       	com	r23
    311e:	61 95       	neg	r22
    3120:	7f 4f       	sbci	r23, 0xFF	; 255
    3122:	8f 4f       	sbci	r24, 0xFF	; 255
    3124:	9f 4f       	sbci	r25, 0xFF	; 255
    3126:	08 95       	ret

00003128 <__floatunsisf>:
    3128:	e8 94       	clt
    312a:	09 c0       	rjmp	.+18     	; 0x313e <__floatsisf+0x12>

0000312c <__floatsisf>:
    312c:	97 fb       	bst	r25, 7
    312e:	3e f4       	brtc	.+14     	; 0x313e <__floatsisf+0x12>
    3130:	90 95       	com	r25
    3132:	80 95       	com	r24
    3134:	70 95       	com	r23
    3136:	61 95       	neg	r22
    3138:	7f 4f       	sbci	r23, 0xFF	; 255
    313a:	8f 4f       	sbci	r24, 0xFF	; 255
    313c:	9f 4f       	sbci	r25, 0xFF	; 255
    313e:	99 23       	and	r25, r25
    3140:	a9 f0       	breq	.+42     	; 0x316c <__floatsisf+0x40>
    3142:	f9 2f       	mov	r31, r25
    3144:	96 e9       	ldi	r25, 0x96	; 150
    3146:	bb 27       	eor	r27, r27
    3148:	93 95       	inc	r25
    314a:	f6 95       	lsr	r31
    314c:	87 95       	ror	r24
    314e:	77 95       	ror	r23
    3150:	67 95       	ror	r22
    3152:	b7 95       	ror	r27
    3154:	f1 11       	cpse	r31, r1
    3156:	f8 cf       	rjmp	.-16     	; 0x3148 <__floatsisf+0x1c>
    3158:	fa f4       	brpl	.+62     	; 0x3198 <__floatsisf+0x6c>
    315a:	bb 0f       	add	r27, r27
    315c:	11 f4       	brne	.+4      	; 0x3162 <__floatsisf+0x36>
    315e:	60 ff       	sbrs	r22, 0
    3160:	1b c0       	rjmp	.+54     	; 0x3198 <__floatsisf+0x6c>
    3162:	6f 5f       	subi	r22, 0xFF	; 255
    3164:	7f 4f       	sbci	r23, 0xFF	; 255
    3166:	8f 4f       	sbci	r24, 0xFF	; 255
    3168:	9f 4f       	sbci	r25, 0xFF	; 255
    316a:	16 c0       	rjmp	.+44     	; 0x3198 <__floatsisf+0x6c>
    316c:	88 23       	and	r24, r24
    316e:	11 f0       	breq	.+4      	; 0x3174 <__floatsisf+0x48>
    3170:	96 e9       	ldi	r25, 0x96	; 150
    3172:	11 c0       	rjmp	.+34     	; 0x3196 <__floatsisf+0x6a>
    3174:	77 23       	and	r23, r23
    3176:	21 f0       	breq	.+8      	; 0x3180 <__floatsisf+0x54>
    3178:	9e e8       	ldi	r25, 0x8E	; 142
    317a:	87 2f       	mov	r24, r23
    317c:	76 2f       	mov	r23, r22
    317e:	05 c0       	rjmp	.+10     	; 0x318a <__floatsisf+0x5e>
    3180:	66 23       	and	r22, r22
    3182:	71 f0       	breq	.+28     	; 0x31a0 <__floatsisf+0x74>
    3184:	96 e8       	ldi	r25, 0x86	; 134
    3186:	86 2f       	mov	r24, r22
    3188:	70 e0       	ldi	r23, 0x00	; 0
    318a:	60 e0       	ldi	r22, 0x00	; 0
    318c:	2a f0       	brmi	.+10     	; 0x3198 <__floatsisf+0x6c>
    318e:	9a 95       	dec	r25
    3190:	66 0f       	add	r22, r22
    3192:	77 1f       	adc	r23, r23
    3194:	88 1f       	adc	r24, r24
    3196:	da f7       	brpl	.-10     	; 0x318e <__floatsisf+0x62>
    3198:	88 0f       	add	r24, r24
    319a:	96 95       	lsr	r25
    319c:	87 95       	ror	r24
    319e:	97 f9       	bld	r25, 7
    31a0:	08 95       	ret

000031a2 <__fp_cmp>:
    31a2:	99 0f       	add	r25, r25
    31a4:	00 08       	sbc	r0, r0
    31a6:	55 0f       	add	r21, r21
    31a8:	aa 0b       	sbc	r26, r26
    31aa:	e0 e8       	ldi	r30, 0x80	; 128
    31ac:	fe ef       	ldi	r31, 0xFE	; 254
    31ae:	16 16       	cp	r1, r22
    31b0:	17 06       	cpc	r1, r23
    31b2:	e8 07       	cpc	r30, r24
    31b4:	f9 07       	cpc	r31, r25
    31b6:	c0 f0       	brcs	.+48     	; 0x31e8 <__fp_cmp+0x46>
    31b8:	12 16       	cp	r1, r18
    31ba:	13 06       	cpc	r1, r19
    31bc:	e4 07       	cpc	r30, r20
    31be:	f5 07       	cpc	r31, r21
    31c0:	98 f0       	brcs	.+38     	; 0x31e8 <__fp_cmp+0x46>
    31c2:	62 1b       	sub	r22, r18
    31c4:	73 0b       	sbc	r23, r19
    31c6:	84 0b       	sbc	r24, r20
    31c8:	95 0b       	sbc	r25, r21
    31ca:	39 f4       	brne	.+14     	; 0x31da <__fp_cmp+0x38>
    31cc:	0a 26       	eor	r0, r26
    31ce:	61 f0       	breq	.+24     	; 0x31e8 <__fp_cmp+0x46>
    31d0:	23 2b       	or	r18, r19
    31d2:	24 2b       	or	r18, r20
    31d4:	25 2b       	or	r18, r21
    31d6:	21 f4       	brne	.+8      	; 0x31e0 <__fp_cmp+0x3e>
    31d8:	08 95       	ret
    31da:	0a 26       	eor	r0, r26
    31dc:	09 f4       	brne	.+2      	; 0x31e0 <__fp_cmp+0x3e>
    31de:	a1 40       	sbci	r26, 0x01	; 1
    31e0:	a6 95       	lsr	r26
    31e2:	8f ef       	ldi	r24, 0xFF	; 255
    31e4:	81 1d       	adc	r24, r1
    31e6:	81 1d       	adc	r24, r1
    31e8:	08 95       	ret

000031ea <__fp_inf>:
    31ea:	97 f9       	bld	r25, 7
    31ec:	9f 67       	ori	r25, 0x7F	; 127
    31ee:	80 e8       	ldi	r24, 0x80	; 128
    31f0:	70 e0       	ldi	r23, 0x00	; 0
    31f2:	60 e0       	ldi	r22, 0x00	; 0
    31f4:	08 95       	ret

000031f6 <__fp_nan>:
    31f6:	9f ef       	ldi	r25, 0xFF	; 255
    31f8:	80 ec       	ldi	r24, 0xC0	; 192
    31fa:	08 95       	ret

000031fc <__fp_pscA>:
    31fc:	00 24       	eor	r0, r0
    31fe:	0a 94       	dec	r0
    3200:	16 16       	cp	r1, r22
    3202:	17 06       	cpc	r1, r23
    3204:	18 06       	cpc	r1, r24
    3206:	09 06       	cpc	r0, r25
    3208:	08 95       	ret

0000320a <__fp_pscB>:
    320a:	00 24       	eor	r0, r0
    320c:	0a 94       	dec	r0
    320e:	12 16       	cp	r1, r18
    3210:	13 06       	cpc	r1, r19
    3212:	14 06       	cpc	r1, r20
    3214:	05 06       	cpc	r0, r21
    3216:	08 95       	ret

00003218 <__fp_round>:
    3218:	09 2e       	mov	r0, r25
    321a:	03 94       	inc	r0
    321c:	00 0c       	add	r0, r0
    321e:	11 f4       	brne	.+4      	; 0x3224 <__fp_round+0xc>
    3220:	88 23       	and	r24, r24
    3222:	52 f0       	brmi	.+20     	; 0x3238 <__fp_round+0x20>
    3224:	bb 0f       	add	r27, r27
    3226:	40 f4       	brcc	.+16     	; 0x3238 <__fp_round+0x20>
    3228:	bf 2b       	or	r27, r31
    322a:	11 f4       	brne	.+4      	; 0x3230 <__fp_round+0x18>
    322c:	60 ff       	sbrs	r22, 0
    322e:	04 c0       	rjmp	.+8      	; 0x3238 <__fp_round+0x20>
    3230:	6f 5f       	subi	r22, 0xFF	; 255
    3232:	7f 4f       	sbci	r23, 0xFF	; 255
    3234:	8f 4f       	sbci	r24, 0xFF	; 255
    3236:	9f 4f       	sbci	r25, 0xFF	; 255
    3238:	08 95       	ret

0000323a <__fp_split3>:
    323a:	57 fd       	sbrc	r21, 7
    323c:	90 58       	subi	r25, 0x80	; 128
    323e:	44 0f       	add	r20, r20
    3240:	55 1f       	adc	r21, r21
    3242:	59 f0       	breq	.+22     	; 0x325a <__fp_splitA+0x10>
    3244:	5f 3f       	cpi	r21, 0xFF	; 255
    3246:	71 f0       	breq	.+28     	; 0x3264 <__fp_splitA+0x1a>
    3248:	47 95       	ror	r20

0000324a <__fp_splitA>:
    324a:	88 0f       	add	r24, r24
    324c:	97 fb       	bst	r25, 7
    324e:	99 1f       	adc	r25, r25
    3250:	61 f0       	breq	.+24     	; 0x326a <__fp_splitA+0x20>
    3252:	9f 3f       	cpi	r25, 0xFF	; 255
    3254:	79 f0       	breq	.+30     	; 0x3274 <__fp_splitA+0x2a>
    3256:	87 95       	ror	r24
    3258:	08 95       	ret
    325a:	12 16       	cp	r1, r18
    325c:	13 06       	cpc	r1, r19
    325e:	14 06       	cpc	r1, r20
    3260:	55 1f       	adc	r21, r21
    3262:	f2 cf       	rjmp	.-28     	; 0x3248 <__fp_split3+0xe>
    3264:	46 95       	lsr	r20
    3266:	f1 df       	rcall	.-30     	; 0x324a <__fp_splitA>
    3268:	08 c0       	rjmp	.+16     	; 0x327a <__fp_splitA+0x30>
    326a:	16 16       	cp	r1, r22
    326c:	17 06       	cpc	r1, r23
    326e:	18 06       	cpc	r1, r24
    3270:	99 1f       	adc	r25, r25
    3272:	f1 cf       	rjmp	.-30     	; 0x3256 <__fp_splitA+0xc>
    3274:	86 95       	lsr	r24
    3276:	71 05       	cpc	r23, r1
    3278:	61 05       	cpc	r22, r1
    327a:	08 94       	sec
    327c:	08 95       	ret

0000327e <__fp_zero>:
    327e:	e8 94       	clt

00003280 <__fp_szero>:
    3280:	bb 27       	eor	r27, r27
    3282:	66 27       	eor	r22, r22
    3284:	77 27       	eor	r23, r23
    3286:	cb 01       	movw	r24, r22
    3288:	97 f9       	bld	r25, 7
    328a:	08 95       	ret

0000328c <__gesf2>:
    328c:	8a df       	rcall	.-236    	; 0x31a2 <__fp_cmp>
    328e:	08 f4       	brcc	.+2      	; 0x3292 <__gesf2+0x6>
    3290:	8f ef       	ldi	r24, 0xFF	; 255
    3292:	08 95       	ret

00003294 <__mulsf3>:
    3294:	0b d0       	rcall	.+22     	; 0x32ac <__mulsf3x>
    3296:	c0 cf       	rjmp	.-128    	; 0x3218 <__fp_round>
    3298:	b1 df       	rcall	.-158    	; 0x31fc <__fp_pscA>
    329a:	28 f0       	brcs	.+10     	; 0x32a6 <__mulsf3+0x12>
    329c:	b6 df       	rcall	.-148    	; 0x320a <__fp_pscB>
    329e:	18 f0       	brcs	.+6      	; 0x32a6 <__mulsf3+0x12>
    32a0:	95 23       	and	r25, r21
    32a2:	09 f0       	breq	.+2      	; 0x32a6 <__mulsf3+0x12>
    32a4:	a2 cf       	rjmp	.-188    	; 0x31ea <__fp_inf>
    32a6:	a7 cf       	rjmp	.-178    	; 0x31f6 <__fp_nan>
    32a8:	11 24       	eor	r1, r1
    32aa:	ea cf       	rjmp	.-44     	; 0x3280 <__fp_szero>

000032ac <__mulsf3x>:
    32ac:	c6 df       	rcall	.-116    	; 0x323a <__fp_split3>
    32ae:	a0 f3       	brcs	.-24     	; 0x3298 <__mulsf3+0x4>

000032b0 <__mulsf3_pse>:
    32b0:	95 9f       	mul	r25, r21
    32b2:	d1 f3       	breq	.-12     	; 0x32a8 <__mulsf3+0x14>
    32b4:	95 0f       	add	r25, r21
    32b6:	50 e0       	ldi	r21, 0x00	; 0
    32b8:	55 1f       	adc	r21, r21
    32ba:	62 9f       	mul	r22, r18
    32bc:	f0 01       	movw	r30, r0
    32be:	72 9f       	mul	r23, r18
    32c0:	bb 27       	eor	r27, r27
    32c2:	f0 0d       	add	r31, r0
    32c4:	b1 1d       	adc	r27, r1
    32c6:	63 9f       	mul	r22, r19
    32c8:	aa 27       	eor	r26, r26
    32ca:	f0 0d       	add	r31, r0
    32cc:	b1 1d       	adc	r27, r1
    32ce:	aa 1f       	adc	r26, r26
    32d0:	64 9f       	mul	r22, r20
    32d2:	66 27       	eor	r22, r22
    32d4:	b0 0d       	add	r27, r0
    32d6:	a1 1d       	adc	r26, r1
    32d8:	66 1f       	adc	r22, r22
    32da:	82 9f       	mul	r24, r18
    32dc:	22 27       	eor	r18, r18
    32de:	b0 0d       	add	r27, r0
    32e0:	a1 1d       	adc	r26, r1
    32e2:	62 1f       	adc	r22, r18
    32e4:	73 9f       	mul	r23, r19
    32e6:	b0 0d       	add	r27, r0
    32e8:	a1 1d       	adc	r26, r1
    32ea:	62 1f       	adc	r22, r18
    32ec:	83 9f       	mul	r24, r19
    32ee:	a0 0d       	add	r26, r0
    32f0:	61 1d       	adc	r22, r1
    32f2:	22 1f       	adc	r18, r18
    32f4:	74 9f       	mul	r23, r20
    32f6:	33 27       	eor	r19, r19
    32f8:	a0 0d       	add	r26, r0
    32fa:	61 1d       	adc	r22, r1
    32fc:	23 1f       	adc	r18, r19
    32fe:	84 9f       	mul	r24, r20
    3300:	60 0d       	add	r22, r0
    3302:	21 1d       	adc	r18, r1
    3304:	82 2f       	mov	r24, r18
    3306:	76 2f       	mov	r23, r22
    3308:	6a 2f       	mov	r22, r26
    330a:	11 24       	eor	r1, r1
    330c:	9f 57       	subi	r25, 0x7F	; 127
    330e:	50 40       	sbci	r21, 0x00	; 0
    3310:	8a f0       	brmi	.+34     	; 0x3334 <__mulsf3_pse+0x84>
    3312:	e1 f0       	breq	.+56     	; 0x334c <__mulsf3_pse+0x9c>
    3314:	88 23       	and	r24, r24
    3316:	4a f0       	brmi	.+18     	; 0x332a <__mulsf3_pse+0x7a>
    3318:	ee 0f       	add	r30, r30
    331a:	ff 1f       	adc	r31, r31
    331c:	bb 1f       	adc	r27, r27
    331e:	66 1f       	adc	r22, r22
    3320:	77 1f       	adc	r23, r23
    3322:	88 1f       	adc	r24, r24
    3324:	91 50       	subi	r25, 0x01	; 1
    3326:	50 40       	sbci	r21, 0x00	; 0
    3328:	a9 f7       	brne	.-22     	; 0x3314 <__mulsf3_pse+0x64>
    332a:	9e 3f       	cpi	r25, 0xFE	; 254
    332c:	51 05       	cpc	r21, r1
    332e:	70 f0       	brcs	.+28     	; 0x334c <__mulsf3_pse+0x9c>
    3330:	5c cf       	rjmp	.-328    	; 0x31ea <__fp_inf>
    3332:	a6 cf       	rjmp	.-180    	; 0x3280 <__fp_szero>
    3334:	5f 3f       	cpi	r21, 0xFF	; 255
    3336:	ec f3       	brlt	.-6      	; 0x3332 <__mulsf3_pse+0x82>
    3338:	98 3e       	cpi	r25, 0xE8	; 232
    333a:	dc f3       	brlt	.-10     	; 0x3332 <__mulsf3_pse+0x82>
    333c:	86 95       	lsr	r24
    333e:	77 95       	ror	r23
    3340:	67 95       	ror	r22
    3342:	b7 95       	ror	r27
    3344:	f7 95       	ror	r31
    3346:	e7 95       	ror	r30
    3348:	9f 5f       	subi	r25, 0xFF	; 255
    334a:	c1 f7       	brne	.-16     	; 0x333c <__mulsf3_pse+0x8c>
    334c:	fe 2b       	or	r31, r30
    334e:	88 0f       	add	r24, r24
    3350:	91 1d       	adc	r25, r1
    3352:	96 95       	lsr	r25
    3354:	87 95       	ror	r24
    3356:	97 f9       	bld	r25, 7
    3358:	08 95       	ret

0000335a <__divmodhi4>:
    335a:	97 fb       	bst	r25, 7
    335c:	07 2e       	mov	r0, r23
    335e:	16 f4       	brtc	.+4      	; 0x3364 <__divmodhi4+0xa>
    3360:	00 94       	com	r0
    3362:	06 d0       	rcall	.+12     	; 0x3370 <__divmodhi4_neg1>
    3364:	77 fd       	sbrc	r23, 7
    3366:	08 d0       	rcall	.+16     	; 0x3378 <__divmodhi4_neg2>
    3368:	0b d0       	rcall	.+22     	; 0x3380 <__udivmodhi4>
    336a:	07 fc       	sbrc	r0, 7
    336c:	05 d0       	rcall	.+10     	; 0x3378 <__divmodhi4_neg2>
    336e:	3e f4       	brtc	.+14     	; 0x337e <__divmodhi4_exit>

00003370 <__divmodhi4_neg1>:
    3370:	90 95       	com	r25
    3372:	81 95       	neg	r24
    3374:	9f 4f       	sbci	r25, 0xFF	; 255
    3376:	08 95       	ret

00003378 <__divmodhi4_neg2>:
    3378:	70 95       	com	r23
    337a:	61 95       	neg	r22
    337c:	7f 4f       	sbci	r23, 0xFF	; 255

0000337e <__divmodhi4_exit>:
    337e:	08 95       	ret

00003380 <__udivmodhi4>:
    3380:	aa 1b       	sub	r26, r26
    3382:	bb 1b       	sub	r27, r27
    3384:	51 e1       	ldi	r21, 0x11	; 17
    3386:	07 c0       	rjmp	.+14     	; 0x3396 <__udivmodhi4_ep>

00003388 <__udivmodhi4_loop>:
    3388:	aa 1f       	adc	r26, r26
    338a:	bb 1f       	adc	r27, r27
    338c:	a6 17       	cp	r26, r22
    338e:	b7 07       	cpc	r27, r23
    3390:	10 f0       	brcs	.+4      	; 0x3396 <__udivmodhi4_ep>
    3392:	a6 1b       	sub	r26, r22
    3394:	b7 0b       	sbc	r27, r23

00003396 <__udivmodhi4_ep>:
    3396:	88 1f       	adc	r24, r24
    3398:	99 1f       	adc	r25, r25
    339a:	5a 95       	dec	r21
    339c:	a9 f7       	brne	.-22     	; 0x3388 <__udivmodhi4_loop>
    339e:	80 95       	com	r24
    33a0:	90 95       	com	r25
    33a2:	bc 01       	movw	r22, r24
    33a4:	cd 01       	movw	r24, r26
    33a6:	08 95       	ret

000033a8 <memcmp>:
    33a8:	fb 01       	movw	r30, r22
    33aa:	dc 01       	movw	r26, r24
    33ac:	04 c0       	rjmp	.+8      	; 0x33b6 <memcmp+0xe>
    33ae:	8d 91       	ld	r24, X+
    33b0:	01 90       	ld	r0, Z+
    33b2:	80 19       	sub	r24, r0
    33b4:	21 f4       	brne	.+8      	; 0x33be <memcmp+0x16>
    33b6:	41 50       	subi	r20, 0x01	; 1
    33b8:	50 40       	sbci	r21, 0x00	; 0
    33ba:	c8 f7       	brcc	.-14     	; 0x33ae <memcmp+0x6>
    33bc:	88 1b       	sub	r24, r24
    33be:	99 0b       	sbc	r25, r25
    33c0:	08 95       	ret

000033c2 <memcpy>:
    33c2:	fb 01       	movw	r30, r22
    33c4:	dc 01       	movw	r26, r24
    33c6:	02 c0       	rjmp	.+4      	; 0x33cc <memcpy+0xa>
    33c8:	01 90       	ld	r0, Z+
    33ca:	0d 92       	st	X+, r0
    33cc:	41 50       	subi	r20, 0x01	; 1
    33ce:	50 40       	sbci	r21, 0x00	; 0
    33d0:	d8 f7       	brcc	.-10     	; 0x33c8 <memcpy+0x6>
    33d2:	08 95       	ret

000033d4 <memset>:
    33d4:	dc 01       	movw	r26, r24
    33d6:	01 c0       	rjmp	.+2      	; 0x33da <memset+0x6>
    33d8:	6d 93       	st	X+, r22
    33da:	41 50       	subi	r20, 0x01	; 1
    33dc:	50 40       	sbci	r21, 0x00	; 0
    33de:	e0 f7       	brcc	.-8      	; 0x33d8 <memset+0x4>
    33e0:	08 95       	ret

000033e2 <strncpy>:
    33e2:	fb 01       	movw	r30, r22
    33e4:	dc 01       	movw	r26, r24
    33e6:	41 50       	subi	r20, 0x01	; 1
    33e8:	50 40       	sbci	r21, 0x00	; 0
    33ea:	48 f0       	brcs	.+18     	; 0x33fe <strncpy+0x1c>
    33ec:	01 90       	ld	r0, Z+
    33ee:	0d 92       	st	X+, r0
    33f0:	00 20       	and	r0, r0
    33f2:	c9 f7       	brne	.-14     	; 0x33e6 <strncpy+0x4>
    33f4:	01 c0       	rjmp	.+2      	; 0x33f8 <strncpy+0x16>
    33f6:	1d 92       	st	X+, r1
    33f8:	41 50       	subi	r20, 0x01	; 1
    33fa:	50 40       	sbci	r21, 0x00	; 0
    33fc:	e0 f7       	brcc	.-8      	; 0x33f6 <strncpy+0x14>
    33fe:	08 95       	ret

00003400 <_exit>:
    3400:	f8 94       	cli

00003402 <__stop_program>:
    3402:	ff cf       	rjmp	.-2      	; 0x3402 <__stop_program>
